// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"j8273":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 57014;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "cb5ea115f72d0d54";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"4ZGjQ":[function(require,module,exports,__globalThis) {
var _stargate = require("@cosmjs/stargate");
var _protoSigning = require("@cosmjs/proto-signing");
window.addEventListener('load', ()=>{
    const approveButton = document.getElementById('approve-button');
    const statusElement = document.getElementById('status');
    approveButton.addEventListener('click', async ()=>{
        console.log('Approve button clicked');
        if (!window.keplr) {
            statusElement.textContent = "Error: Keplr Wallet not found.";
            statusElement.style.color = "red";
            console.error('Keplr not found');
            return;
        }
        console.log('Keplr found');
        const chainId = "mocha-4";
        const chainInfo = {
            chainId: chainId,
            chainName: "Celestia Mocha Testnet",
            rpc: "https://celestia-testnet-rpc.polkachu.com",
            bip44: {
                coinType: 118
            },
            bech32Config: {
                bech32PrefixAccAddr: "celestia",
                bech32PrefixAccPub: "celestiapub",
                bech32PrefixValAddr: "celestiavaloper",
                bech32PrefixValPub: "celestiavaloperpub",
                bech32PrefixConsAddr: "celestiavalcons",
                bech32PrefixConsPub: "celestiavalconspub"
            },
            currencies: [
                {
                    coinDenom: "TIA",
                    coinMinimalDenom: "utia",
                    coinDecimals: 6
                }
            ],
            feeCurrencies: [
                {
                    coinDenom: "TIA",
                    coinMinimalDenom: "utia",
                    coinDecimals: 6
                }
            ],
            stakeCurrency: {
                coinDenom: "TIA",
                coinMinimalDenom: "utia",
                coinDecimals: 6
            },
            gasPriceStep: {
                low: 0.01,
                average: 0.02,
                high: 0.03
            }
        };
        try {
            console.log('Suggesting chain');
            await window.keplr.experimentalSuggestChain(chainInfo);
            console.log('Chain suggested');
            console.log('Enabling chain');
            await window.keplr.enable(chainId);
            console.log('Chain enabled');
            console.log('Getting offline signer');
            const offlineSigner = window.keplr.getOfflineSignerOnlyAmino(chainId);
            console.log('Offline signer obtained');
            console.log('Getting accounts');
            const accounts = await offlineSigner.getAccounts();
            const senderAddress = accounts[0].address;
            console.log('Accounts obtained:', senderAddress);
            statusElement.textContent = "Preparing transaction...";
            statusElement.style.color = "#333";
            // Connect to the RPC endpoint
            const rpcEndpoint = chainInfo.rpc;
            const client = await (0, _stargate.SigningStargateClient).connectWithSigner(rpcEndpoint, offlineSigner);
            // Get account details using RPC
            console.log('Fetching account details via RPC');
            const account = await client.getAccount(senderAddress);
            if (!account) throw new Error("Account not found on chain.");
            const accountNumber = account.accountNumber;
            const sequence = account.sequence;
            console.log('Account details fetched:', {
                accountNumber,
                sequence
            });
            const msg = {
                type: "cosmos-sdk/MsgSend",
                value: {
                    from_address: senderAddress,
                    to_address: "celestia1jjsduzgd4euahh208rv2p53y2w5heggy5cgkh5",
                    amount: [
                        {
                            denom: "utia",
                            amount: "100"
                        }
                    ]
                }
            };
            const fee = {
                amount: [
                    {
                        denom: "utia",
                        amount: "5000"
                    }
                ],
                gas: "200000"
            };
            const memo = "Transaction from Godot DApp";
            // Sign and broadcast the transaction using RPC
            console.log('Signing and broadcasting transaction');
            const result = await client.signAndBroadcast(senderAddress, [
                msg
            ], fee, memo);
            console.log('Transaction broadcasted', result);
            if (result.code !== undefined && result.code !== 0) throw new Error(result.rawLog);
            statusElement.textContent = `Success! Tx Hash: ${result.transactionHash}`;
            statusElement.style.color = "green";
        } catch (error) {
            statusElement.textContent = `Error: ${error.message}`;
            statusElement.style.color = "red";
            console.error('An error occurred:', error);
        }
    });
});

},{"@cosmjs/stargate":"4T8IB","@cosmjs/proto-signing":"2gdyE"}],"4T8IB":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgTransfer = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateVestingAccount = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createVestingAminoConverters = exports.createStakingAminoConverters = exports.createSlashingAminoConverters = exports.createIbcAminoConverters = exports.createGroupAminoConverters = exports.createGovAminoConverters = exports.createFeegrantAminoConverters = exports.createEvidenceAminoConverters = exports.createDistributionAminoConverters = exports.createCrysisAminoConverters = exports.createBankAminoConverters = exports.createAuthzAminoConverters = exports.logs = exports.GasPrice = exports.calculateFee = exports.fromTendermintEvent = exports.AminoTypes = exports.accountFromAny = void 0;
exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.BroadcastTxError = exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.createDefaultAminoConverters = exports.isSearchTxQueryArray = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.setupTxExtension = exports.setupStakingExtension = exports.setupSlashingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupFeegrantExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthzExtension = exports.setupAuthExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
var accounts_1 = require("bc82617f3111c416");
Object.defineProperty(exports, "accountFromAny", {
    enumerable: true,
    get: function() {
        return accounts_1.accountFromAny;
    }
});
var aminotypes_1 = require("3c79329cdfd66040");
Object.defineProperty(exports, "AminoTypes", {
    enumerable: true,
    get: function() {
        return aminotypes_1.AminoTypes;
    }
});
var events_1 = require("8affbc4ee5cc27a0");
Object.defineProperty(exports, "fromTendermintEvent", {
    enumerable: true,
    get: function() {
        return events_1.fromTendermintEvent;
    }
});
var fee_1 = require("be9e3a37759b3463");
Object.defineProperty(exports, "calculateFee", {
    enumerable: true,
    get: function() {
        return fee_1.calculateFee;
    }
});
Object.defineProperty(exports, "GasPrice", {
    enumerable: true,
    get: function() {
        return fee_1.GasPrice;
    }
});
exports.logs = __importStar(require("d4cf09b912da011d"));
var modules_1 = require("e59e651f097fa17a");
Object.defineProperty(exports, "createAuthzAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createAuthzAminoConverters;
    }
});
Object.defineProperty(exports, "createBankAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createBankAminoConverters;
    }
});
Object.defineProperty(exports, "createCrysisAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createCrysisAminoConverters;
    }
});
Object.defineProperty(exports, "createDistributionAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createDistributionAminoConverters;
    }
});
Object.defineProperty(exports, "createEvidenceAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createEvidenceAminoConverters;
    }
});
Object.defineProperty(exports, "createFeegrantAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createFeegrantAminoConverters;
    }
});
Object.defineProperty(exports, "createGovAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createGovAminoConverters;
    }
});
Object.defineProperty(exports, "createGroupAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createGroupAminoConverters;
    }
});
Object.defineProperty(exports, "createIbcAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createIbcAminoConverters;
    }
});
Object.defineProperty(exports, "createSlashingAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createSlashingAminoConverters;
    }
});
Object.defineProperty(exports, "createStakingAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createStakingAminoConverters;
    }
});
Object.defineProperty(exports, "createVestingAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createVestingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgBeginRedelegate", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgBeginRedelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateValidator", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgCreateValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgCreateVestingAccount;
    }
});
Object.defineProperty(exports, "isAminoMsgDelegate", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgDelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgDeposit", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgDeposit;
    }
});
Object.defineProperty(exports, "isAminoMsgEditValidator", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgEditValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgFundCommunityPool", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgFundCommunityPool;
    }
});
Object.defineProperty(exports, "isAminoMsgMultiSend", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgMultiSend;
    }
});
Object.defineProperty(exports, "isAminoMsgSend", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSend;
    }
});
Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSetWithdrawAddress;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitEvidence", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSubmitEvidence;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitProposal", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSubmitProposal;
    }
});
Object.defineProperty(exports, "isAminoMsgTransfer", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgTransfer;
    }
});
Object.defineProperty(exports, "isAminoMsgUndelegate", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgUndelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgUnjail", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgUnjail;
    }
});
Object.defineProperty(exports, "isAminoMsgVerifyInvariant", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgVerifyInvariant;
    }
});
Object.defineProperty(exports, "isAminoMsgVote", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgVote;
    }
});
Object.defineProperty(exports, "isAminoMsgVoteWeighted", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgVoteWeighted;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgWithdrawDelegatorReward;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgWithdrawValidatorCommission;
    }
});
Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgBeginRedelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgCreateValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgDelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgDelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgDepositEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgDepositEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgEditValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgSendEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgSendEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgSubmitProposalEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgTransferEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgTransferEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgUndelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgUndelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgVoteEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgVoteWeightedEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    }
});
Object.defineProperty(exports, "setupAuthExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupAuthExtension;
    }
});
Object.defineProperty(exports, "setupAuthzExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupAuthzExtension;
    }
});
Object.defineProperty(exports, "setupBankExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupBankExtension;
    }
});
Object.defineProperty(exports, "setupDistributionExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupDistributionExtension;
    }
});
Object.defineProperty(exports, "setupFeegrantExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupFeegrantExtension;
    }
});
Object.defineProperty(exports, "setupGovExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupGovExtension;
    }
});
Object.defineProperty(exports, "setupIbcExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupIbcExtension;
    }
});
Object.defineProperty(exports, "setupMintExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupMintExtension;
    }
});
Object.defineProperty(exports, "setupSlashingExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupSlashingExtension;
    }
});
Object.defineProperty(exports, "setupStakingExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupStakingExtension;
    }
});
Object.defineProperty(exports, "setupTxExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupTxExtension;
    }
});
var multisignature_1 = require("1f3e59b963d67c61");
Object.defineProperty(exports, "makeMultisignedTx", {
    enumerable: true,
    get: function() {
        return multisignature_1.makeMultisignedTx;
    }
});
Object.defineProperty(exports, "makeMultisignedTxBytes", {
    enumerable: true,
    get: function() {
        return multisignature_1.makeMultisignedTxBytes;
    }
});
var queryclient_1 = require("845247f1eb946446");
Object.defineProperty(exports, "createPagination", {
    enumerable: true,
    get: function() {
        return queryclient_1.createPagination;
    }
});
Object.defineProperty(exports, "createProtobufRpcClient", {
    enumerable: true,
    get: function() {
        return queryclient_1.createProtobufRpcClient;
    }
});
Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", {
    enumerable: true,
    get: function() {
        return queryclient_1.decodeCosmosSdkDecFromProto;
    }
});
Object.defineProperty(exports, "QueryClient", {
    enumerable: true,
    get: function() {
        return queryclient_1.QueryClient;
    }
});
var search_1 = require("c2ec7b767d6bdf25");
Object.defineProperty(exports, "isSearchTxQueryArray", {
    enumerable: true,
    get: function() {
        return search_1.isSearchTxQueryArray;
    }
});
var signingstargateclient_1 = require("644669fede6457af");
Object.defineProperty(exports, "createDefaultAminoConverters", {
    enumerable: true,
    get: function() {
        return signingstargateclient_1.createDefaultAminoConverters;
    }
});
Object.defineProperty(exports, "defaultRegistryTypes", {
    enumerable: true,
    get: function() {
        return signingstargateclient_1.defaultRegistryTypes;
    }
});
Object.defineProperty(exports, "SigningStargateClient", {
    enumerable: true,
    get: function() {
        return signingstargateclient_1.SigningStargateClient;
    }
});
var stargateclient_1 = require("403d9d6fd440339a");
Object.defineProperty(exports, "assertIsDeliverTxFailure", {
    enumerable: true,
    get: function() {
        return stargateclient_1.assertIsDeliverTxFailure;
    }
});
Object.defineProperty(exports, "assertIsDeliverTxSuccess", {
    enumerable: true,
    get: function() {
        return stargateclient_1.assertIsDeliverTxSuccess;
    }
});
Object.defineProperty(exports, "BroadcastTxError", {
    enumerable: true,
    get: function() {
        return stargateclient_1.BroadcastTxError;
    }
});
Object.defineProperty(exports, "isDeliverTxFailure", {
    enumerable: true,
    get: function() {
        return stargateclient_1.isDeliverTxFailure;
    }
});
Object.defineProperty(exports, "isDeliverTxSuccess", {
    enumerable: true,
    get: function() {
        return stargateclient_1.isDeliverTxSuccess;
    }
});
Object.defineProperty(exports, "StargateClient", {
    enumerable: true,
    get: function() {
        return stargateclient_1.StargateClient;
    }
});
Object.defineProperty(exports, "TimeoutError", {
    enumerable: true,
    get: function() {
        return stargateclient_1.TimeoutError;
    }
});
var proto_signing_1 = require("f38410a9486e8190");
Object.defineProperty(exports, "coin", {
    enumerable: true,
    get: function() {
        return proto_signing_1.coin;
    }
});
Object.defineProperty(exports, "coins", {
    enumerable: true,
    get: function() {
        return proto_signing_1.coins;
    }
});
Object.defineProperty(exports, "makeCosmoshubPath", {
    enumerable: true,
    get: function() {
        return proto_signing_1.makeCosmoshubPath;
    }
});
Object.defineProperty(exports, "parseCoins", {
    enumerable: true,
    get: function() {
        return proto_signing_1.parseCoins;
    }
});

},{"bc82617f3111c416":"inL4M","3c79329cdfd66040":"7vdok","8affbc4ee5cc27a0":"UX70m","be9e3a37759b3463":"3phn0","d4cf09b912da011d":"988PF","e59e651f097fa17a":"MIuAK","1f3e59b963d67c61":"2rnY4","845247f1eb946446":"cM4fi","c2ec7b767d6bdf25":"8KORu","644669fede6457af":"hcImJ","403d9d6fd440339a":"f7GTj","f38410a9486e8190":"2gdyE"}],"inL4M":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.accountFromAny = accountFromAny;
const math_1 = require("f6a1fcc38a9dacb8");
const proto_signing_1 = require("c588b22f60755f39");
const utils_1 = require("ad52d5e38416d906");
const auth_1 = require("47e304600f22f91");
const vesting_1 = require("e47152263e197f39");
function uint64FromProto(input) {
    return math_1.Uint64.fromString(input.toString());
}
function accountFromBaseAccount(input) {
    const { address, pubKey, accountNumber, sequence } = input;
    const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
    return {
        address: address,
        pubkey: pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
    };
}
/**
 * Basic implementation of AccountParser. This is supposed to support the most relevant
 * common Cosmos SDK account types. If you need support for exotic account types,
 * you'll need to write your own account decoder.
 */ function accountFromAny(input) {
    const { typeUrl, value } = input;
    switch(typeUrl){
        // auth
        case "/cosmos.auth.v1beta1.BaseAccount":
            return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount":
            {
                const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        // vesting
        case "/cosmos.vesting.v1beta1.BaseVestingAccount":
            {
                const baseAccount = vesting_1.BaseVestingAccount.decode(value)?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount":
            {
                const baseAccount = vesting_1.ContinuousVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount":
            {
                const baseAccount = vesting_1.DelayedVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount":
            {
                const baseAccount = vesting_1.PeriodicVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        default:
            throw new Error(`Unsupported type: '${typeUrl}'`);
    }
}

},{"f6a1fcc38a9dacb8":"e8aug","c588b22f60755f39":"2gdyE","ad52d5e38416d906":"3R4mb","47e304600f22f91":"1HQnV","e47152263e197f39":"5O0Qj"}],"e8aug":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;
var decimal_1 = require("d0c6bb22686007db");
Object.defineProperty(exports, "Decimal", {
    enumerable: true,
    get: function() {
        return decimal_1.Decimal;
    }
});
var integers_1 = require("7d074c9904101e2c");
Object.defineProperty(exports, "Int53", {
    enumerable: true,
    get: function() {
        return integers_1.Int53;
    }
});
Object.defineProperty(exports, "Uint32", {
    enumerable: true,
    get: function() {
        return integers_1.Uint32;
    }
});
Object.defineProperty(exports, "Uint53", {
    enumerable: true,
    get: function() {
        return integers_1.Uint53;
    }
});
Object.defineProperty(exports, "Uint64", {
    enumerable: true,
    get: function() {
        return integers_1.Uint64;
    }
});

},{"d0c6bb22686007db":"92sYf","7d074c9904101e2c":"JCXGc"}],"92sYf":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Decimal = void 0;
// Too large values lead to massive memory usage. Limit to something sensible.
// The largest value we need is 18 (Ether).
const maxFractionalDigits = 100;
/**
 * A type for arbitrary precision, non-negative decimals.
 *
 * Instances of this class are immutable.
 */ class Decimal {
    static fromUserInput(input, fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        let whole;
        let fractional;
        if (input === "") {
            whole = "0";
            fractional = "";
        } else if (input.search(/\./) === -1) {
            // integer format, no separator
            whole = input;
            fractional = "";
        } else {
            const parts = input.split(".");
            switch(parts.length){
                case 0:
                case 1:
                    throw new Error("Fewer than two elements in split result. This must not happen here.");
                case 2:
                    if (!parts[1]) throw new Error("Fractional part missing");
                    whole = parts[0];
                    fractional = parts[1].replace(/0+$/, "");
                    break;
                default:
                    throw new Error("More than one separator found");
            }
        }
        if (fractional.length > fractionalDigits) throw new Error("Got more fractional digits than supported");
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new Decimal(quantity, fractionalDigits);
    }
    static fromAtomics(atomics, fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal(atomics, fractionalDigits);
    }
    /**
     * Creates a Decimal with value 0.0 and the given number of fractional digits.
     *
     * Fractional digits are not relevant for the value but needed to be able
     * to perform arithmetic operations with other decimals.
     */ static zero(fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal("0", fractionalDigits);
    }
    /**
     * Creates a Decimal with value 1.0 and the given number of fractional digits.
     *
     * Fractional digits are not relevant for the value but needed to be able
     * to perform arithmetic operations with other decimals.
     */ static one(fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
    }
    static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits)) throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0) throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
    }
    static compare(a, b) {
        if (a.fractionalDigits !== b.fractionalDigits) throw new Error("Fractional digits do not match");
        const difference = a.data.atomics - b.data.atomics;
        if (difference < 0n) return -1;
        if (difference > 0n) return 1;
        return 0;
    }
    get atomics() {
        return this.data.atomics.toString();
    }
    get fractionalDigits() {
        return this.data.fractionalDigits;
    }
    data;
    constructor(atomics, fractionalDigits){
        if (!atomics.match(/^[0-9]+$/)) throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        this.data = {
            atomics: BigInt(atomics),
            fractionalDigits: fractionalDigits
        };
    }
    /** Creates a new instance with the same value */ clone() {
        return new Decimal(this.atomics, this.fractionalDigits);
    }
    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */ floor() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) return this.clone();
        else return Decimal.fromAtomics((whole * factor).toString(), this.fractionalDigits);
    }
    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */ ceil() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) return this.clone();
        else return Decimal.fromAtomics(((whole + 1n) * factor).toString(), this.fractionalDigits);
    }
    toString() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) return whole.toString();
        else {
            const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
            return `${whole.toString()}.${trimmedFractionalPart}`;
        }
    }
    /**
     * Returns an approximation as a float type. Only use this if no
     * exact calculation is required.
     */ toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out)) throw new Error("Conversion to number failed");
        return out;
    }
    /**
     * a.plus(b) returns a+b.
     *
     * Both values need to have the same fractional digits.
     */ plus(b) {
        if (this.fractionalDigits !== b.fractionalDigits) throw new Error("Fractional digits do not match");
        const sum = this.data.atomics + b.data.atomics;
        return new Decimal(sum.toString(), this.fractionalDigits);
    }
    /**
     * a.minus(b) returns a-b.
     *
     * Both values need to have the same fractional digits.
     * The resulting difference needs to be non-negative.
     */ minus(b) {
        if (this.fractionalDigits !== b.fractionalDigits) throw new Error("Fractional digits do not match");
        const difference = this.data.atomics - b.data.atomics;
        if (difference < 0n) throw new Error("Difference must not be negative");
        return new Decimal(difference.toString(), this.fractionalDigits);
    }
    /**
     * a.multiply(b) returns a*b.
     *
     * We only allow multiplication by unsigned integers to avoid rounding errors.
     */ multiply(b) {
        const product = this.data.atomics * b.toBigInt();
        return new Decimal(product.toString(), this.fractionalDigits);
    }
    equals(b) {
        return Decimal.compare(this, b) === 0;
    }
    isLessThan(b) {
        return Decimal.compare(this, b) < 0;
    }
    isLessThanOrEqual(b) {
        return Decimal.compare(this, b) <= 0;
    }
    isGreaterThan(b) {
        return Decimal.compare(this, b) > 0;
    }
    isGreaterThanOrEqual(b) {
        return Decimal.compare(this, b) >= 0;
    }
}
exports.Decimal = Decimal;

},{}],"JCXGc":[function(require,module,exports,__globalThis) {
"use strict";
/* eslint-disable no-bitwise */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;
const uint64MaxValue = 18446744073709551615n;
class Uint32 {
    /** @deprecated use Uint32.fromBytes */ static fromBigEndianBytes(bytes) {
        return Uint32.fromBytes(bytes);
    }
    /**
     * Creates a Uint32 from a fixed length byte array.
     *
     * @param bytes a list of exactly 4 bytes
     * @param endianness defaults to big endian
     */ static fromBytes(bytes, endianness = "be") {
        if (bytes.length !== 4) throw new Error("Invalid input length. Expected 4 bytes.");
        for(let i = 0; i < bytes.length; ++i){
            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) throw new Error(`Invalid value in byte. Found: ${bytes[i]}`);
        }
        const beBytes = endianness === "be" ? bytes : Array.from(bytes).reverse();
        // Use multiplication instead of shifting since bitwise operators are defined
        // on SIGNED int32 in JavaScript and we don't want to risk surprises
        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 256 + beBytes[3]);
    }
    static fromString(str) {
        if (!str.match(/^[0-9]+$/)) throw new Error("Invalid string format");
        return new Uint32(Number.parseInt(str, 10));
    }
    data;
    constructor(input){
        if (Number.isNaN(input)) throw new Error("Input is not a number");
        if (!Number.isInteger(input)) throw new Error("Input is not an integer");
        if (input < 0 || input > 4294967295) throw new Error("Input not in uint32 range: " + input.toString());
        this.data = input;
    }
    toBytesBigEndian() {
        // Use division instead of shifting since bitwise operators are defined
        // on SIGNED int32 in JavaScript and we don't want to risk surprises
        return new Uint8Array([
            Math.floor(this.data / 2 ** 24) & 0xff,
            Math.floor(this.data / 2 ** 16) & 0xff,
            Math.floor(this.data / 256) & 0xff,
            Math.floor(this.data / 1) & 0xff
        ]);
    }
    toBytesLittleEndian() {
        // Use division instead of shifting since bitwise operators are defined
        // on SIGNED int32 in JavaScript and we don't want to risk surprises
        return new Uint8Array([
            Math.floor(this.data / 1) & 0xff,
            Math.floor(this.data / 256) & 0xff,
            Math.floor(this.data / 2 ** 16) & 0xff,
            Math.floor(this.data / 2 ** 24) & 0xff
        ]);
    }
    toNumber() {
        return this.data;
    }
    toBigInt() {
        return BigInt(this.toNumber());
    }
    toString() {
        return this.data.toString();
    }
}
exports.Uint32 = Uint32;
class Int53 {
    static fromString(str) {
        if (!str.match(/^-?[0-9]+$/)) throw new Error("Invalid string format");
        return new Int53(Number.parseInt(str, 10));
    }
    data;
    constructor(input){
        if (Number.isNaN(input)) throw new Error("Input is not a number");
        if (!Number.isInteger(input)) throw new Error("Input is not an integer");
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) throw new Error("Input not in int53 range: " + input.toString());
        this.data = input;
    }
    toNumber() {
        return this.data;
    }
    toBigInt() {
        return BigInt(this.toNumber());
    }
    toString() {
        return this.data.toString();
    }
}
exports.Int53 = Int53;
class Uint53 {
    static fromString(str) {
        const signed = Int53.fromString(str);
        return new Uint53(signed.toNumber());
    }
    data;
    constructor(input){
        const signed = new Int53(input);
        if (signed.toNumber() < 0) throw new Error("Input is negative");
        this.data = signed;
    }
    toNumber() {
        return this.data.toNumber();
    }
    toBigInt() {
        return BigInt(this.toNumber());
    }
    toString() {
        return this.data.toString();
    }
}
exports.Uint53 = Uint53;
class Uint64 {
    /** @deprecated use Uint64.fromBytes */ static fromBytesBigEndian(bytes) {
        return Uint64.fromBytes(bytes);
    }
    /**
     * Creates a Uint64 from a fixed length byte array.
     *
     * @param bytes a list of exactly 8 bytes
     * @param endianness defaults to big endian
     */ static fromBytes(bytes, endianness = "be") {
        if (bytes.length !== 8) throw new Error("Invalid input length. Expected 8 bytes.");
        const beBytes = endianness === "be" ? Array.from(bytes) : Array.from(bytes).reverse();
        let value = 0n;
        for (const byte of beBytes){
            value *= 256n;
            if (!Number.isInteger(byte) || byte > 255 || byte < 0) throw new Error(`Invalid value in byte. Found: ${byte}`);
            value += BigInt(byte);
        }
        return new Uint64(value);
    }
    static fromString(str) {
        if (!str.match(/^[0-9]+$/)) throw new Error("Invalid string format");
        return new Uint64(BigInt(str));
    }
    static fromNumber(input) {
        if (Number.isNaN(input)) throw new Error("Input is not a number");
        if (!Number.isInteger(input)) throw new Error("Input is not an integer");
        if (!Number.isSafeInteger(input)) throw new Error("Input is not a safe integer");
        const bigint = BigInt(input);
        return new Uint64(bigint);
    }
    data;
    constructor(data){
        if (data < 0n) throw new Error("Input is negative");
        if (data > uint64MaxValue) throw new Error("Input exceeds uint64 range");
        this.data = data;
    }
    toBytesBigEndian() {
        return this.toBytesLittleEndian().reverse();
    }
    toBytesLittleEndian() {
        const bytes = new Uint8Array(8);
        let value = this.data;
        for(let i = 0; i < bytes.length; i++){
            bytes[i] = Number(value % 256n);
            value /= 256n;
        }
        return bytes;
    }
    toString() {
        return this.data.toString(10);
    }
    toBigInt() {
        return this.data;
    }
    toNumber() {
        if (this.data > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error("number can only safely store up to 53 bits");
        const num = Number(this.data);
        return num;
    }
}
exports.Uint64 = Uint64;
// Assign classes to unused variables in order to verify static interface conformance at compile time.
// Workaround for https://github.com/microsoft/TypeScript/issues/33892
const _int53Class = Int53;
const _uint53Class = Uint53;
const _uint32Class = Uint32;
const _uint64Class = Uint64;

},{}],"2gdyE":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseCoins = exports.coins = exports.coin = exports.executeKdf = exports.makeSignDoc = exports.makeSignBytes = exports.makeAuthInfoBytes = exports.isOfflineDirectSigner = exports.Registry = exports.isTxBodyEncodeObject = exports.isTsProtoGeneratedType = exports.isPbjsGeneratedType = exports.encodePubkey = exports.decodePubkey = exports.decodeOptionalPubkey = exports.anyToSinglePubkey = exports.makeCosmoshubPath = exports.DirectSecp256k1Wallet = exports.extractKdfConfiguration = exports.DirectSecp256k1HdWallet = exports.decodeTxRaw = void 0;
// This type happens to be shared between Amino and Direct sign modes
var decode_1 = require("245bd8943034fa38");
Object.defineProperty(exports, "decodeTxRaw", {
    enumerable: true,
    get: function() {
        return decode_1.decodeTxRaw;
    }
});
var directsecp256k1hdwallet_1 = require("8d5b3e5cc318db66");
Object.defineProperty(exports, "DirectSecp256k1HdWallet", {
    enumerable: true,
    get: function() {
        return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    }
});
Object.defineProperty(exports, "extractKdfConfiguration", {
    enumerable: true,
    get: function() {
        return directsecp256k1hdwallet_1.extractKdfConfiguration;
    }
});
var directsecp256k1wallet_1 = require("179742365fd3b7f6");
Object.defineProperty(exports, "DirectSecp256k1Wallet", {
    enumerable: true,
    get: function() {
        return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    }
});
var paths_1 = require("e4dd86363ee49c9a");
Object.defineProperty(exports, "makeCosmoshubPath", {
    enumerable: true,
    get: function() {
        return paths_1.makeCosmoshubPath;
    }
});
var pubkey_1 = require("967af73e36cf7525");
Object.defineProperty(exports, "anyToSinglePubkey", {
    enumerable: true,
    get: function() {
        return pubkey_1.anyToSinglePubkey;
    }
});
Object.defineProperty(exports, "decodeOptionalPubkey", {
    enumerable: true,
    get: function() {
        return pubkey_1.decodeOptionalPubkey;
    }
});
Object.defineProperty(exports, "decodePubkey", {
    enumerable: true,
    get: function() {
        return pubkey_1.decodePubkey;
    }
});
Object.defineProperty(exports, "encodePubkey", {
    enumerable: true,
    get: function() {
        return pubkey_1.encodePubkey;
    }
});
var registry_1 = require("b20774c7b4cc1f50");
Object.defineProperty(exports, "isPbjsGeneratedType", {
    enumerable: true,
    get: function() {
        return registry_1.isPbjsGeneratedType;
    }
});
Object.defineProperty(exports, "isTsProtoGeneratedType", {
    enumerable: true,
    get: function() {
        return registry_1.isTsProtoGeneratedType;
    }
});
Object.defineProperty(exports, "isTxBodyEncodeObject", {
    enumerable: true,
    get: function() {
        return registry_1.isTxBodyEncodeObject;
    }
});
Object.defineProperty(exports, "Registry", {
    enumerable: true,
    get: function() {
        return registry_1.Registry;
    }
});
var signer_1 = require("98a319aab5de40be");
Object.defineProperty(exports, "isOfflineDirectSigner", {
    enumerable: true,
    get: function() {
        return signer_1.isOfflineDirectSigner;
    }
});
var signing_1 = require("4573690332383cd8");
Object.defineProperty(exports, "makeAuthInfoBytes", {
    enumerable: true,
    get: function() {
        return signing_1.makeAuthInfoBytes;
    }
});
Object.defineProperty(exports, "makeSignBytes", {
    enumerable: true,
    get: function() {
        return signing_1.makeSignBytes;
    }
});
Object.defineProperty(exports, "makeSignDoc", {
    enumerable: true,
    get: function() {
        return signing_1.makeSignDoc;
    }
});
var wallet_1 = require("84bd11382476e1ba");
Object.defineProperty(exports, "executeKdf", {
    enumerable: true,
    get: function() {
        return wallet_1.executeKdf;
    }
});
var amino_1 = require("eff4536ac3a44065");
Object.defineProperty(exports, "coin", {
    enumerable: true,
    get: function() {
        return amino_1.coin;
    }
});
Object.defineProperty(exports, "coins", {
    enumerable: true,
    get: function() {
        return amino_1.coins;
    }
});
Object.defineProperty(exports, "parseCoins", {
    enumerable: true,
    get: function() {
        return amino_1.parseCoins;
    }
});

},{"245bd8943034fa38":"5BGzx","8d5b3e5cc318db66":"3XRYb","179742365fd3b7f6":"cfdjd","e4dd86363ee49c9a":"4CrS9","967af73e36cf7525":"jKcfJ","b20774c7b4cc1f50":"29um8","98a319aab5de40be":"aav1G","4573690332383cd8":"g8GJ3","84bd11382476e1ba":"3QlLM","eff4536ac3a44065":"bh8mf"}],"5BGzx":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeTxRaw = decodeTxRaw;
const tx_1 = require("39082517e7a6e6ad");
/**
 * Takes a serialized TxRaw (the bytes stored in Tendermint) and decodes it into something usable.
 */ function decodeTxRaw(tx) {
    const txRaw = tx_1.TxRaw.decode(tx);
    return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
    };
}

},{"39082517e7a6e6ad":"dbom9"}],"dbom9":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuxSignerData = exports.Tip = exports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDocDirectAux = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("2fc92ab2c36bdab6");
const signing_1 = require("e6276eb27dd2fcb6");
const multisig_1 = require("926bd3d9b4261655");
const coin_1 = require("76624f4af9fa8795");
const binary_1 = require("6ee1dac8bf663c42");
const helpers_1 = require("d817877c78ac1068");
exports.protobufPackage = "cosmos.tx.v1beta1";
function createBaseTx() {
    return {
        body: undefined,
        authInfo: undefined,
        signatures: []
    };
}
exports.Tx = {
    typeUrl: "/cosmos.tx.v1beta1.Tx",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.body !== undefined) exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        if (message.authInfo !== undefined) exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        for (const v of message.signatures)writer.uint32(26).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.body = exports.TxBody.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTx();
        if ((0, helpers_1.isSet)(object.body)) obj.body = exports.TxBody.fromJSON(object.body);
        if ((0, helpers_1.isSet)(object.authInfo)) obj.authInfo = exports.AuthInfo.fromJSON(object.authInfo);
        if (Array.isArray(object?.signatures)) obj.signatures = object.signatures.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.body !== undefined && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : undefined);
        message.authInfo !== undefined && (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : undefined);
        if (message.signatures) obj.signatures = message.signatures.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTx();
        if (object.body !== undefined && object.body !== null) message.body = exports.TxBody.fromPartial(object.body);
        if (object.authInfo !== undefined && object.authInfo !== null) message.authInfo = exports.AuthInfo.fromPartial(object.authInfo);
        message.signatures = object.signatures?.map((e)=>e) || [];
        return message;
    }
};
function createBaseTxRaw() {
    return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
    };
}
exports.TxRaw = {
    typeUrl: "/cosmos.tx.v1beta1.TxRaw",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) writer.uint32(10).bytes(message.bodyBytes);
        if (message.authInfoBytes.length !== 0) writer.uint32(18).bytes(message.authInfoBytes);
        for (const v of message.signatures)writer.uint32(26).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case 2:
                    message.authInfoBytes = reader.bytes();
                    break;
                case 3:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxRaw();
        if ((0, helpers_1.isSet)(object.bodyBytes)) obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes)) obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if (Array.isArray(object?.signatures)) obj.signatures = object.signatures.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.bodyBytes !== undefined && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== undefined && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) obj.signatures = message.signatures.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxRaw();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.signatures = object.signatures?.map((e)=>e) || [];
        return message;
    }
};
function createBaseSignDoc() {
    return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: BigInt(0)
    };
}
exports.SignDoc = {
    typeUrl: "/cosmos.tx.v1beta1.SignDoc",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) writer.uint32(10).bytes(message.bodyBytes);
        if (message.authInfoBytes.length !== 0) writer.uint32(18).bytes(message.authInfoBytes);
        if (message.chainId !== "") writer.uint32(26).string(message.chainId);
        if (message.accountNumber !== BigInt(0)) writer.uint32(32).uint64(message.accountNumber);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case 2:
                    message.authInfoBytes = reader.bytes();
                    break;
                case 3:
                    message.chainId = reader.string();
                    break;
                case 4:
                    message.accountNumber = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignDoc();
        if ((0, helpers_1.isSet)(object.bodyBytes)) obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes)) obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if ((0, helpers_1.isSet)(object.chainId)) obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber)) obj.accountNumber = BigInt(object.accountNumber.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.bodyBytes !== undefined && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== undefined && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignDoc();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== undefined && object.accountNumber !== null) message.accountNumber = BigInt(object.accountNumber.toString());
        return message;
    }
};
function createBaseSignDocDirectAux() {
    return {
        bodyBytes: new Uint8Array(),
        publicKey: undefined,
        chainId: "",
        accountNumber: BigInt(0),
        sequence: BigInt(0),
        tip: undefined
    };
}
exports.SignDocDirectAux = {
    typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) writer.uint32(10).bytes(message.bodyBytes);
        if (message.publicKey !== undefined) any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
        if (message.chainId !== "") writer.uint32(26).string(message.chainId);
        if (message.accountNumber !== BigInt(0)) writer.uint32(32).uint64(message.accountNumber);
        if (message.sequence !== BigInt(0)) writer.uint32(40).uint64(message.sequence);
        if (message.tip !== undefined) exports.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignDocDirectAux();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case 2:
                    message.publicKey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chainId = reader.string();
                    break;
                case 4:
                    message.accountNumber = reader.uint64();
                    break;
                case 5:
                    message.sequence = reader.uint64();
                    break;
                case 6:
                    message.tip = exports.Tip.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignDocDirectAux();
        if ((0, helpers_1.isSet)(object.bodyBytes)) obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.publicKey)) obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.chainId)) obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber)) obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.tip)) obj.tip = exports.Tip.fromJSON(object.tip);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.bodyBytes !== undefined && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignDocDirectAux();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        if (object.publicKey !== undefined && object.publicKey !== null) message.publicKey = any_1.Any.fromPartial(object.publicKey);
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== undefined && object.accountNumber !== null) message.accountNumber = BigInt(object.accountNumber.toString());
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        if (object.tip !== undefined && object.tip !== null) message.tip = exports.Tip.fromPartial(object.tip);
        return message;
    }
};
function createBaseTxBody() {
    return {
        messages: [],
        memo: "",
        timeoutHeight: BigInt(0),
        extensionOptions: [],
        nonCriticalExtensionOptions: []
    };
}
exports.TxBody = {
    typeUrl: "/cosmos.tx.v1beta1.TxBody",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages)any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.memo !== "") writer.uint32(18).string(message.memo);
        if (message.timeoutHeight !== BigInt(0)) writer.uint32(24).uint64(message.timeoutHeight);
        for (const v of message.extensionOptions)any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
        for (const v of message.nonCriticalExtensionOptions)any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.memo = reader.string();
                    break;
                case 3:
                    message.timeoutHeight = reader.uint64();
                    break;
                case 1023:
                    message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 2047:
                    message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxBody();
        if (Array.isArray(object?.messages)) obj.messages = object.messages.map((e)=>any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.memo)) obj.memo = String(object.memo);
        if ((0, helpers_1.isSet)(object.timeoutHeight)) obj.timeoutHeight = BigInt(object.timeoutHeight.toString());
        if (Array.isArray(object?.extensionOptions)) obj.extensionOptions = object.extensionOptions.map((e)=>any_1.Any.fromJSON(e));
        if (Array.isArray(object?.nonCriticalExtensionOptions)) obj.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions.map((e)=>any_1.Any.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.messages) obj.messages = message.messages.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.messages = [];
        message.memo !== undefined && (obj.memo = message.memo);
        message.timeoutHeight !== undefined && (obj.timeoutHeight = (message.timeoutHeight || BigInt(0)).toString());
        if (message.extensionOptions) obj.extensionOptions = message.extensionOptions.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.extensionOptions = [];
        if (message.nonCriticalExtensionOptions) obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.nonCriticalExtensionOptions = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxBody();
        message.messages = object.messages?.map((e)=>any_1.Any.fromPartial(e)) || [];
        message.memo = object.memo ?? "";
        if (object.timeoutHeight !== undefined && object.timeoutHeight !== null) message.timeoutHeight = BigInt(object.timeoutHeight.toString());
        message.extensionOptions = object.extensionOptions?.map((e)=>any_1.Any.fromPartial(e)) || [];
        message.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions?.map((e)=>any_1.Any.fromPartial(e)) || [];
        return message;
    }
};
function createBaseAuthInfo() {
    return {
        signerInfos: [],
        fee: undefined,
        tip: undefined
    };
}
exports.AuthInfo = {
    typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signerInfos)exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.fee !== undefined) exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        if (message.tip !== undefined) exports.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.fee = exports.Fee.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.tip = exports.Tip.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAuthInfo();
        if (Array.isArray(object?.signerInfos)) obj.signerInfos = object.signerInfos.map((e)=>exports.SignerInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.fee)) obj.fee = exports.Fee.fromJSON(object.fee);
        if ((0, helpers_1.isSet)(object.tip)) obj.tip = exports.Tip.fromJSON(object.tip);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.signerInfos) obj.signerInfos = message.signerInfos.map((e)=>e ? exports.SignerInfo.toJSON(e) : undefined);
        else obj.signerInfos = [];
        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);
        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAuthInfo();
        message.signerInfos = object.signerInfos?.map((e)=>exports.SignerInfo.fromPartial(e)) || [];
        if (object.fee !== undefined && object.fee !== null) message.fee = exports.Fee.fromPartial(object.fee);
        if (object.tip !== undefined && object.tip !== null) message.tip = exports.Tip.fromPartial(object.tip);
        return message;
    }
};
function createBaseSignerInfo() {
    return {
        publicKey: undefined,
        modeInfo: undefined,
        sequence: BigInt(0)
    };
}
exports.SignerInfo = {
    typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== undefined) any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        if (message.modeInfo !== undefined) exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.publicKey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignerInfo();
        if ((0, helpers_1.isSet)(object.publicKey)) obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.modeInfo)) obj.modeInfo = exports.ModeInfo.fromJSON(object.modeInfo);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);
        message.modeInfo !== undefined && (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : undefined);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignerInfo();
        if (object.publicKey !== undefined && object.publicKey !== null) message.publicKey = any_1.Any.fromPartial(object.publicKey);
        if (object.modeInfo !== undefined && object.modeInfo !== null) message.modeInfo = exports.ModeInfo.fromPartial(object.modeInfo);
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseModeInfo() {
    return {
        single: undefined,
        multi: undefined
    };
}
exports.ModeInfo = {
    typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== undefined) exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        if (message.multi !== undefined) exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseModeInfo();
        if ((0, helpers_1.isSet)(object.single)) obj.single = exports.ModeInfo_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi)) obj.multi = exports.ModeInfo_Multi.fromJSON(object.multi);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.single !== undefined && (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : undefined);
        message.multi !== undefined && (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseModeInfo();
        if (object.single !== undefined && object.single !== null) message.single = exports.ModeInfo_Single.fromPartial(object.single);
        if (object.multi !== undefined && object.multi !== null) message.multi = exports.ModeInfo_Multi.fromPartial(object.multi);
        return message;
    }
};
function createBaseModeInfo_Single() {
    return {
        mode: 0
    };
}
exports.ModeInfo_Single = {
    typeUrl: "/cosmos.tx.v1beta1.Single",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) writer.uint32(8).int32(message.mode);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseModeInfo_Single();
        if ((0, helpers_1.isSet)(object.mode)) obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseModeInfo_Single();
        message.mode = object.mode ?? 0;
        return message;
    }
};
function createBaseModeInfo_Multi() {
    return {
        bitarray: undefined,
        modeInfos: []
    };
}
exports.ModeInfo_Multi = {
    typeUrl: "/cosmos.tx.v1beta1.Multi",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== undefined) multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        for (const v of message.modeInfos)exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseModeInfo_Multi();
        if ((0, helpers_1.isSet)(object.bitarray)) obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object?.modeInfos)) obj.modeInfos = object.modeInfos.map((e)=>exports.ModeInfo.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);
        if (message.modeInfos) obj.modeInfos = message.modeInfos.map((e)=>e ? exports.ModeInfo.toJSON(e) : undefined);
        else obj.modeInfos = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseModeInfo_Multi();
        if (object.bitarray !== undefined && object.bitarray !== null) message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        message.modeInfos = object.modeInfos?.map((e)=>exports.ModeInfo.fromPartial(e)) || [];
        return message;
    }
};
function createBaseFee() {
    return {
        amount: [],
        gasLimit: BigInt(0),
        payer: "",
        granter: ""
    };
}
exports.Fee = {
    typeUrl: "/cosmos.tx.v1beta1.Fee",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.gasLimit !== BigInt(0)) writer.uint32(16).uint64(message.gasLimit);
        if (message.payer !== "") writer.uint32(26).string(message.payer);
        if (message.granter !== "") writer.uint32(34).string(message.granter);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.gasLimit = reader.uint64();
                    break;
                case 3:
                    message.payer = reader.string();
                    break;
                case 4:
                    message.granter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseFee();
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.gasLimit)) obj.gasLimit = BigInt(object.gasLimit.toString());
        if ((0, helpers_1.isSet)(object.payer)) obj.payer = String(object.payer);
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        message.gasLimit !== undefined && (obj.gasLimit = (message.gasLimit || BigInt(0)).toString());
        message.payer !== undefined && (obj.payer = message.payer);
        message.granter !== undefined && (obj.granter = message.granter);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseFee();
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.gasLimit !== undefined && object.gasLimit !== null) message.gasLimit = BigInt(object.gasLimit.toString());
        message.payer = object.payer ?? "";
        message.granter = object.granter ?? "";
        return message;
    }
};
function createBaseTip() {
    return {
        amount: [],
        tipper: ""
    };
}
exports.Tip = {
    typeUrl: "/cosmos.tx.v1beta1.Tip",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.tipper !== "") writer.uint32(18).string(message.tipper);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTip();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.tipper = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTip();
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.tipper)) obj.tipper = String(object.tipper);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        message.tipper !== undefined && (obj.tipper = message.tipper);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTip();
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.tipper = object.tipper ?? "";
        return message;
    }
};
function createBaseAuxSignerData() {
    return {
        address: "",
        signDoc: undefined,
        mode: 0,
        sig: new Uint8Array()
    };
}
exports.AuxSignerData = {
    typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.signDoc !== undefined) exports.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
        if (message.mode !== 0) writer.uint32(24).int32(message.mode);
        if (message.sig.length !== 0) writer.uint32(34).bytes(message.sig);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuxSignerData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.signDoc = exports.SignDocDirectAux.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.mode = reader.int32();
                    break;
                case 4:
                    message.sig = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAuxSignerData();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.signDoc)) obj.signDoc = exports.SignDocDirectAux.fromJSON(object.signDoc);
        if ((0, helpers_1.isSet)(object.mode)) obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        if ((0, helpers_1.isSet)(object.sig)) obj.sig = (0, helpers_1.bytesFromBase64)(object.sig);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.signDoc !== undefined && (obj.signDoc = message.signDoc ? exports.SignDocDirectAux.toJSON(message.signDoc) : undefined);
        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        message.sig !== undefined && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== undefined ? message.sig : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAuxSignerData();
        message.address = object.address ?? "";
        if (object.signDoc !== undefined && object.signDoc !== null) message.signDoc = exports.SignDocDirectAux.fromPartial(object.signDoc);
        message.mode = object.mode ?? 0;
        message.sig = object.sig ?? new Uint8Array();
        return message;
    }
};

},{"2fc92ab2c36bdab6":"56aJC","e6276eb27dd2fcb6":"9PT9z","926bd3d9b4261655":"aenYD","76624f4af9fa8795":"1ymyZ","6ee1dac8bf663c42":"bi36x","d817877c78ac1068":"eYjRL"}],"56aJC":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Any = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("eba2188f6556b8d6");
const helpers_1 = require("bab745b6a9f6f541");
exports.protobufPackage = "google.protobuf";
function createBaseAny() {
    return {
        typeUrl: "",
        value: new Uint8Array()
    };
}
exports.Any = {
    typeUrl: "/google.protobuf.Any",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.typeUrl !== "") writer.uint32(10).string(message.typeUrl);
        if (message.value.length !== 0) writer.uint32(18).bytes(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.typeUrl = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAny();
        if ((0, helpers_1.isSet)(object.typeUrl)) obj.typeUrl = String(object.typeUrl);
        if ((0, helpers_1.isSet)(object.value)) obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);
        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAny();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
    }
};

},{"eba2188f6556b8d6":"bi36x","bab745b6a9f6f541":"eYjRL"}],"bi36x":[function(require,module,exports,__globalThis) {
"use strict";
/* eslint-disable */ /**
 * This file and any referenced files were automatically generated by @cosmology/telescope@1.12.20
 * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
 * and run the transpile command or npm scripts command that is used to regenerate this bundle.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BinaryWriter = exports.BinaryReader = exports.WireType = void 0;
// Copyright (c) 2016, Daniel Wirtz  All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
// * Neither the name of its author, nor the names of its contributors
//   may be used to endorse or promote products derived from this software
//   without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ---
// Code generated by the command line utilities is owned by the owner
// of the input file used when generating it. This code is not
// standalone and requires a support library to be linked with it. This
// support library is itself covered by the above license.
const utf8_1 = require("7d7c86c609874846");
const varint_1 = require("61769eed8a6a0284");
var WireType;
(function(WireType) {
    WireType[WireType["Varint"] = 0] = "Varint";
    WireType[WireType["Fixed64"] = 1] = "Fixed64";
    WireType[WireType["Bytes"] = 2] = "Bytes";
    WireType[WireType["Fixed32"] = 5] = "Fixed32";
})(WireType || (exports.WireType = WireType = {}));
class BinaryReader {
    assertBounds() {
        if (this.pos > this.len) throw new RangeError("premature EOF");
    }
    constructor(buf){
        this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);
        this.pos = 0;
        this.type = 0;
        this.len = this.buf.length;
    }
    tag() {
        const tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [
            fieldNo,
            wireType,
            tag
        ];
    }
    skip(length) {
        if (typeof length === "number") {
            if (this.pos + length > this.len) throw indexOutOfRange(this, length);
            this.pos += length;
        } else do {
            if (this.pos >= this.len) throw indexOutOfRange(this);
        }while (this.buf[this.pos++] & 128);
        return this;
    }
    skipType(wireType) {
        switch(wireType){
            case WireType.Varint:
                this.skip();
                break;
            case WireType.Fixed64:
                this.skip(8);
                break;
            case WireType.Bytes:
                this.skip(this.uint32());
                break;
            case 3:
                while((wireType = this.uint32() & 7) !== 4)this.skipType(wireType);
                break;
            case WireType.Fixed32:
                this.skip(4);
                break;
            /* istanbul ignore next */ default:
                throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
    }
    uint32() {
        return varint_1.varint32read.bind(this)();
    }
    int32() {
        return this.uint32() | 0;
    }
    sint32() {
        const num = this.uint32();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    }
    fixed32() {
        const val = (0, varint_1.readUInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
    }
    sfixed32() {
        const val = (0, varint_1.readInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
    }
    int64() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.int64ToString)(lo, hi));
    }
    uint64() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.uInt64ToString)(lo, hi));
    }
    sint64() {
        let [lo, hi] = varint_1.varint64read.bind(this)();
        // zig zag
        [lo, hi] = (0, varint_1.zzDecode)(lo, hi);
        return BigInt((0, varint_1.int64ToString)(lo, hi));
    }
    fixed64() {
        const lo = this.sfixed32();
        const hi = this.sfixed32();
        return BigInt((0, varint_1.uInt64ToString)(lo, hi));
    }
    sfixed64() {
        const lo = this.sfixed32();
        const hi = this.sfixed32();
        return BigInt((0, varint_1.int64ToString)(lo, hi));
    }
    float() {
        throw new Error("float not supported");
    }
    double() {
        throw new Error("double not supported");
    }
    bool() {
        const [lo, hi] = varint_1.varint64read.bind(this)();
        return lo !== 0 || hi !== 0;
    }
    bytes() {
        const len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    string() {
        const bytes = this.bytes();
        return (0, utf8_1.utf8Read)(bytes, 0, bytes.length);
    }
}
exports.BinaryReader = BinaryReader;
class Op {
    constructor(fn, len, val){
        this.fn = fn;
        this.len = len;
        this.val = val;
    }
    proceed(buf, pos) {
        if (this.fn) this.fn(this.val, buf, pos);
    }
}
class State {
    constructor(writer){
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
    }
}
class BinaryWriter {
    constructor(){
        this.len = 0;
        // uint64 is the same with int64
        this.uint64 = BinaryWriter.prototype.int64;
        // sfixed64 is the same with fixed64
        this.sfixed64 = BinaryWriter.prototype.fixed64;
        // sfixed32 is the same with fixed32
        this.sfixed32 = BinaryWriter.prototype.fixed32;
        this.head = new Op(null, 0, 0);
        this.tail = this.head;
        this.states = null;
    }
    static create() {
        return new BinaryWriter();
    }
    static alloc(size) {
        if (typeof Uint8Array !== "undefined") return pool((size)=>new Uint8Array(size), Uint8Array.prototype.subarray)(size);
        else return new Array(size);
    }
    _push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
    }
    finish() {
        let head = this.head.next, pos = 0;
        const buf = BinaryWriter.alloc(this.len);
        while(head){
            head.proceed(buf, pos);
            pos += head.len;
            head = head.next;
        }
        return buf;
    }
    fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(null, 0, 0);
        this.len = 0;
        return this;
    }
    reset() {
        if (this.states) {
            this.head = this.states.head;
            this.tail = this.states.tail;
            this.len = this.states.len;
            this.states = this.states.next;
        } else {
            this.head = this.tail = new Op(null, 0, 0);
            this.len = 0;
        }
        return this;
    }
    ldelim() {
        const head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
            this.tail.next = head.next; // skip noop
            this.tail = tail;
            this.len += len;
        }
        return this;
    }
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    uint32(value) {
        this.len += (this.tail = this.tail.next = new Op(varint_1.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
        return this;
    }
    int32(value) {
        return value < 0 ? this._push(varint_1.writeVarint64, 10, (0, varint_1.int64FromString)(value.toString())) // 10 bytes per spec
         : this.uint32(value);
    }
    sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
    int64(value) {
        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), {
            lo,
            hi
        });
    }
    sint64(value) {
        let { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        // zig zag
        [lo, hi] = (0, varint_1.zzEncode)(lo, hi);
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), {
            lo,
            hi
        });
    }
    fixed64(value) {
        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeFixed32, 4, lo)._push(varint_1.writeFixed32, 4, hi);
    }
    bool(value) {
        return this._push(varint_1.writeByte, 1, value ? 1 : 0);
    }
    fixed32(value) {
        return this._push(varint_1.writeFixed32, 4, value >>> 0);
    }
    float(value) {
        throw new Error("float not supported" + value);
    }
    double(value) {
        throw new Error("double not supported" + value);
    }
    bytes(value) {
        const len = value.length >>> 0;
        if (!len) return this._push(varint_1.writeByte, 1, 0);
        return this.uint32(len)._push(writeBytes, len, value);
    }
    string(value) {
        const len = (0, utf8_1.utf8Length)(value);
        return len ? this.uint32(len)._push(utf8_1.utf8Write, len, value) : this._push(varint_1.writeByte, 1, 0);
    }
}
exports.BinaryWriter = BinaryWriter;
function writeBytes(val, buf, pos) {
    if (typeof Uint8Array !== "undefined") buf.set(val, pos);
    else for(let i = 0; i < val.length; ++i)buf[pos + i] = val[i];
}
function pool(alloc, slice, size) {
    const SIZE = size || 8192;
    const MAX = SIZE >>> 1;
    let slab = null;
    let offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX) return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        const buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
        offset = (offset | 7) + 1;
        return buf;
    };
}
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

},{"7d7c86c609874846":"gWFVR","61769eed8a6a0284":"ivyvk"}],"gWFVR":[function(require,module,exports,__globalThis) {
/* eslint-disable */ /**
 * This file and any referenced files were automatically generated by @cosmology/telescope@1.12.20
 * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
 * and run the transpile command or npm scripts command that is used to regenerate this bundle.
 */ // Copyright (c) 2016, Daniel Wirtz  All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
// * Neither the name of its author, nor the names of its contributors
//   may be used to endorse or promote products derived from this software
//   without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.utf8Write = exports.utf8Read = exports.utf8Length = void 0;
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */ function utf8Length(str) {
    let len = 0, c = 0;
    for(let i = 0; i < str.length; ++i){
        c = str.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xfc00) === 0xd800 && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
}
exports.utf8Length = utf8Length;
/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */ function utf8Read(buffer, start, end) {
    const len = end - start;
    if (len < 1) return "";
    const chunk = [];
    let parts = [], i = 0, t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xd800 + (t >> 10);
            chunk[i++] = 0xdc00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode(...chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode(...chunk.slice(0, i));
}
exports.utf8Read = utf8Read;
/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */ function utf8Write(str, buffer, offset) {
    const start = offset;
    let c1, c2; // character 2
    for(let i = 0; i < str.length; ++i){
        c1 = str.charCodeAt(i);
        if (c1 < 128) buffer[offset++] = c1;
        else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = str.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {
            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
}
exports.utf8Write = utf8Write;

},{}],"ivyvk":[function(require,module,exports,__globalThis) {
"use strict";
/* eslint-disable */ /**
 * This file and any referenced files were automatically generated by @cosmology/telescope@1.12.20
 * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
 * and run the transpile command or npm scripts command that is used to regenerate this bundle.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.writeByte = exports.writeFixed32 = exports.int64Length = exports.writeVarint64 = exports.writeVarint32 = exports.readInt32 = exports.readUInt32 = exports.zzDecode = exports.zzEncode = exports.varint32read = exports.varint32write = exports.uInt64ToString = exports.int64ToString = exports.int64FromString = exports.varint64write = exports.varint64read = void 0;
// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [1]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */ function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for(let shift = 0; shift < 28; shift += 7){
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7f) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [
                lowBits,
                highBits
            ];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0f) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [
            lowBits,
            highBits
        ];
    }
    for(let shift = 3; shift <= 31; shift += 7){
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7f) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [
                lowBits,
                highBits
            ];
        }
    }
    throw new Error("invalid varint");
}
exports.varint64read = varint64read;
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */ function varint64write(lo, hi, bytes) {
    for(let i = 0; i < 28; i = i + 7){
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
        bytes.push(byte);
        if (!hasNext) return;
    }
    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);
    if (!hasMoreBits) return;
    for(let i = 3; i < 31; i = i + 7){
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
        bytes.push(byte);
        if (!hasNext) return;
    }
    bytes.push(hi >>> 31 & 0x01);
}
exports.varint64write = varint64write;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
 */ function int64FromString(dec) {
    // Check for minus sign.
    const minus = dec[0] === "-";
    if (minus) dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
exports.int64FromString = int64FromString;
/**
 * Losslessly converts a 64-bit signed integer in 32:32 split representation
 * into a decimal string.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
 */ function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    // If we're treating the input as a signed value and the high bit is set, do
    // a manual two's complement conversion before the decimal conversion.
    const negative = bits.hi & 0x80000000;
    if (negative) bits = negate(bits.lo, bits.hi);
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
}
exports.int64ToString = int64ToString;
/**
 * Losslessly converts a 64-bit unsigned integer in 32:32 split representation
 * into a decimal string.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
 */ function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with
    // highBits <= 0x1FFFFF can be safely expressed with a double and retain
    // integer precision.
    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.
    if (hi <= 0x1fffff) return String(TWO_PWR_32_DBL * hi + lo);
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    const low = lo & 0xffffff;
    const mid = (lo >>> 24 | hi << 8) & 0xffffff;
    const high = hi >> 16 & 0xffff;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    // Apply carries from A to B and from B to C.
    const base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // If digitC is 0, then we should have returned in the trivial code path
    // at the top for non-safe integers. Given this, we can assume both digitB
    // and digitA need leading zeros.
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
exports.uInt64ToString = uInt64ToString;
function toUnsigned(lo, hi) {
    return {
        lo: lo >>> 0,
        hi: hi >>> 0
    };
}
function newBits(lo, hi) {
    return {
        lo: lo | 0,
        hi: hi | 0
    };
}
/**
 * Returns two's compliment negation of input.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers
 */ function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) lowBits = ~lowBits + 1;
    else // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,
    // adding 1 to that, results in 0x100000000, which leaves
    // the low bits 0x0 and simply adds one to the high bits.
    highBits += 1;
    return newBits(lowBits, highBits);
}
/**
 * Returns decimal representation of digit1e7 with leading zeros.
 */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
};
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */ function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while(value > 0x7f){
            bytes.push(value & 0x7f | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    } else {
        for(let i = 0; i < 9; i++){
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
exports.varint32write = varint32write;
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */ function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7f;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0f) << 28;
    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];
    if ((b & 0x80) != 0) throw new Error("invalid varint");
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}
exports.varint32read = varint32read;
/**
 * encode zig zag
 */ function zzEncode(lo, hi) {
    let mask = hi >> 31;
    hi = ((hi << 1 | lo >>> 31) ^ mask) >>> 0;
    lo = (lo << 1 ^ mask) >>> 0;
    return [
        lo,
        hi
    ];
}
exports.zzEncode = zzEncode;
/**
 * decode zig zag
 */ function zzDecode(lo, hi) {
    let mask = -(lo & 1);
    lo = ((lo >>> 1 | hi << 31) ^ mask) >>> 0;
    hi = (hi >>> 1 ^ mask) >>> 0;
    return [
        lo,
        hi
    ];
}
exports.zzDecode = zzDecode;
/**
 * unsigned int32 without moving pos.
 */ function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 0x1000000;
}
exports.readUInt32 = readUInt32;
/**
 * signed int32 without moving pos.
 */ function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}
exports.readInt32 = readInt32;
/**
 * writing varint32 to pos
 */ function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
exports.writeVarint32 = writeVarint32;
/**
 * writing varint64 to pos
 */ function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
exports.writeVarint64 = writeVarint64;
function int64Length(lo, hi) {
    let part0 = lo, part1 = (lo >>> 28 | hi << 4) >>> 0, part2 = hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
}
exports.int64Length = int64Length;
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
exports.writeFixed32 = writeFixed32;
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
exports.writeByte = writeByte;

},{}],"eYjRL":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var Buffer = require("e426f54cb57e13ed").Buffer;
"use strict";
/* eslint-disable */ /**
 * This file and any referenced files were automatically generated by @cosmology/telescope@1.12.20
 * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
 * and run the transpile command or npm scripts command that is used to regenerate this bundle.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromJsonTimestamp = exports.fromTimestamp = exports.toTimestamp = exports.isRpc = exports.setPaginationParams = exports.isObject = exports.isSet = exports.fromDuration = exports.toDuration = exports.omitDefault = exports.base64FromBytes = exports.bytesFromBase64 = void 0;
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob || ((b64)=>globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
    return arr;
}
exports.bytesFromBase64 = bytesFromBase64;
const btoa = globalThis.btoa || ((bin)=>globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte)=>{
        bin.push(String.fromCharCode(byte));
    });
    return btoa(bin.join(""));
}
exports.base64FromBytes = base64FromBytes;
function omitDefault(input) {
    if (typeof input === "string") return input === "" ? undefined : input;
    if (typeof input === "number") return input === 0 ? undefined : input;
    if (typeof input === "boolean") return input === false ? undefined : input;
    if (typeof input === "bigint") return input === BigInt(0) ? undefined : input;
    throw new Error(`Got unsupported type ${typeof input}`);
}
exports.omitDefault = omitDefault;
function toDuration(duration) {
    return {
        seconds: BigInt(Math.floor(parseInt(duration) / 1000000000)),
        nanos: parseInt(duration) % 1000000000
    };
}
exports.toDuration = toDuration;
function fromDuration(duration) {
    return (parseInt(duration.seconds.toString()) * 1000000000 + duration.nanos).toString();
}
exports.fromDuration = fromDuration;
function isSet(value) {
    return value !== null && value !== undefined;
}
exports.isSet = isSet;
function isObject(value) {
    return typeof value === "object" && value !== null;
}
exports.isObject = isObject;
const setPaginationParams = (options, pagination)=>{
    if (!pagination) return options;
    if (typeof pagination?.countTotal !== "undefined") options.params["pagination.count_total"] = pagination.countTotal;
    if (typeof pagination?.key !== "undefined") // String to Uint8Array
    // let uint8arr = new Uint8Array(Buffer.from(data,'base64'));
    // Uint8Array to String
    options.params["pagination.key"] = Buffer.from(pagination.key).toString("base64");
    if (typeof pagination?.limit !== "undefined") options.params["pagination.limit"] = pagination.limit.toString();
    if (typeof pagination?.offset !== "undefined") options.params["pagination.offset"] = pagination.offset.toString();
    if (typeof pagination?.reverse !== "undefined") options.params["pagination.reverse"] = pagination.reverse;
    return options;
};
exports.setPaginationParams = setPaginationParams;
function isRpc(rpc) {
    return rpc !== null && rpc !== undefined && typeof rpc.request === "function";
}
exports.isRpc = isRpc;
function toTimestamp(date) {
    const seconds = numberToLong(date.getTime() / 1000);
    const nanos = date.getTime() % 1000 * 1000000;
    return {
        seconds,
        nanos
    };
}
exports.toTimestamp = toTimestamp;
function fromTimestamp(t) {
    let millis = Number(t.seconds) * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
exports.fromTimestamp = fromTimestamp;
const timestampFromJSON = (object)=>{
    return {
        seconds: isSet(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(0),
        nanos: isSet(object.nanos) ? Number(object.nanos) : 0
    };
};
function fromJsonTimestamp(o) {
    if (o instanceof Date) return toTimestamp(o);
    else if (typeof o === "string") return toTimestamp(new Date(o));
    else return timestampFromJSON(o);
}
exports.fromJsonTimestamp = fromJsonTimestamp;
function numberToLong(number) {
    return BigInt(Math.trunc(number));
}

},{"e426f54cb57e13ed":"bCaf4"}],"bCaf4":[function(require,module,exports,__globalThis) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"9c62938f1dccc73c":"9I2RJ","aceacb6a4531a9d2":"geXY6"}],"9I2RJ":[function(require,module,exports,__globalThis) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"geXY6":[function(require,module,exports,__globalThis) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"9PT9z":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;
/* eslint-disable */ const multisig_1 = require("a8142d9c39757044");
const any_1 = require("72deac2f2d9934ec");
const binary_1 = require("9a2d59cd32e8672d");
const helpers_1 = require("bf1447e7226d860f");
exports.protobufPackage = "cosmos.tx.signing.v1beta1";
/**
 * SignMode represents a signing mode with its own security guarantees.
 *
 * This enum should be considered a registry of all known sign modes
 * in the Cosmos ecosystem. Apps are not expected to support all known
 * sign modes. Apps that would like to support custom  sign modes are
 * encouraged to open a small PR against this file to add a new case
 * to this SignMode enum describing their sign mode so that different
 * apps have a consistent version of this enum.
 */ var SignMode;
(function(SignMode) {
    /**
     * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
     * rejected.
     */ SignMode[SignMode["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
    /**
     * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
     * verified with raw bytes from Tx.
     */ SignMode[SignMode["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
    /**
     * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some
     * human-readable textual representation on top of the binary representation
     * from SIGN_MODE_DIRECT.
     *
     * Since: cosmos-sdk 0.50
     */ SignMode[SignMode["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
    /**
     * SIGN_MODE_DIRECT_AUX - SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
     * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
     * require signers signing over other signers' `signer_info`.
     *
     * Since: cosmos-sdk 0.46
     */ SignMode[SignMode["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
    /**
     * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
     * Amino JSON and will be removed in the future.
     */ SignMode[SignMode["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
    /**
     * SIGN_MODE_EIP_191 - SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
     * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
     *
     * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
     * but is not implemented on the SDK by default. To enable EIP-191, you need
     * to pass a custom `TxConfig` that has an implementation of
     * `SignModeHandler` for EIP-191. The SDK may decide to fully support
     * EIP-191 in the future.
     *
     * Since: cosmos-sdk 0.45.2
     */ SignMode[SignMode["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
    SignMode[SignMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignMode || (exports.SignMode = SignMode = {}));
function signModeFromJSON(object) {
    switch(object){
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
            return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
            return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
            return SignMode.SIGN_MODE_TEXTUAL;
        case 3:
        case "SIGN_MODE_DIRECT_AUX":
            return SignMode.SIGN_MODE_DIRECT_AUX;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
            return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
            return SignMode.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SignMode.UNRECOGNIZED;
    }
}
exports.signModeFromJSON = signModeFromJSON;
function signModeToJSON(object) {
    switch(object){
        case SignMode.SIGN_MODE_UNSPECIFIED:
            return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
            return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
            return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_DIRECT_AUX:
            return "SIGN_MODE_DIRECT_AUX";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
            return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode.SIGN_MODE_EIP_191:
            return "SIGN_MODE_EIP_191";
        case SignMode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.signModeToJSON = signModeToJSON;
function createBaseSignatureDescriptors() {
    return {
        signatures: []
    };
}
exports.SignatureDescriptors = {
    typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures)exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignatureDescriptors();
        if (Array.isArray(object?.signatures)) obj.signatures = object.signatures.map((e)=>exports.SignatureDescriptor.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.signatures) obj.signatures = message.signatures.map((e)=>e ? exports.SignatureDescriptor.toJSON(e) : undefined);
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignatureDescriptors();
        message.signatures = object.signatures?.map((e)=>exports.SignatureDescriptor.fromPartial(e)) || [];
        return message;
    }
};
function createBaseSignatureDescriptor() {
    return {
        publicKey: undefined,
        data: undefined,
        sequence: BigInt(0)
    };
}
exports.SignatureDescriptor = {
    typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== undefined) any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        if (message.data !== undefined) exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.publicKey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignatureDescriptor();
        if ((0, helpers_1.isSet)(object.publicKey)) obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.data)) obj.data = exports.SignatureDescriptor_Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);
        message.data !== undefined && (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : undefined);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignatureDescriptor();
        if (object.publicKey !== undefined && object.publicKey !== null) message.publicKey = any_1.Any.fromPartial(object.publicKey);
        if (object.data !== undefined && object.data !== null) message.data = exports.SignatureDescriptor_Data.fromPartial(object.data);
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseSignatureDescriptor_Data() {
    return {
        single: undefined,
        multi: undefined
    };
}
exports.SignatureDescriptor_Data = {
    typeUrl: "/cosmos.tx.signing.v1beta1.Data",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== undefined) exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        if (message.multi !== undefined) exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignatureDescriptor_Data();
        if ((0, helpers_1.isSet)(object.single)) obj.single = exports.SignatureDescriptor_Data_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi)) obj.multi = exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.single !== undefined && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : undefined);
        message.multi !== undefined && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignatureDescriptor_Data();
        if (object.single !== undefined && object.single !== null) message.single = exports.SignatureDescriptor_Data_Single.fromPartial(object.single);
        if (object.multi !== undefined && object.multi !== null) message.multi = exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi);
        return message;
    }
};
function createBaseSignatureDescriptor_Data_Single() {
    return {
        mode: 0,
        signature: new Uint8Array()
    };
}
exports.SignatureDescriptor_Data_Single = {
    typeUrl: "/cosmos.tx.signing.v1beta1.Single",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) writer.uint32(8).int32(message.mode);
        if (message.signature.length !== 0) writer.uint32(18).bytes(message.signature);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignatureDescriptor_Data_Single();
        if ((0, helpers_1.isSet)(object.mode)) obj.mode = signModeFromJSON(object.mode);
        if ((0, helpers_1.isSet)(object.signature)) obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));
        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = object.mode ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        return message;
    }
};
function createBaseSignatureDescriptor_Data_Multi() {
    return {
        bitarray: undefined,
        signatures: []
    };
}
exports.SignatureDescriptor_Data_Multi = {
    typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== undefined) multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        for (const v of message.signatures)exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignatureDescriptor_Data_Multi();
        if ((0, helpers_1.isSet)(object.bitarray)) obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object?.signatures)) obj.signatures = object.signatures.map((e)=>exports.SignatureDescriptor_Data.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);
        if (message.signatures) obj.signatures = message.signatures.map((e)=>e ? exports.SignatureDescriptor_Data.toJSON(e) : undefined);
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignatureDescriptor_Data_Multi();
        if (object.bitarray !== undefined && object.bitarray !== null) message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        message.signatures = object.signatures?.map((e)=>exports.SignatureDescriptor_Data.fromPartial(e)) || [];
        return message;
    }
};

},{"a8142d9c39757044":"aenYD","72deac2f2d9934ec":"56aJC","9a2d59cd32e8672d":"bi36x","bf1447e7226d860f":"eYjRL"}],"aenYD":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompactBitArray = exports.MultiSignature = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("526ffbd2bddc4a8");
const helpers_1 = require("2e538d1a6f7501d7");
exports.protobufPackage = "cosmos.crypto.multisig.v1beta1";
function createBaseMultiSignature() {
    return {
        signatures: []
    };
}
exports.MultiSignature = {
    typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMultiSignature();
        if (Array.isArray(object?.signatures)) obj.signatures = object.signatures.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.signatures) obj.signatures = message.signatures.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMultiSignature();
        message.signatures = object.signatures?.map((e)=>e) || [];
        return message;
    }
};
function createBaseCompactBitArray() {
    return {
        extraBitsStored: 0,
        elems: new Uint8Array()
    };
}
exports.CompactBitArray = {
    typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.extraBitsStored !== 0) writer.uint32(8).uint32(message.extraBitsStored);
        if (message.elems.length !== 0) writer.uint32(18).bytes(message.elems);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.extraBitsStored = reader.uint32();
                    break;
                case 2:
                    message.elems = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCompactBitArray();
        if ((0, helpers_1.isSet)(object.extraBitsStored)) obj.extraBitsStored = Number(object.extraBitsStored);
        if ((0, helpers_1.isSet)(object.elems)) obj.elems = (0, helpers_1.bytesFromBase64)(object.elems);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.extraBitsStored !== undefined && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== undefined && (obj.elems = (0, helpers_1.base64FromBytes)(message.elems !== undefined ? message.elems : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCompactBitArray();
        message.extraBitsStored = object.extraBitsStored ?? 0;
        message.elems = object.elems ?? new Uint8Array();
        return message;
    }
};

},{"526ffbd2bddc4a8":"bi36x","2e538d1a6f7501d7":"eYjRL"}],"1ymyZ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("23dc2b1b830990e9");
const helpers_1 = require("a07d3cde27de9013");
exports.protobufPackage = "cosmos.base.v1beta1";
function createBaseCoin() {
    return {
        denom: "",
        amount: ""
    };
}
exports.Coin = {
    typeUrl: "/cosmos.base.v1beta1.Coin",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        if (message.amount !== "") writer.uint32(18).string(message.amount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCoin();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = String(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
    }
};
function createBaseDecCoin() {
    return {
        denom: "",
        amount: ""
    };
}
exports.DecCoin = {
    typeUrl: "/cosmos.base.v1beta1.DecCoin",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        if (message.amount !== "") writer.uint32(18).string(message.amount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDecCoin();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = String(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDecCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
    }
};
function createBaseIntProto() {
    return {
        int: ""
    };
}
exports.IntProto = {
    typeUrl: "/cosmos.base.v1beta1.IntProto",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.int !== "") writer.uint32(10).string(message.int);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.int = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseIntProto();
        if ((0, helpers_1.isSet)(object.int)) obj.int = String(object.int);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.int !== undefined && (obj.int = message.int);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseIntProto();
        message.int = object.int ?? "";
        return message;
    }
};
function createBaseDecProto() {
    return {
        dec: ""
    };
}
exports.DecProto = {
    typeUrl: "/cosmos.base.v1beta1.DecProto",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.dec !== "") writer.uint32(10).string(message.dec);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.dec = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDecProto();
        if ((0, helpers_1.isSet)(object.dec)) obj.dec = String(object.dec);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.dec !== undefined && (obj.dec = message.dec);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDecProto();
        message.dec = object.dec ?? "";
        return message;
    }
};

},{"23dc2b1b830990e9":"bi36x","a07d3cde27de9013":"eYjRL"}],"3XRYb":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DirectSecp256k1HdWallet = void 0;
exports.extractKdfConfiguration = extractKdfConfiguration;
const amino_1 = require("6675bf1f8c853f32");
const crypto_1 = require("a13568a7d50bc71b");
const encoding_1 = require("18e6a84c77738bb5");
const utils_1 = require("2386718c5587a8c6");
const signing_1 = require("e47f38cfbf743642");
const wallet_1 = require("490b2338766f04f7");
const serializationTypeV1 = "directsecp256k1hdwallet-v1";
/**
 * A KDF configuration that is not very strong but can be used on the main thread.
 * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.
 */ const basicPasswordHashingOptions = {
    algorithm: "argon2id",
    params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12288
    }
};
function isDerivationJson(thing) {
    if (!(0, utils_1.isNonNullObject)(thing)) return false;
    if (typeof thing.hdPath !== "string") return false;
    if (typeof thing.prefix !== "string") return false;
    return true;
}
function extractKdfConfigurationV1(doc) {
    return doc.kdf;
}
function extractKdfConfiguration(serialization) {
    const root = JSON.parse(serialization);
    if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
    switch(root.type){
        case serializationTypeV1:
            return extractKdfConfigurationV1(root);
        default:
            throw new Error("Unsupported serialization type");
    }
}
const defaultOptions = {
    bip39Password: "",
    hdPaths: [
        (0, amino_1.makeCosmoshubPath)(0)
    ],
    prefix: "cosmos"
};
/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */ class DirectSecp256k1HdWallet {
    /**
     * Restores a wallet from the given BIP39 mnemonic.
     *
     * @param mnemonic Any valid English mnemonic.
     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */ static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new DirectSecp256k1HdWallet(mnemonicChecked, {
            ...options,
            seed: seed
        });
    }
    /**
     * Generates a new wallet with a BIP39 mnemonic of the given length.
     *
     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */ static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
    }
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * @param password The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
        switch(root.type){
            case serializationTypeV1:
                return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
            default:
                throw new Error("Unsupported serialization type");
        }
    }
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch(untypedRoot.type){
            case serializationTypeV1:
                {
                    const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
                    const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
                    const { mnemonic, accounts } = decryptedDocument;
                    (0, utils_1.assert)(typeof mnemonic === "string");
                    if (!Array.isArray(accounts)) throw new Error("Property 'accounts' is not an array");
                    if (!accounts.every((account)=>isDerivationJson(account))) throw new Error("Account is not in the correct format.");
                    const firstPrefix = accounts[0].prefix;
                    if (!accounts.every(({ prefix })=>prefix === firstPrefix)) throw new Error("Accounts do not all have the same prefix");
                    const hdPaths = accounts.map(({ hdPath })=>(0, crypto_1.stringToPath)(hdPath));
                    return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
                        hdPaths: hdPaths,
                        prefix: firstPrefix
                    });
                }
            default:
                throw new Error("Unsupported serialization type");
        }
    }
    static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
    }
    /** Base secret */ secret;
    /** BIP39 seed */ seed;
    /** Derivation instructions */ accounts;
    constructor(mnemonic, options){
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath)=>({
                hdPath: hdPath,
                prefix: prefix
            }));
    }
    get mnemonic() {
        return this.secret.toString();
    }
    async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address })=>({
                algo: algo,
                pubkey: pubkey,
                address: address
            }));
    }
    async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address })=>address === signerAddress);
        if (account === undefined) throw new Error(`Address ${signerAddress} not found in wallet`);
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([
            ...signature.r(32),
            ...signature.s(32)
        ]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
            signed: signDoc,
            signature: stdSignature
        };
    }
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * @param password The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
    }
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF options. If this
     * is not the case, the wallet cannot be restored with the original password.
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
            mnemonic: this.mnemonic,
            accounts: this.accounts.map(({ hdPath, prefix })=>({
                    hdPath: (0, crypto_1.pathToString)(hdPath),
                    prefix: prefix
                }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
            algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
            type: serializationTypeV1,
            kdf: kdfConfiguration,
            encryption: encryptionConfiguration,
            data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
    }
    async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
            privkey: privkey,
            pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
    }
    async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix })=>{
            const { privkey, pubkey } = await this.getKeyPair(hdPath);
            const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
            return {
                algo: "secp256k1",
                privkey: privkey,
                pubkey: pubkey,
                address: address
            };
        }));
    }
}
exports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;

},{"6675bf1f8c853f32":"bh8mf","a13568a7d50bc71b":"kTd5b","18e6a84c77738bb5":"enCPS","2386718c5587a8c6":"3R4mb","e47f38cfbf743642":"g8GJ3","490b2338766f04f7":"3QlLM"}],"bh8mf":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.executeKdf = exports.makeStdTx = exports.isStdTx = exports.serializeSignDoc = exports.makeSignDoc = exports.encodeSecp256k1Signature = exports.decodeSignature = exports.Secp256k1Wallet = exports.Secp256k1HdWallet = exports.extractKdfConfiguration = exports.pubkeyType = exports.isSinglePubkey = exports.isSecp256k1Pubkey = exports.isMultisigThresholdPubkey = exports.isEd25519Pubkey = exports.makeCosmoshubPath = exports.omitDefault = exports.createMultisigThresholdPubkey = exports.encodeSecp256k1Pubkey = exports.encodeEd25519Pubkey = exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.parseCoins = exports.coins = exports.coin = exports.addCoins = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
var addresses_1 = require("e1824bcf3b98bf6f");
Object.defineProperty(exports, "pubkeyToAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.pubkeyToAddress;
    }
});
Object.defineProperty(exports, "pubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.pubkeyToRawAddress;
    }
});
Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.rawEd25519PubkeyToRawAddress;
    }
});
Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.rawSecp256k1PubkeyToRawAddress;
    }
});
var coins_1 = require("e2f7e16b1d9bd6c0");
Object.defineProperty(exports, "addCoins", {
    enumerable: true,
    get: function() {
        return coins_1.addCoins;
    }
});
Object.defineProperty(exports, "coin", {
    enumerable: true,
    get: function() {
        return coins_1.coin;
    }
});
Object.defineProperty(exports, "coins", {
    enumerable: true,
    get: function() {
        return coins_1.coins;
    }
});
Object.defineProperty(exports, "parseCoins", {
    enumerable: true,
    get: function() {
        return coins_1.parseCoins;
    }
});
var encoding_1 = require("9f30347372e52cef");
Object.defineProperty(exports, "decodeAminoPubkey", {
    enumerable: true,
    get: function() {
        return encoding_1.decodeAminoPubkey;
    }
});
Object.defineProperty(exports, "decodeBech32Pubkey", {
    enumerable: true,
    get: function() {
        return encoding_1.decodeBech32Pubkey;
    }
});
Object.defineProperty(exports, "encodeAminoPubkey", {
    enumerable: true,
    get: function() {
        return encoding_1.encodeAminoPubkey;
    }
});
Object.defineProperty(exports, "encodeBech32Pubkey", {
    enumerable: true,
    get: function() {
        return encoding_1.encodeBech32Pubkey;
    }
});
Object.defineProperty(exports, "encodeEd25519Pubkey", {
    enumerable: true,
    get: function() {
        return encoding_1.encodeEd25519Pubkey;
    }
});
Object.defineProperty(exports, "encodeSecp256k1Pubkey", {
    enumerable: true,
    get: function() {
        return encoding_1.encodeSecp256k1Pubkey;
    }
});
var multisig_1 = require("122d36691b652bcc");
Object.defineProperty(exports, "createMultisigThresholdPubkey", {
    enumerable: true,
    get: function() {
        return multisig_1.createMultisigThresholdPubkey;
    }
});
var omitdefault_1 = require("ed2b18a6178619f8");
Object.defineProperty(exports, "omitDefault", {
    enumerable: true,
    get: function() {
        return omitdefault_1.omitDefault;
    }
});
var paths_1 = require("fa26751de0066333");
Object.defineProperty(exports, "makeCosmoshubPath", {
    enumerable: true,
    get: function() {
        return paths_1.makeCosmoshubPath;
    }
});
var pubkeys_1 = require("49bdce9f02e13cf4");
Object.defineProperty(exports, "isEd25519Pubkey", {
    enumerable: true,
    get: function() {
        return pubkeys_1.isEd25519Pubkey;
    }
});
Object.defineProperty(exports, "isMultisigThresholdPubkey", {
    enumerable: true,
    get: function() {
        return pubkeys_1.isMultisigThresholdPubkey;
    }
});
Object.defineProperty(exports, "isSecp256k1Pubkey", {
    enumerable: true,
    get: function() {
        return pubkeys_1.isSecp256k1Pubkey;
    }
});
Object.defineProperty(exports, "isSinglePubkey", {
    enumerable: true,
    get: function() {
        return pubkeys_1.isSinglePubkey;
    }
});
Object.defineProperty(exports, "pubkeyType", {
    enumerable: true,
    get: function() {
        return pubkeys_1.pubkeyType;
    }
});
var secp256k1hdwallet_1 = require("34ee96c2724e14d1");
Object.defineProperty(exports, "extractKdfConfiguration", {
    enumerable: true,
    get: function() {
        return secp256k1hdwallet_1.extractKdfConfiguration;
    }
});
Object.defineProperty(exports, "Secp256k1HdWallet", {
    enumerable: true,
    get: function() {
        return secp256k1hdwallet_1.Secp256k1HdWallet;
    }
});
var secp256k1wallet_1 = require("ba8fe486005d13ff");
Object.defineProperty(exports, "Secp256k1Wallet", {
    enumerable: true,
    get: function() {
        return secp256k1wallet_1.Secp256k1Wallet;
    }
});
var signature_1 = require("9e0ce10d80d95e1a");
Object.defineProperty(exports, "decodeSignature", {
    enumerable: true,
    get: function() {
        return signature_1.decodeSignature;
    }
});
Object.defineProperty(exports, "encodeSecp256k1Signature", {
    enumerable: true,
    get: function() {
        return signature_1.encodeSecp256k1Signature;
    }
});
var signdoc_1 = require("deebadfb7762a51c");
Object.defineProperty(exports, "makeSignDoc", {
    enumerable: true,
    get: function() {
        return signdoc_1.makeSignDoc;
    }
});
Object.defineProperty(exports, "serializeSignDoc", {
    enumerable: true,
    get: function() {
        return signdoc_1.serializeSignDoc;
    }
});
var stdtx_1 = require("14de45eba64c6390");
Object.defineProperty(exports, "isStdTx", {
    enumerable: true,
    get: function() {
        return stdtx_1.isStdTx;
    }
});
Object.defineProperty(exports, "makeStdTx", {
    enumerable: true,
    get: function() {
        return stdtx_1.makeStdTx;
    }
});
var wallet_1 = require("fa3d63963a7abf83");
Object.defineProperty(exports, "executeKdf", {
    enumerable: true,
    get: function() {
        return wallet_1.executeKdf;
    }
});

},{"e1824bcf3b98bf6f":"jpNc8","e2f7e16b1d9bd6c0":"R7jkn","9f30347372e52cef":"g8Pi0","122d36691b652bcc":"b2dH1","ed2b18a6178619f8":"574NG","fa26751de0066333":"hdWZv","49bdce9f02e13cf4":"gbh6J","34ee96c2724e14d1":"fLhzh","ba8fe486005d13ff":"7pTgv","9e0ce10d80d95e1a":"2oD6x","deebadfb7762a51c":"amSWz","14de45eba64c6390":"gEESx","fa3d63963a7abf83":"9EHAa"}],"jpNc8":[function(require,module,exports,__globalThis) {
"use strict";
// See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
exports.pubkeyToRawAddress = pubkeyToRawAddress;
exports.pubkeyToAddress = pubkeyToAddress;
const crypto_1 = require("e8ecdfd632276c8");
const encoding_1 = require("5b769938ee9af813");
const encoding_2 = require("3193d95724554e38");
const pubkeys_1 = require("d13b9995e03ab8e");
function rawEd25519PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 32) throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
}
function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 33) throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
    return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
}
// For secp256k1 this assumes we already have a compressed pubkey.
function pubkeyToRawAddress(pubkey) {
    if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
    } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
    } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        // https://github.com/tendermint/tendermint/blob/38b401657e4ad7a7eeb3c30a3cbf512037df3740/crypto/multisig/threshold_pubkey.go#L71-L74
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    } else throw new Error("Unsupported public key type");
}
function pubkeyToAddress(pubkey, prefix) {
    return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
}

},{"e8ecdfd632276c8":"kTd5b","5b769938ee9af813":"enCPS","3193d95724554e38":"g8Pi0","d13b9995e03ab8e":"gbh6J"}],"kTd5b":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringToPath = exports.Slip10RawIndex = exports.slip10CurveFromString = exports.Slip10Curve = exports.Slip10 = exports.pathToString = exports.sha512 = exports.Sha512 = exports.sha256 = exports.Sha256 = exports.Secp256k1Signature = exports.ExtendedSecp256k1Signature = exports.Secp256k1 = exports.ripemd160 = exports.Ripemd160 = exports.Random = exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.isArgon2idOptions = exports.Ed25519Keypair = exports.Ed25519 = exports.Argon2id = exports.keccak256 = exports.Keccak256 = exports.Hmac = exports.EnglishMnemonic = exports.Bip39 = void 0;
var bip39_1 = require("e0aef6f0930e63ec");
Object.defineProperty(exports, "Bip39", {
    enumerable: true,
    get: function() {
        return bip39_1.Bip39;
    }
});
Object.defineProperty(exports, "EnglishMnemonic", {
    enumerable: true,
    get: function() {
        return bip39_1.EnglishMnemonic;
    }
});
var hmac_1 = require("4c28d63089131db1");
Object.defineProperty(exports, "Hmac", {
    enumerable: true,
    get: function() {
        return hmac_1.Hmac;
    }
});
var keccak_1 = require("d484b2518e29c724");
Object.defineProperty(exports, "Keccak256", {
    enumerable: true,
    get: function() {
        return keccak_1.Keccak256;
    }
});
Object.defineProperty(exports, "keccak256", {
    enumerable: true,
    get: function() {
        return keccak_1.keccak256;
    }
});
var libsodium_1 = require("ec32e05f04d98bee");
Object.defineProperty(exports, "Argon2id", {
    enumerable: true,
    get: function() {
        return libsodium_1.Argon2id;
    }
});
Object.defineProperty(exports, "Ed25519", {
    enumerable: true,
    get: function() {
        return libsodium_1.Ed25519;
    }
});
Object.defineProperty(exports, "Ed25519Keypair", {
    enumerable: true,
    get: function() {
        return libsodium_1.Ed25519Keypair;
    }
});
Object.defineProperty(exports, "isArgon2idOptions", {
    enumerable: true,
    get: function() {
        return libsodium_1.isArgon2idOptions;
    }
});
Object.defineProperty(exports, "xchacha20NonceLength", {
    enumerable: true,
    get: function() {
        return libsodium_1.xchacha20NonceLength;
    }
});
Object.defineProperty(exports, "Xchacha20poly1305Ietf", {
    enumerable: true,
    get: function() {
        return libsodium_1.Xchacha20poly1305Ietf;
    }
});
var random_1 = require("6a4e194187079cf0");
Object.defineProperty(exports, "Random", {
    enumerable: true,
    get: function() {
        return random_1.Random;
    }
});
var ripemd_1 = require("3dc585959c064a6f");
Object.defineProperty(exports, "Ripemd160", {
    enumerable: true,
    get: function() {
        return ripemd_1.Ripemd160;
    }
});
Object.defineProperty(exports, "ripemd160", {
    enumerable: true,
    get: function() {
        return ripemd_1.ripemd160;
    }
});
var secp256k1_1 = require("2ba45f9b35d7a8c7");
Object.defineProperty(exports, "Secp256k1", {
    enumerable: true,
    get: function() {
        return secp256k1_1.Secp256k1;
    }
});
var secp256k1signature_1 = require("ce649502c8e0cac6");
Object.defineProperty(exports, "ExtendedSecp256k1Signature", {
    enumerable: true,
    get: function() {
        return secp256k1signature_1.ExtendedSecp256k1Signature;
    }
});
Object.defineProperty(exports, "Secp256k1Signature", {
    enumerable: true,
    get: function() {
        return secp256k1signature_1.Secp256k1Signature;
    }
});
var sha_1 = require("3190d6911c3cdf4b");
Object.defineProperty(exports, "Sha256", {
    enumerable: true,
    get: function() {
        return sha_1.Sha256;
    }
});
Object.defineProperty(exports, "sha256", {
    enumerable: true,
    get: function() {
        return sha_1.sha256;
    }
});
Object.defineProperty(exports, "Sha512", {
    enumerable: true,
    get: function() {
        return sha_1.Sha512;
    }
});
Object.defineProperty(exports, "sha512", {
    enumerable: true,
    get: function() {
        return sha_1.sha512;
    }
});
var slip10_1 = require("5b1f24cf767051d3");
Object.defineProperty(exports, "pathToString", {
    enumerable: true,
    get: function() {
        return slip10_1.pathToString;
    }
});
Object.defineProperty(exports, "Slip10", {
    enumerable: true,
    get: function() {
        return slip10_1.Slip10;
    }
});
Object.defineProperty(exports, "Slip10Curve", {
    enumerable: true,
    get: function() {
        return slip10_1.Slip10Curve;
    }
});
Object.defineProperty(exports, "slip10CurveFromString", {
    enumerable: true,
    get: function() {
        return slip10_1.slip10CurveFromString;
    }
});
Object.defineProperty(exports, "Slip10RawIndex", {
    enumerable: true,
    get: function() {
        return slip10_1.Slip10RawIndex;
    }
});
Object.defineProperty(exports, "stringToPath", {
    enumerable: true,
    get: function() {
        return slip10_1.stringToPath;
    }
});

},{"e0aef6f0930e63ec":"7PGlc","4c28d63089131db1":"b5ho1","d484b2518e29c724":"aqfvg","ec32e05f04d98bee":"1ZvZW","6a4e194187079cf0":"5uiZs","3dc585959c064a6f":"20zbp","2ba45f9b35d7a8c7":"duDm8","ce649502c8e0cac6":"4pSav","3190d6911c3cdf4b":"kKVwh","5b1f24cf767051d3":"fhULm"}],"7PGlc":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Bip39 = exports.EnglishMnemonic = void 0;
exports.entropyToMnemonic = entropyToMnemonic;
exports.mnemonicToEntropy = mnemonicToEntropy;
const encoding_1 = require("415ec9ae8dc94526");
const pbkdf2_1 = require("25e1b55e8c6204c5");
const sha_1 = require("69977aca9172aba5");
const wordlist = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];
function bytesToBitstring(bytes) {
    return Array.from(bytes).map((byte)=>byte.toString(2).padStart(8, "0")).join("");
}
function deriveChecksumBits(entropy) {
    const entropyLengthBits = entropy.length * 8; // "ENT" (in bits)
    const checksumLengthBits = entropyLengthBits / 32; // "CS" (in bits)
    const hash = (0, sha_1.sha256)(entropy);
    return bytesToBitstring(hash).slice(0, checksumLengthBits);
}
function bitstringToByte(bin) {
    return parseInt(bin, 2);
}
const allowedEntropyLengths = [
    16,
    20,
    24,
    28,
    32
];
const allowedWordLengths = [
    12,
    15,
    18,
    21,
    24
];
function entropyToMnemonic(entropy) {
    if (allowedEntropyLengths.indexOf(entropy.length) === -1) throw new Error("invalid input length");
    const entropyBits = bytesToBitstring(entropy);
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const chunks = bits.match(/(.{11})/g);
    const words = chunks.map((binary)=>{
        const index = bitstringToByte(binary);
        return wordlist[index];
    });
    return words.join(" ");
}
const invalidNumberOfWords = "Invalid number of words";
const wordNotInWordlist = "Found word that is not in the wordlist";
const invalidEntropy = "Invalid entropy";
const invalidChecksum = "Invalid mnemonic checksum";
function normalize(str) {
    return str.normalize("NFKD");
}
function mnemonicToEntropy(mnemonic) {
    const words = normalize(mnemonic).split(" ");
    if (!allowedWordLengths.includes(words.length)) throw new Error(invalidNumberOfWords);
    // convert word indices to 11 bit binary strings
    const bits = words.map((word)=>{
        const index = wordlist.indexOf(word);
        if (index === -1) throw new Error(wordNotInWordlist);
        return index.toString(2).padStart(11, "0");
    }).join("");
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(bitstringToByte);
    if (entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) throw new Error(invalidEntropy);
    const entropy = Uint8Array.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) throw new Error(invalidChecksum);
    return entropy;
}
class EnglishMnemonic {
    static wordlist = wordlist;
    // list of space separated lower case words (1 or more)
    static mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
    data;
    constructor(mnemonic){
        if (!EnglishMnemonic.mnemonicMatcher.test(mnemonic)) throw new Error("Invalid mnemonic format");
        const words = mnemonic.split(" ");
        const allowedWordsLengths = [
            12,
            15,
            18,
            21,
            24
        ];
        if (allowedWordsLengths.indexOf(words.length) === -1) throw new Error(`Invalid word count in mnemonic (allowed: ${allowedWordsLengths} got: ${words.length})`);
        for (const word of words){
            if (EnglishMnemonic.wordlist.indexOf(word) === -1) throw new Error("Mnemonic contains invalid word");
        }
        // Throws with informative error message if mnemonic is not valid
        mnemonicToEntropy(mnemonic);
        this.data = mnemonic;
    }
    toString() {
        return this.data;
    }
}
exports.EnglishMnemonic = EnglishMnemonic;
class Bip39 {
    /**
     * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
     *
     * | Entropy            | Words |
     * |--------------------|-------|
     * | 128 bit (16 bytes) |    12 |
     * | 160 bit (20 bytes) |    15 |
     * | 192 bit (24 bytes) |    18 |
     * | 224 bit (28 bytes) |    21 |
     * | 256 bit (32 bytes) |    24 |
     *
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
     * @param entropy The entropy to be encoded. This must be cryptographically secure.
     */ static encode(entropy) {
        return new EnglishMnemonic(entropyToMnemonic(entropy));
    }
    static decode(mnemonic) {
        return mnemonicToEntropy(mnemonic.toString());
    }
    static async mnemonicToSeed(mnemonic, password) {
        const mnemonicBytes = (0, encoding_1.toUtf8)(normalize(mnemonic.toString()));
        const salt = "mnemonic" + (password ? normalize(password) : "");
        const saltBytes = (0, encoding_1.toUtf8)(salt);
        return (0, pbkdf2_1.pbkdf2Sha512)(mnemonicBytes, saltBytes, 2048, 64);
    }
}
exports.Bip39 = Bip39;

},{"415ec9ae8dc94526":"enCPS","25e1b55e8c6204c5":"gbgrR","69977aca9172aba5":"kKVwh"}],"enCPS":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toUtf8 = exports.fromUtf8 = exports.toRfc3339 = exports.fromRfc3339 = exports.toHex = exports.fromHex = exports.toBech32 = exports.normalizeBech32 = exports.fromBech32 = exports.toBase64 = exports.fromBase64 = exports.toAscii = exports.fromAscii = void 0;
var ascii_1 = require("6eb19100b7f6ff4a");
Object.defineProperty(exports, "fromAscii", {
    enumerable: true,
    get: function() {
        return ascii_1.fromAscii;
    }
});
Object.defineProperty(exports, "toAscii", {
    enumerable: true,
    get: function() {
        return ascii_1.toAscii;
    }
});
var base64_1 = require("91075c3f2934ca91");
Object.defineProperty(exports, "fromBase64", {
    enumerable: true,
    get: function() {
        return base64_1.fromBase64;
    }
});
Object.defineProperty(exports, "toBase64", {
    enumerable: true,
    get: function() {
        return base64_1.toBase64;
    }
});
var bech32_1 = require("4e24df9afe0124f1");
Object.defineProperty(exports, "fromBech32", {
    enumerable: true,
    get: function() {
        return bech32_1.fromBech32;
    }
});
Object.defineProperty(exports, "normalizeBech32", {
    enumerable: true,
    get: function() {
        return bech32_1.normalizeBech32;
    }
});
Object.defineProperty(exports, "toBech32", {
    enumerable: true,
    get: function() {
        return bech32_1.toBech32;
    }
});
var hex_1 = require("bd061d82491d73cf");
Object.defineProperty(exports, "fromHex", {
    enumerable: true,
    get: function() {
        return hex_1.fromHex;
    }
});
Object.defineProperty(exports, "toHex", {
    enumerable: true,
    get: function() {
        return hex_1.toHex;
    }
});
var rfc3339_1 = require("b31fee55f5929043");
Object.defineProperty(exports, "fromRfc3339", {
    enumerable: true,
    get: function() {
        return rfc3339_1.fromRfc3339;
    }
});
Object.defineProperty(exports, "toRfc3339", {
    enumerable: true,
    get: function() {
        return rfc3339_1.toRfc3339;
    }
});
var utf8_1 = require("b0775ca06b557c88");
Object.defineProperty(exports, "fromUtf8", {
    enumerable: true,
    get: function() {
        return utf8_1.fromUtf8;
    }
});
Object.defineProperty(exports, "toUtf8", {
    enumerable: true,
    get: function() {
        return utf8_1.toUtf8;
    }
});

},{"6eb19100b7f6ff4a":"j7ng7","91075c3f2934ca91":"9wA2y","4e24df9afe0124f1":"1p46z","bd061d82491d73cf":"fJzl1","b31fee55f5929043":"88AaQ","b0775ca06b557c88":"5bQaQ"}],"j7ng7":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toAscii = toAscii;
exports.fromAscii = fromAscii;
function toAscii(input) {
    const toNums = (str)=>str.split("").map((x)=>{
            const charCode = x.charCodeAt(0);
            // 0x000x1F control characters
            // 0x200x7E printable characters
            // 0x7F delete character
            // 0x800xFF out of 7 bit ascii range
            if (charCode < 0x20 || charCode > 0x7e) throw new Error(`Cannot encode character that is out of printable ASCII range: ${charCode}`);
            return charCode;
        });
    return Uint8Array.from(toNums(input));
}
function fromAscii(data) {
    const fromNums = (listOfNumbers)=>listOfNumbers.map((x)=>{
            // 0x000x1F control characters
            // 0x200x7E printable characters
            // 0x7F delete character
            // 0x800xFF out of 7 bit ascii range
            if (x < 0x20 || x > 0x7e) throw new Error(`Cannot decode character that is out of printable ASCII range: ${x}`);
            return String.fromCharCode(x);
        });
    return fromNums(Array.from(data)).join("");
}

},{}],"9wA2y":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBase64 = toBase64;
exports.fromBase64 = fromBase64;
const base64js = __importStar(require("4a460000ee91cbf9"));
function toBase64(data) {
    return base64js.fromByteArray(data);
}
function fromBase64(base64String) {
    if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) throw new Error("Invalid base64 string format");
    return base64js.toByteArray(base64String);
}

},{"4a460000ee91cbf9":"9I2RJ"}],"1p46z":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBech32 = toBech32;
exports.fromBech32 = fromBech32;
exports.normalizeBech32 = normalizeBech32;
const bech32 = __importStar(require("b1e7c31af2ace242"));
function toBech32(prefix, data, limit) {
    const address = bech32.encode(prefix, bech32.toWords(data), limit);
    return address;
}
function fromBech32(address, limit = Infinity) {
    const decodedAddress = bech32.decode(address, limit);
    return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(bech32.fromWords(decodedAddress.words))
    };
}
/**
 * Takes a bech32 address and returns a normalized (i.e. lower case) representation of it.
 *
 * The input is validated along the way, which makes this significantly safer than
 * using `address.toLowerCase()`.
 */ function normalizeBech32(address) {
    const { prefix, data } = fromBech32(address);
    return toBech32(prefix, data);
}

},{"b1e7c31af2ace242":"6NFHR"}],"6NFHR":[function(require,module,exports,__globalThis) {
'use strict';
var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
// pre-compute lookup table
var ALPHABET_MAP = {};
for(var z = 0; z < ALPHABET.length; z++){
    var x = ALPHABET.charAt(z);
    if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    var b = pre >> 25;
    return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
    var chk = 1;
    for(var i = 0; i < prefix.length; ++i){
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for(i = 0; i < prefix.length; ++i){
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 0x1f;
    }
    return chk;
}
function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
    prefix = prefix.toLowerCase();
    // determine chk mod
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') throw new Error(chk);
    var result = prefix + '1';
    for(var i = 0; i < words.length; ++i){
        var x = words[i];
        if (x >> 5 !== 0) throw new Error('Non 5-bit word');
        chk = polymodStep(chk) ^ x;
        result += ALPHABET.charAt(x);
    }
    for(i = 0; i < 6; ++i)chk = polymodStep(chk);
    chk ^= 1;
    for(i = 0; i < 6; ++i){
        var v = chk >> (5 - i) * 5 & 0x1f;
        result += ALPHABET.charAt(v);
    }
    return result;
}
function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + ' too short';
    if (str.length > LIMIT) return 'Exceeds length limit';
    // don't allow mixed case
    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
    str = lowered;
    var split = str.lastIndexOf('1');
    if (split === -1) return 'No separator character for ' + str;
    if (split === 0) return 'Missing prefix for ' + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return 'Data too short';
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') return chk;
    var words = [];
    for(var i = 0; i < wordChars.length; ++i){
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === undefined) return 'Unknown character ' + c;
        chk = polymodStep(chk) ^ v;
        // not in the checksum?
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
    }
    if (chk !== 1) return 'Invalid checksum for ' + str;
    return {
        prefix: prefix,
        words: words
    };
}
function decodeUnsafe() {
    var res = __decode.apply(null, arguments);
    if (typeof res === 'object') return res;
}
function decode(str) {
    var res = __decode.apply(null, arguments);
    if (typeof res === 'object') return res;
    throw new Error(res);
}
function convert(data, inBits, outBits, pad) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];
    for(var i = 0; i < data.length; ++i){
        value = value << inBits | data[i];
        bits += inBits;
        while(bits >= outBits){
            bits -= outBits;
            result.push(value >> bits & maxV);
        }
    }
    if (pad) {
        if (bits > 0) result.push(value << outBits - bits & maxV);
    } else {
        if (bits >= inBits) return 'Excess padding';
        if (value << outBits - bits & maxV) return 'Non-zero padding';
    }
    return result;
}
function toWordsUnsafe(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
}
function toWords(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
function fromWordsUnsafe(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
}
function fromWords(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
module.exports = {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWordsUnsafe: toWordsUnsafe,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
};

},{}],"fJzl1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toHex = toHex;
exports.fromHex = fromHex;
function toHex(data) {
    let out = "";
    for (const byte of data)out += ("0" + byte.toString(16)).slice(-2);
    return out;
}
function fromHex(hexstring) {
    if (hexstring.length % 2 !== 0) throw new Error("hex string length must be a multiple of 2");
    const out = new Uint8Array(hexstring.length / 2);
    for(let i = 0; i < out.length; i++){
        const j = 2 * i;
        const hexByteAsString = hexstring.slice(j, j + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) throw new Error("hex string contains invalid characters");
        out[i] = parseInt(hexByteAsString, 16);
    }
    return out;
}

},{}],"88AaQ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromRfc3339 = fromRfc3339;
exports.toRfc3339 = toRfc3339;
const rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
function padded(integer, length = 2) {
    return integer.toString().padStart(length, "0");
}
function fromRfc3339(str) {
    const matches = rfc3339Matcher.exec(str);
    if (!matches) throw new Error("Date string is not in RFC3339 format");
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    const hour = +matches[4];
    const minute = +matches[5];
    const second = +matches[6];
    // fractional seconds match either undefined or a string like ".1", ".123456789"
    const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;
    let tzOffsetSign;
    let tzOffsetHours;
    let tzOffsetMinutes;
    // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).
    if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
    } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
    }
    const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds
    const date = new Date();
    date.setUTCFullYear(year, month - 1, day);
    date.setUTCHours(hour, minute, second, milliSeconds);
    return new Date(date.getTime() - tzOffset * 1000);
}
function toRfc3339(date) {
    const year = date.getUTCFullYear();
    const month = padded(date.getUTCMonth() + 1);
    const day = padded(date.getUTCDate());
    const hour = padded(date.getUTCHours());
    const minute = padded(date.getUTCMinutes());
    const second = padded(date.getUTCSeconds());
    const ms = padded(date.getUTCMilliseconds(), 3);
    return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
}

},{}],"5bQaQ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toUtf8 = toUtf8;
exports.fromUtf8 = fromUtf8;
function toUtf8(str) {
    return new TextEncoder().encode(str);
}
/**
 * Takes UTF-8 data and decodes it to a string.
 *
 * In lossy mode, the [REPLACEMENT CHARACTER](https://en.wikipedia.org/wiki/Specials_(Unicode_block))
 * is used to substitute invalid encodings.
 * By default lossy mode is off and invalid data will lead to exceptions.
 */ function fromUtf8(data, lossy = false) {
    const fatal = !lossy;
    return new TextDecoder("utf-8", {
        fatal
    }).decode(data);
}

},{}],"gbgrR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSubtle = getSubtle;
exports.pbkdf2Sha512Subtle = pbkdf2Sha512Subtle;
exports.pbkdf2Sha512Noble = pbkdf2Sha512Noble;
exports.pbkdf2Sha512 = pbkdf2Sha512;
const utils_1 = require("2d2de8852646b871");
const pbkdf2_1 = require("6364052c0553a502");
const sha2_js_1 = require("c4fa2b32311fef9f");
/**
 * Returns the SubtleCrypto API for this environment if present.
 *
 * Right now (CosmJS 0.35), all supported environments we are aware of have
 * SubtleCrypto. However, we keep the optional return type just in case as we can
 * use the pure-JS fallback.
 */ async function getSubtle() {
    // From Node.js 15 onwards, webcrypto is available in globalThis.
    // In version 15 and 16 this was stored under the webcrypto key.
    // With Node.js 17 it was moved to the same locations where browsers
    // make it available.
    // Loading `require("crypto")` here seems unnecessary since it only
    // causes issues with bundlers and does not increase compatibility.
    return globalThis?.crypto?.subtle;
}
async function pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen) {
    (0, utils_1.assert)(subtle, "Argument subtle is falsy");
    (0, utils_1.assert)(typeof subtle === "object", "Argument subtle is not of type object");
    (0, utils_1.assert)(typeof subtle.importKey === "function", "subtle.importKey is not a function");
    (0, utils_1.assert)(typeof subtle.deriveBits === "function", "subtle.deriveBits is not a function");
    return subtle.importKey("raw", secret, {
        name: "PBKDF2"
    }, false, [
        "deriveBits"
    ]).then((key)=>subtle.deriveBits({
            name: "PBKDF2",
            salt: salt,
            iterations: iterations,
            hash: {
                name: "SHA-512"
            }
        }, key, keylen * 8).then((buffer)=>new Uint8Array(buffer)));
}
async function pbkdf2Sha512Noble(secret, salt, iterations, keylen) {
    return (0, pbkdf2_1.pbkdf2Async)(sha2_js_1.sha512, secret, salt, {
        c: iterations,
        dkLen: keylen
    });
}
/**
 * A pbkdf2 implementation for BIP39. This is not exported at package level and thus a private API.
 */ async function pbkdf2Sha512(secret, salt, iterations, keylen) {
    const subtle = await getSubtle();
    if (subtle) return pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen);
    else return pbkdf2Sha512Noble(secret, salt, iterations, keylen);
}

},{"2d2de8852646b871":"3R4mb","6364052c0553a502":"9ICn6","c4fa2b32311fef9f":"5Nc2s"}],"3R4mb":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isUint8Array = exports.isNonNullObject = exports.isDefined = exports.sleep = exports.assertDefinedAndNotNull = exports.assertDefined = exports.assert = exports.arrayContentStartsWith = exports.arrayContentEquals = void 0;
var arrays_1 = require("f51dfd65d06af00b");
Object.defineProperty(exports, "arrayContentEquals", {
    enumerable: true,
    get: function() {
        return arrays_1.arrayContentEquals;
    }
});
Object.defineProperty(exports, "arrayContentStartsWith", {
    enumerable: true,
    get: function() {
        return arrays_1.arrayContentStartsWith;
    }
});
var assert_1 = require("2117434ca0f6c35c");
Object.defineProperty(exports, "assert", {
    enumerable: true,
    get: function() {
        return assert_1.assert;
    }
});
Object.defineProperty(exports, "assertDefined", {
    enumerable: true,
    get: function() {
        return assert_1.assertDefined;
    }
});
Object.defineProperty(exports, "assertDefinedAndNotNull", {
    enumerable: true,
    get: function() {
        return assert_1.assertDefinedAndNotNull;
    }
});
var sleep_1 = require("aa5fd2c10484a724");
Object.defineProperty(exports, "sleep", {
    enumerable: true,
    get: function() {
        return sleep_1.sleep;
    }
});
var typechecks_1 = require("8cc0dae0b3ed47c2");
Object.defineProperty(exports, "isDefined", {
    enumerable: true,
    get: function() {
        return typechecks_1.isDefined;
    }
});
Object.defineProperty(exports, "isNonNullObject", {
    enumerable: true,
    get: function() {
        return typechecks_1.isNonNullObject;
    }
});
Object.defineProperty(exports, "isUint8Array", {
    enumerable: true,
    get: function() {
        return typechecks_1.isUint8Array;
    }
});

},{"f51dfd65d06af00b":"hIsQD","2117434ca0f6c35c":"gAOb2","aa5fd2c10484a724":"amlMS","8cc0dae0b3ed47c2":"bdNbB"}],"hIsQD":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.arrayContentEquals = arrayContentEquals;
exports.arrayContentStartsWith = arrayContentStartsWith;
/**
 * Compares the content of two arrays-like objects for equality.
 *
 * Equality is defined as having equal length and element values, where element equality means `===` returning `true`.
 *
 * This allows you to compare the content of a Buffer, Uint8Array or number[], ignoring the specific type.
 * As a consequence, this returns different results than Jasmine's `toEqual`, which ensures elements have the same type.
 */ function arrayContentEquals(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; ++i){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
/**
 * Checks if `a` starts with the contents of `b`.
 *
 * This requires equality of the element values, where element equality means `===` returning `true`.
 *
 * This allows you to compare the content of a Buffer, Uint8Array or number[], ignoring the specific type.
 * As a consequence, this returns different results than Jasmine's `toEqual`, which ensures elements have the same type.
 */ function arrayContentStartsWith(a, b) {
    if (a.length < b.length) return false;
    for(let i = 0; i < b.length; ++i){
        if (a[i] !== b[i]) return false;
    }
    return true;
}

},{}],"gAOb2":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assert = assert;
exports.assertDefined = assertDefined;
exports.assertDefinedAndNotNull = assertDefinedAndNotNull;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function assert(condition, msg) {
    if (!condition) throw new Error(msg || "condition is not truthy");
}
function assertDefined(value, msg) {
    if (value === undefined) throw new Error(msg ?? "value is undefined");
}
function assertDefinedAndNotNull(value, msg) {
    if (value === undefined || value === null) throw new Error(msg ?? "value is undefined or null");
}

},{}],"amlMS":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sleep = sleep;
async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}

},{}],"bdNbB":[function(require,module,exports,__globalThis) {
var Buffer = require("198adb626d343d8b").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isNonNullObject = isNonNullObject;
exports.isUint8Array = isUint8Array;
exports.isDefined = isDefined;
/**
 * Checks if data is a non-null object (i.e. matches the TypeScript object type).
 *
 * Note: this returns true for arrays, which are objects in JavaScript
 * even though array and object are different types in JSON.
 *
 * @see https://www.typescriptlang.org/docs/handbook/basic-types.html#object
 */ function isNonNullObject(data) {
    return typeof data === "object" && data !== null;
}
/**
 * Checks if data is an Uint8Array. Note: Buffer is treated as not a Uint8Array
 */ function isUint8Array(data) {
    if (!isNonNullObject(data)) return false;
    // Avoid instanceof check which is unreliable in some JS environments
    // https://medium.com/@simonwarta/limitations-of-the-instanceof-operator-f4bcdbe7a400
    // Use check that was discussed in https://github.com/crypto-browserify/pbkdf2/pull/81
    if (Object.prototype.toString.call(data) !== "[object Uint8Array]") return false;
    if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        // Buffer.isBuffer is available at runtime
        if (Buffer.isBuffer(data)) return false;
    }
    return true;
}
/**
 * Checks if input is not undefined in a TypeScript-friendly way.
 *
 * This is convenient to use in e.g. `Array.filter` as it will convert
 * the type of a `Array<Foo | undefined>` to `Array<Foo>`.
 */ function isDefined(value) {
    return value !== undefined;
}

},{"198adb626d343d8b":"bCaf4"}],"9ICn6":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pbkdf2 = pbkdf2;
exports.pbkdf2Async = pbkdf2Async;
/**
 * PBKDF (RFC 2898). Can be used to create a key from password and salt.
 * @module
 */ const hmac_ts_1 = require("956a90fd4950a619");
// prettier-ignore
const utils_ts_1 = require("704e31af7d37dfd5");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash);
    const opts = (0, utils_ts_1.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1) throw new Error('iterations (c) should be >= 1');
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_ts_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return {
        c,
        dkLen,
        asyncTick,
        DK,
        PRF,
        PRFSalt
    };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 * @example
 * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });
 */ function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for(let ui = 1; ui < c; ui++){
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.
 * @example
 * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });
 */ async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, ()=>{
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

},{"956a90fd4950a619":"higgt","704e31af7d37dfd5":"fuxLy"}],"higgt":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */ const utils_ts_1 = require("337359ae358d0fc");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key)=>new HMAC(hash, key);

},{"337359ae358d0fc":"fuxLy"}],"fuxLy":[function(require,module,exports,__globalThis) {
"use strict";
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("308a0f9b8753b4af");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is positive integer. */ function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */ function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error('digestInto() expects output buffer of length at least ' + min);
}
/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++)arrays[i].fill(0);
}
/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */ function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);
/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */ function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++)arr[i] = byteSwap(arr[i]);
    return arr;
}
exports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */ const nextTick = async ()=>{};
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */ function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */ function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */ class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    throw new Error('crypto.getRandomValues must be defined');
}

},{"308a0f9b8753b4af":"hCvWO"}],"hCvWO":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

},{}],"5Nc2s":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ const _md_ts_1 = require("af0cede5cbbd2245");
const u64 = require("ae8242871b0e5f98");
const utils_ts_1 = require("6023160825f79395");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32){
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor(){
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (()=>u64.split([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();
const SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64){
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor(){
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8,
    0x19544da2,
    0x73e19966,
    0x89dcd4d6,
    0x1dfab7ae,
    0x32ff9c82,
    0x679dd514,
    0x582f9fcf,
    0x0f6d2b69,
    0x7bd44da8,
    0x77e36f73,
    0x04c48942,
    0x3f9d85a8,
    0x6a1d36c8,
    0x1112e6ad,
    0x91d692a1
]);
/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194,
    0xfc2bf72c,
    0x9f555fa3,
    0xc84c64c2,
    0x2393b86b,
    0x6f53b151,
    0x96387719,
    0x5940eabd,
    0x96283ee2,
    0xa88effe3,
    0xbe5e1e25,
    0x53863992,
    0x2b0199fc,
    0x2c85b8aa,
    0x0eb72ddc,
    0x81c52ca2
]);
class SHA512_224 extends SHA512 {
    constructor(){
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor(){
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */ exports.sha256 = (0, utils_ts_1.createHasher)(()=>new SHA256());
/** SHA2-224 hash function from RFC 4634 */ exports.sha224 = (0, utils_ts_1.createHasher)(()=>new SHA224());
/** SHA2-512 hash function from RFC 4634. */ exports.sha512 = (0, utils_ts_1.createHasher)(()=>new SHA512());
/** SHA2-384 hash function from RFC 4634. */ exports.sha384 = (0, utils_ts_1.createHasher)(()=>new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_256 = (0, utils_ts_1.createHasher)(()=>new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_224 = (0, utils_ts_1.createHasher)(()=>new SHA512_224());

},{"af0cede5cbbd2245":"dkX9O","ae8242871b0e5f98":"gNDUI","6023160825f79395":"fuxLy"}],"dkX9O":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ const utils_ts_1 = require("e667c0fa26fe74b7");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */ function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ exports.SHA256_IV = Uint32Array.from([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8,
    0x367cd507,
    0x3070dd17,
    0xf70e5939,
    0xffc00b31,
    0x68581511,
    0x64f98fa7,
    0xbefa4fa4
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d,
    0xc1059ed8,
    0x629a292a,
    0x367cd507,
    0x9159015a,
    0x3070dd17,
    0x152fecd8,
    0xf70e5939,
    0x67332667,
    0xffc00b31,
    0x8eb44a87,
    0x68581511,
    0xdb0c2e0d,
    0x64f98fa7,
    0x47b5481d,
    0xbefa4fa4
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ exports.SHA512_IV = Uint32Array.from([
    0x6a09e667,
    0xf3bcc908,
    0xbb67ae85,
    0x84caa73b,
    0x3c6ef372,
    0xfe94f82b,
    0xa54ff53a,
    0x5f1d36f1,
    0x510e527f,
    0xade682d1,
    0x9b05688c,
    0x2b3e6c1f,
    0x1f83d9ab,
    0xfb41bd6b,
    0x5be0cd19,
    0x137e2179
]);

},{"e667c0fa26fe74b7":"fuxLy"}],"gNDUI":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l)=>h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64;

},{}],"kKVwh":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sha512 = exports.Sha256 = void 0;
exports.sha256 = sha256;
exports.sha512 = sha512;
const sha2_js_1 = require("153daeb4cffa6ae8");
const utils_1 = require("d9b43d08aa155e0c");
class Sha256 {
    blockSize = 64;
    impl = sha2_js_1.sha256.create();
    constructor(firstData){
        if (firstData) this.update(firstData);
    }
    update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
    }
    digest() {
        return this.impl.digest();
    }
}
exports.Sha256 = Sha256;
/** Convenience function equivalent to `new Sha256(data).digest()` */ function sha256(data) {
    return new Sha256(data).digest();
}
class Sha512 {
    blockSize = 128;
    impl = sha2_js_1.sha512.create();
    constructor(firstData){
        if (firstData) this.update(firstData);
    }
    update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
    }
    digest() {
        return this.impl.digest();
    }
}
exports.Sha512 = Sha512;
/** Convenience function equivalent to `new Sha512(data).digest()` */ function sha512(data) {
    return new Sha512(data).digest();
}

},{"153daeb4cffa6ae8":"5Nc2s","d9b43d08aa155e0c":"7UmIW"}],"7UmIW":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toRealUint8Array = toRealUint8Array;
// See https://github.com/paulmillr/noble-hashes/issues/25 for why this is needed
function toRealUint8Array(data) {
    if (data instanceof Uint8Array) return data;
    else return Uint8Array.from(data);
}

},{}],"b5ho1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hmac = void 0;
class Hmac {
    blockSize;
    messageHasher;
    oKeyPad;
    iKeyPad;
    hash;
    constructor(hashFunctionConstructor, originalKey){
        // This implementation is based on https://en.wikipedia.org/wiki/HMAC#Implementation
        // with the addition of incremental hashing support. Thus part of the algorithm
        // is in the constructor and the rest in digest().
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data)=>new hashFunctionConstructor().update(data).digest();
        let key = originalKey;
        if (key.length > blockSize) key = this.hash(key);
        if (key.length < blockSize) {
            const zeroPadding = new Uint8Array(blockSize - key.length);
            key = new Uint8Array([
                ...key,
                ...zeroPadding
            ]);
        }
        // eslint-disable-next-line no-bitwise
        this.oKeyPad = key.map((keyByte)=>keyByte ^ 0x5c);
        // eslint-disable-next-line no-bitwise
        this.iKeyPad = key.map((keyByte)=>keyByte ^ 0x36);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
    }
    update(data) {
        this.messageHasher.update(data);
        return this;
    }
    digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([
            ...this.oKeyPad,
            ...innerHash
        ]));
    }
}
exports.Hmac = Hmac;

},{}],"aqfvg":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Keccak256 = void 0;
exports.keccak256 = keccak256;
const sha3_1 = require("6bef89668db6abf9");
const utils_1 = require("97f343ef37f3a464");
class Keccak256 {
    blockSize = 64;
    impl = sha3_1.keccak_256.create();
    constructor(firstData){
        if (firstData) this.update(firstData);
    }
    update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
    }
    digest() {
        return this.impl.digest();
    }
}
exports.Keccak256 = Keccak256;
/** Convenience function equivalent to `new Keccak256(data).digest()` */ function keccak256(data) {
    return new Keccak256(data).digest();
}

},{"6bef89668db6abf9":"by5a3","97f343ef37f3a464":"7UmIW"}],"by5a3":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */ const _u64_ts_1 = require("45e8a44e40fd6b7f");
// prettier-ignore
const utils_ts_1 = require("5a04751f3e786b49");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {
    const B = new Uint32Array(10);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta 
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */ class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200)) throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */ exports.sha3_224 = (()=>gen(0x06, 144, 28))();
/** SHA3-256 hash function. Different from keccak-256. */ exports.sha3_256 = (()=>gen(0x06, 136, 32))();
/** SHA3-384 hash function. */ exports.sha3_384 = (()=>gen(0x06, 104, 48))();
/** SHA3-512 hash function. */ exports.sha3_512 = (()=>gen(0x06, 72, 64))();
/** keccak-224 hash function. */ exports.keccak_224 = (()=>gen(0x01, 144, 28))();
/** keccak-256 hash function. Different from SHA3-256. */ exports.keccak_256 = (()=>gen(0x01, 136, 32))();
/** keccak-384 hash function. */ exports.keccak_384 = (()=>gen(0x01, 104, 48))();
/** keccak-512 hash function. */ exports.keccak_512 = (()=>gen(0x01, 72, 64))();
const genShake = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */ exports.shake128 = (()=>genShake(0x1f, 168, 16))();
/** SHAKE256 XOF with 256-bit security. */ exports.shake256 = (()=>genShake(0x1f, 136, 32))();

},{"45e8a44e40fd6b7f":"gNDUI","5a04751f3e786b49":"fuxLy"}],"1ZvZW":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.Ed25519 = exports.Ed25519Keypair = exports.Argon2id = void 0;
exports.isArgon2idOptions = isArgon2idOptions;
const utils_1 = require("f32142b427636cd0");
const chacha_js_1 = require("7874b52ec7ed4668");
const ed25519_js_1 = require("129f71876e0626af");
const hash_wasm_1 = require("6fe7a8e9787c2404");
function isArgon2idOptions(thing) {
    if (!(0, utils_1.isNonNullObject)(thing)) return false;
    if (typeof thing.outputLength !== "number") return false;
    if (typeof thing.opsLimit !== "number") return false;
    if (typeof thing.memLimitKib !== "number") return false;
    return true;
}
class Argon2id {
    static async execute(password, salt, options) {
        const opts = {
            password,
            salt,
            outputType: "binary",
            iterations: options.opsLimit,
            memorySize: options.memLimitKib,
            parallelism: 1,
            hashLength: options.outputLength
        };
        if (salt.length !== 16) throw new Error(`Got invalid salt length ${salt.length}. Must be 16.`);
        const hash = await (0, hash_wasm_1.argon2id)(opts);
        // guaranteed by outputType: 'binary'
        (0, utils_1.assert)(typeof hash !== "string");
        return hash;
    }
}
exports.Argon2id = Argon2id;
class Ed25519Keypair {
    // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
    static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        return new Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
    }
    privkey;
    pubkey;
    constructor(privkey, pubkey){
        this.privkey = privkey;
        this.pubkey = pubkey;
    }
    toLibsodiumPrivkey() {
        return new Uint8Array([
            ...this.privkey,
            ...this.pubkey
        ]);
    }
}
exports.Ed25519Keypair = Ed25519Keypair;
class Ed25519 {
    /**
     * Generates a keypair deterministically from a given 32 bytes seed.
     *
     * This seed equals the Ed25519 private key.
     * For implementation details see crypto_sign_seed_keypair in
     * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
     * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
     */ static async makeKeypair(privKey) {
        const pubKey = ed25519_js_1.ed25519.getPublicKey(privKey);
        return new Ed25519Keypair(privKey, pubKey);
    }
    static async createSignature(message, keyPair) {
        return ed25519_js_1.ed25519.sign(message, keyPair.privkey);
    }
    static async verifySignature(signature, message, pubkey) {
        return ed25519_js_1.ed25519.verify(signature, message, pubkey);
    }
}
exports.Ed25519 = Ed25519;
/**
 * Nonce length in bytes for all flavours of XChaCha20.
 *
 * @see https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xchacha20#notes
 */ exports.xchacha20NonceLength = 24;
class Xchacha20poly1305Ietf {
    static async encrypt(message, key, nonce) {
        const additionalAuthenticatedData = undefined;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.encrypt(message);
    }
    static async decrypt(ciphertext, key, nonce) {
        const additionalAuthenticatedData = undefined;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.decrypt(ciphertext);
    }
}
exports.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;

},{"f32142b427636cd0":"3R4mb","7874b52ec7ed4668":"lXF0m","129f71876e0626af":"ihmxa","6fe7a8e9787c2404":"ccEv4"}],"lXF0m":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.xchacha20poly1305 = exports.chacha20poly1305 = exports._poly1305_aead = exports.chacha12 = exports.chacha8 = exports.xchacha20 = exports.chacha20 = exports.chacha20orig = void 0;
exports.hchacha = hchacha;
/**
 * [ChaCha20](https://cr.yp.to/chacha.html) stream cipher, released
 * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.
 * It was standardized in [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and
 * is now used in TLS 1.3.
 *
 * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)
 * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with
 * randomly-generated nonces.
 *
 * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and
 * [wiki](https://en.wikipedia.org/wiki/Salsa20).
 * @module
 */ const _arx_ts_1 = require("9d5797bedbdd6e1f");
const _poly1305_ts_1 = require("4bc7624fcda0dfdf");
const utils_ts_1 = require("93240c83fe2b64be");
/**
 * ChaCha core function.
 */ // prettier-ignore
function chachaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter	Nonce   Nonce
    // Save state to temporary variables
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for(let r = 0; r < rounds; r += 2){
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
    }
    // Write output
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
}
/**
 * hchacha helper method, used primarily in xchacha, to hash
 * key and nonce into key' and nonce'.
 * Same as chachaCore, but there doesn't seem to be a way to move the block
 * out without 25% performance hit.
 */ // prettier-ignore
function hchacha(s, k, i, o32) {
    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for(let r = 0; r < 20; r += 2){
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
    }
    let oi = 0;
    o32[oi++] = x00;
    o32[oi++] = x01;
    o32[oi++] = x02;
    o32[oi++] = x03;
    o32[oi++] = x12;
    o32[oi++] = x13;
    o32[oi++] = x14;
    o32[oi++] = x15;
}
/**
 * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.
 */ exports.chacha20orig = (0, _arx_ts_1.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 8,
    allowShortKeys: true
});
/**
 * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.
 * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.
 */ exports.chacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
});
/**
 * XChaCha eXtended-nonce ChaCha. 24-byte nonce.
 * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha
 */ exports.xchacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
});
/**
 * Reduced 8-round chacha, described in original paper.
 */ exports.chacha8 = (0, _arx_ts_1.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 4,
    rounds: 8
});
/**
 * Reduced 12-round chacha, described in original paper.
 */ exports.chacha12 = (0, _arx_ts_1.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 4,
    rounds: 12
});
const ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
// Pad to digest size with zeros
const updatePadded = (h, msg)=>{
    h.update(msg);
    const left = msg.length % 16;
    if (left) h.update(ZEROS16.subarray(left));
};
const ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
    const authKey = fn(key, nonce, ZEROS32);
    const h = _poly1305_ts_1.poly1305.create(authKey);
    if (AAD) updatePadded(h, AAD);
    updatePadded(h, data);
    const num = (0, utils_ts_1.u64Lengths)(data.length, AAD ? AAD.length : 0, true);
    h.update(num);
    const res = h.digest();
    (0, utils_ts_1.clean)(authKey, num);
    return res;
}
/**
 * AEAD algorithm from RFC 8439.
 * Salsa20 and chacha (RFC 8439) use poly1305 differently.
 * We could have composed them similar to:
 * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250
 * But it's hard because of authKey:
 * In salsa20, authKey changes position in salsa stream.
 * In chacha, authKey can't be computed inside computeTag, it modifies the counter.
 */ const _poly1305_aead = (xorStream)=>(key, nonce, AAD)=>{
        const tagLength = 16;
        return {
            encrypt (plaintext, output) {
                const plength = plaintext.length;
                output = (0, utils_ts_1.getOutput)(plength + tagLength, output, false);
                output.set(plaintext);
                const oPlain = output.subarray(0, -tagLength);
                xorStream(key, nonce, oPlain, oPlain, 1);
                const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
                output.set(tag, plength); // append tag
                (0, utils_ts_1.clean)(tag);
                return output;
            },
            decrypt (ciphertext, output) {
                output = (0, utils_ts_1.getOutput)(ciphertext.length - tagLength, output, false);
                const data = ciphertext.subarray(0, -tagLength);
                const passedTag = ciphertext.subarray(-tagLength);
                const tag = computeTag(xorStream, key, nonce, data, AAD);
                if (!(0, utils_ts_1.equalBytes)(passedTag, tag)) throw new Error('invalid tag');
                output.set(ciphertext.subarray(0, -tagLength));
                xorStream(key, nonce, output, output, 1); // start stream with i=1
                (0, utils_ts_1.clean)(tag);
                return output;
            }
        };
    };
exports._poly1305_aead = _poly1305_aead;
/**
 * ChaCha20-Poly1305 from RFC 8439.
 *
 * Unsafe to use random nonces under the same key, due to collision chance.
 * Prefer XChaCha instead.
 */ exports.chacha20poly1305 = (0, utils_ts_1.wrapCipher)({
    blockSize: 64,
    nonceLength: 12,
    tagLength: 16
}, (0, exports._poly1305_aead)(exports.chacha20));
/**
 * XChaCha20-Poly1305 extended-nonce chacha.
 *
 * Can be safely used with random nonces (CSPRNG).
 * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).
 */ exports.xchacha20poly1305 = (0, utils_ts_1.wrapCipher)({
    blockSize: 64,
    nonceLength: 24,
    tagLength: 16
}, (0, exports._poly1305_aead)(exports.xchacha20));

},{"9d5797bedbdd6e1f":"eo3v9","4bc7624fcda0dfdf":"7hEiA","93240c83fe2b64be":"k0xcN"}],"eo3v9":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rotl = rotl;
exports.createCipher = createCipher;
/**
 * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.

RFC8439 requires multi-step cipher stream, where
authKey starts with counter: 0, actual msg with counter: 1.

For this, we need a way to re-use nonce / counter:

    const counter = new Uint8Array(4);
    chacha(..., counter, ...); // counter is now 1
    chacha(..., counter, ...); // counter is now 2

This is complicated:

- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB
- Original papers don't allow mutating counters
- Counter overflow is undefined [^1]
- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it
- Caveat: Cannot be re-used through all cases:
- * chacha has (counter | nonce)
- * xchacha has (nonce16 | counter | nonce16)
- Idea B: separate nonce / counter and provide separate API for counter re-use
- Caveat: there are different counter sizes depending on an algorithm.
- salsa & chacha also differ in structures of key & sigma:
  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]
  chacha:       s(4) | k(8) | ctr(1) | nonce(3)
  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)
- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`
- Caveat: we can't re-use counter array

xchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal
(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).

[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/
[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2

 * @module
 */ // prettier-ignore
const utils_ts_1 = require("7e60b3e5ff53101e");
// We can't make top-level var depend on utils.utf8ToBytes
// because it's not present in all envs. Creating a similar fn here
const _utf8ToBytes = (str)=>Uint8Array.from(str.split('').map((c)=>c.charCodeAt(0)));
const sigma16 = _utf8ToBytes('expand 16-byte k');
const sigma32 = _utf8ToBytes('expand 32-byte k');
const sigma16_32 = (0, utils_ts_1.u32)(sigma16);
const sigma32_32 = (0, utils_ts_1.u32)(sigma32);
function rotl(a, b) {
    return a << b | a >>> 32 - b;
}
// Is byte array aligned to 4 byte offset (u32)?
function isAligned32(b) {
    return b.byteOffset % 4 === 0;
}
// Salsa and Chacha block length is always 512-bit
const BLOCK_LEN = 64;
const BLOCK_LEN32 = 16;
// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]
// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]
const MAX_COUNTER = 2 ** 32 - 1;
const U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = (0, utils_ts_1.u32)(block);
    // Make sure that buffers aligned to 4 bytes
    const isAligned = isAligned32(data) && isAligned32(output);
    const d32 = isAligned ? (0, utils_ts_1.u32)(data) : U32_EMPTY;
    const o32 = isAligned ? (0, utils_ts_1.u32)(output) : U32_EMPTY;
    for(let pos = 0; pos < len; counter++){
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');
        const take = Math.min(BLOCK_LEN, len - pos);
        // aligned to 4 bytes
        if (isAligned && take === BLOCK_LEN) {
            const pos32 = pos / 4;
            if (pos % 4 !== 0) throw new Error('arx: invalid block position');
            for(let j = 0, posj; j < BLOCK_LEN32; j++){
                posj = pos32 + j;
                o32[posj] = d32[posj] ^ b32[j];
            }
            pos += BLOCK_LEN;
            continue;
        }
        for(let j = 0, posj; j < take; j++){
            posj = pos + j;
            output[posj] = data[posj] ^ block[j];
        }
        pos += take;
    }
}
/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */ function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_ts_1.checkOpts)({
        allowShortKeys: false,
        counterLength: 8,
        counterRight: false,
        rounds: 20
    }, opts);
    if (typeof core !== 'function') throw new Error('core must be a function');
    (0, utils_ts_1.anumber)(counterLength);
    (0, utils_ts_1.anumber)(rounds);
    (0, utils_ts_1.abool)(counterRight);
    (0, utils_ts_1.abool)(allowShortKeys);
    return (key, nonce, data, output, counter = 0)=>{
        (0, utils_ts_1.abytes)(key);
        (0, utils_ts_1.abytes)(nonce);
        (0, utils_ts_1.abytes)(data);
        const len = data.length;
        if (output === undefined) output = new Uint8Array(len);
        (0, utils_ts_1.abytes)(output);
        (0, utils_ts_1.anumber)(counter);
        if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');
        if (output.length < len) throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean = [];
        // Key & sigma
        // key=16 -> sigma16, k=key|key
        // key=32 -> sigma32, k=key
        let l = key.length;
        let k;
        let sigma;
        if (l === 32) {
            toClean.push(k = (0, utils_ts_1.copyBytes)(key));
            sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
            k = new Uint8Array(32);
            k.set(key);
            k.set(key, 16);
            sigma = sigma16_32;
            toClean.push(k);
        } else throw new Error(`arx: invalid 32-byte key, got length=${l}`);
        // Nonce
        // salsa20:      8   (8-byte counter)
        // chacha20orig: 8   (8-byte counter)
        // chacha20:     12  (4-byte counter)
        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)
        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)
        // Align nonce to 4 bytes
        if (!isAligned32(nonce)) toClean.push(nonce = (0, utils_ts_1.copyBytes)(nonce));
        const k32 = (0, utils_ts_1.u32)(k);
        // hsalsa & hchacha: handle extended nonce
        if (extendNonceFn) {
            if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);
            extendNonceFn(sigma, k32, (0, utils_ts_1.u32)(nonce.subarray(0, 16)), k32);
            nonce = nonce.subarray(16);
        }
        // Handle nonce counter
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length) throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        // Pad counter when nonce is 64 bit
        if (nonceNcLen !== 12) {
            const nc = new Uint8Array(12);
            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
            nonce = nc;
            toClean.push(nonce);
        }
        const n32 = (0, utils_ts_1.u32)(nonce);
        runCipher(core, sigma, k32, n32, data, output, counter, rounds);
        (0, utils_ts_1.clean)(...toClean);
        return output;
    };
}

},{"7e60b3e5ff53101e":"k0xcN"}],"k0xcN":[function(require,module,exports,__globalThis) {
"use strict";
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapCipher = exports.Hash = exports.nextTick = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.abool = abool;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.numberToBytesBE = numberToBytesBE;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.overlapBytes = overlapBytes;
exports.complexOverlapBytes = complexOverlapBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.equalBytes = equalBytes;
exports.getOutput = getOutput;
exports.setBigUint64 = setBigUint64;
exports.u64Lengths = u64Lengths;
exports.isAligned32 = isAligned32;
exports.copyBytes = copyBytes;
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is boolean. */ function abool(b) {
    if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);
}
/** Asserts something is positive integer. */ function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/**
 * Asserts something is hash
 * TODO: remove
 * @deprecated
 */ function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error('digestInto() expects output buffer of length at least ' + min);
}
/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++)arrays[i].fill(0);
}
/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
// Used in micro
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian
}
// Used in ff1
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
// Used in micro, ff1
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
// TODO: remove
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async ()=>{};
exports.nextTick = nextTick;
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'
 */ function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    else if (isBytes(data)) data = copyBytes(data);
    else throw new Error('Uint8Array expected, got ' + typeof data);
    return data;
}
/**
 * Checks if two U8A use same underlying buffer and overlaps.
 * This is invalid and can corrupt data.
 */ function overlapBytes(a, b) {
    return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end
    ;
}
/**
 * If input and output overlap and input starts before output, we will overwrite end of input before
 * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)
 */ function complexOverlapBytes(input, output) {
    // This is very cursed. It works somehow, but I'm completely unsure,
    // reasoning about overlapping aligned windows is very hard.
    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset) throw new Error('complex overlap of input and output is not supported');
}
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** Compares 2 uint8array-s in kinda constant time. */ function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
// TODO: remove
/** For runtime check if class implements interface. */ class Hash {
}
exports.Hash = Hash;
/**
 * Wraps a cipher: validates args, ensures encrypt() can only be called once.
 * @__NO_SIDE_EFFECTS__
 */ const wrapCipher = (params, constructor)=>{
    function wrappedCipher(key, ...args) {
        // Validate key
        abytes(key);
        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:
        if (!exports.isLE) throw new Error('Non little-endian hardware is not yet supported');
        // Validate nonce if nonceLength is present
        if (params.nonceLength !== undefined) {
            const nonce = args[0];
            if (!nonce) throw new Error('nonce / iv required');
            if (params.varSizeNonce) abytes(nonce);
            else abytes(nonce, params.nonceLength);
        }
        // Validate AAD if tagLength present
        const tagl = params.tagLength;
        if (tagl && args[1] !== undefined) abytes(args[1]);
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output)=>{
            if (output !== undefined) {
                if (fnLength !== 2) throw new Error('cipher output not supported');
                abytes(output);
            }
        };
        // Create wrapped cipher with validation and single-use encryption
        let called = false;
        const wrCipher = {
            encrypt (data, output) {
                if (called) throw new Error('cannot encrypt() twice with same key + nonce');
                called = true;
                abytes(data);
                checkOutput(cipher.encrypt.length, output);
                return cipher.encrypt(data, output);
            },
            decrypt (data, output) {
                abytes(data);
                if (tagl && data.length < tagl) throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);
                checkOutput(cipher.decrypt.length, output);
                return cipher.decrypt(data, output);
            }
        };
        return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
};
exports.wrapCipher = wrapCipher;
/**
 * By default, returns u8a of length.
 * When out is available, it checks it for validity and uses it.
 */ function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === undefined) return new Uint8Array(expectedLength);
    if (out.length !== expectedLength) throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);
    if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');
    return out;
}
/** Polyfill for Safari 14. */ function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
function u64Lengths(dataLength, aadLength, isLE) {
    abool(isLE);
    const num = new Uint8Array(16);
    const view = createView(num);
    setBigUint64(view, 0, BigInt(aadLength), isLE);
    setBigUint64(view, 8, BigInt(dataLength), isLE);
    return num;
}
// Is byte array aligned to 4 byte offset (u32)?
function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
}
// copy bytes to new u8a (aligned). Because Buffer.slice is broken.
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}

},{}],"7hEiA":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.poly1305 = void 0;
exports.wrapConstructorWithKey = wrapConstructorWithKey;
/**
 * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),
 * [wiki](https://en.wikipedia.org/wiki/Poly1305))
 * is a fast and parallel secret-key message-authentication code suitable for
 * a wide variety of applications. It was standardized in
 * [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and is now used in TLS 1.3.
 *
 * Polynomial MACs are not perfect for every situation:
 * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.
 * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).
 * To combat invisible salamanders, `hash(key)` can be included in ciphertext,
 * however, this would violate ciphertext indistinguishability:
 * an attacker would know which key was used - so `HKDF(key, i)`
 * could be used instead.
 *
 * Check out [original website](https://cr.yp.to/mac.html).
 * @module
 */ const utils_ts_1 = require("989a64bbfc29f1fc");
// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna
const u8to16 = (a, i)=>a[i++] & 0xff | (a[i++] & 0xff) << 8;
class Poly1305 {
    constructor(key){
        this.blockLen = 16;
        this.outputLen = 16;
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.pos = 0;
        this.finished = false;
        key = (0, utils_ts_1.toBytes)(key);
        (0, utils_ts_1.abytes)(key, 32);
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47
        this.r[0] = t0 & 0x1fff;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this.r[5] = t4 >>> 1 & 0x1ffe;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this.r[9] = t7 >>> 5 & 0x007f;
        for(let i = 0; i < 8; i++)this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
        const hibit = isLast ? 0 : 2048;
        const { h, r } = this;
        const r0 = r[0];
        const r1 = r[1];
        const r2 = r[2];
        const r3 = r[3];
        const r4 = r[4];
        const r5 = r[5];
        const r6 = r[6];
        const r7 = r[7];
        const r8 = r[8];
        const r9 = r[9];
        const t0 = u8to16(data, offset + 0);
        const t1 = u8to16(data, offset + 2);
        const t2 = u8to16(data, offset + 4);
        const t3 = u8to16(data, offset + 6);
        const t4 = u8to16(data, offset + 8);
        const t5 = u8to16(data, offset + 10);
        const t6 = u8to16(data, offset + 12);
        const t7 = u8to16(data, offset + 14);
        let h0 = h[0] + (t0 & 0x1fff);
        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 0x1fff);
        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 0x1fff);
        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 0x1fff);
        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 0x1fff);
        let h5 = h[5] + (t4 >>> 1 & 0x1fff);
        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 0x1fff);
        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 0x1fff);
        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 0x1fff);
        let h9 = h[9] + (t7 >>> 5 | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 0x1fff;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 0x1fff;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 0x1fff;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 0x1fff;
        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 0x1fff;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 0x1fff;
        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 0x1fff;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 0x1fff;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 0x1fff;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 0x1fff;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 0x1fff;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 0x1fff;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        c = d6 >>> 13;
        d6 &= 0x1fff;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 0x1fff;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 0x1fff;
        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 0x1fff;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 0x1fff;
        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 0x1fff;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 0x1fff;
        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 0x1fff;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 0x1fff;
        c = c >>> 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
    }
    finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 0x1fff;
        for(let i = 2; i < 10; i++){
            h[i] += c;
            c = h[i] >>> 13;
            h[i] &= 0x1fff;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 0x1fff;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 0x1fff;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for(let i = 1; i < 10; i++){
            g[i] = h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= 8192;
        let mask = (c ^ 1) - 1;
        for(let i = 0; i < 10; i++)g[i] &= mask;
        mask = ~mask;
        for(let i = 0; i < 10; i++)h[i] = h[i] & mask | g[i];
        h[0] = (h[0] | h[1] << 13) & 0xffff;
        h[1] = (h[1] >>> 3 | h[2] << 10) & 0xffff;
        h[2] = (h[2] >>> 6 | h[3] << 7) & 0xffff;
        h[3] = (h[3] >>> 9 | h[4] << 4) & 0xffff;
        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 0xffff;
        h[5] = (h[6] >>> 2 | h[7] << 11) & 0xffff;
        h[6] = (h[7] >>> 5 | h[8] << 8) & 0xffff;
        h[7] = (h[8] >>> 8 | h[9] << 5) & 0xffff;
        let f = h[0] + pad[0];
        h[0] = f & 0xffff;
        for(let i = 1; i < 8; i++){
            f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
            h[i] = f & 0xffff;
        }
        (0, utils_ts_1.clean)(g);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input
            if (take === blockLen) {
                for(; blockLen <= len - pos; pos += blockLen)this.process(data, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(buffer, 0, false);
                this.pos = 0;
            }
        }
        return this;
    }
    destroy() {
        (0, utils_ts_1.clean)(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
            buffer[pos++] = 1;
            for(; pos < 16; pos++)buffer[pos] = 0;
            this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for(let i = 0; i < 8; i++){
            out[opos++] = h[i] >>> 0;
            out[opos++] = h[i] >>> 8;
        }
        return out;
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
}
function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key)=>hashCons(key).update((0, utils_ts_1.toBytes)(msg)).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key)=>hashCons(key);
    return hashC;
}
/** Poly1305 MAC from RFC 8439. */ exports.poly1305 = wrapConstructorWithKey((key)=>new Poly1305(key));

},{"989a64bbfc29f1fc":"k0xcN"}],"ihmxa":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha2_js_1 = require("346ee77fc212e399");
const utils_js_1 = require("800c6db25c913637");
const curve_ts_1 = require("5da4de0ce8ebfcf3");
const edwards_ts_1 = require("8204d40c15abc71d");
const hash_to_curve_ts_1 = require("59425f280fcf046f");
const modular_ts_1 = require("e20cbf22035770bd");
const montgomery_ts_1 = require("efe43c4320fa6488");
const utils_ts_1 = require("5ecae2b418609955");
// prettier-ignore
const _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
// P = 2n**255n-19n
const ed25519_CURVE_p = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed');
// N = 2n**252n + 27742317777372353535851937790883648493n
// a = Fp.create(BigInt(-1))
// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
const ed25519_CURVE = /* @__PURE__ */ (()=>({
        p: ed25519_CURVE_p,
        n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),
        h: _8n,
        a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),
        d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),
        Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),
        Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658')
    }))();
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE_p;
    const x2 = x * x % P;
    const b2 = x2 * x % P; // x^3, 11
    const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111
    const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P; // x^31
    const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
    const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
    const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
    const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
    const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
    const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
    const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return {
        pow_p_5_8,
        b2
    };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// (-1) aka (a) aka 2^((p-1)/4)
// Fp.sqrt(Fp.neg(1))
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ed25519_CURVE_p;
    const v3 = (0, modular_ts_1.mod)(v * v * v, P); // v
    const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P); // v
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P); // vx
    const root1 = x; // First root candidate
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time
    if ((0, modular_ts_1.isNegativeLE)(x, P)) x = (0, modular_ts_1.mod)(-x, P);
    return {
        isValid: useRoot1 || useRoot2,
        value: x
    };
}
const Fp = /* @__PURE__ */ (()=>(0, modular_ts_1.Field)(ed25519_CURVE.p, {
        isLE: true
    }))();
const Fn = /* @__PURE__ */ (()=>(0, modular_ts_1.Field)(ed25519_CURVE.n, {
        isLE: true
    }))();
const ed25519Defaults = /* @__PURE__ */ (()=>({
        ...ed25519_CURVE,
        Fp,
        hash: sha2_js_1.sha512,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio
    }))();
/**
 * ed25519 curve with EdDSA signatures.
 * @example
 * import { ed25519 } from '@noble/curves/ed25519';
 * const { secretKey, publicKey } = ed25519.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = ed25519.sign(msg, priv);
 * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215
 * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5
 */ exports.ed25519 = (()=>(0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255) throw new Error('Context is too big');
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([
        phflag ? 1 : 0,
        ctx.length
    ]), ctx, data);
}
/** Context of ed25519. Uses context for domain separation. */ exports.ed25519ctx = (()=>(0, edwards_ts_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
    }))();
/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */ exports.ed25519ph = (()=>(0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
        domain: ed25519_domain,
        prehash: sha2_js_1.sha512
    })))();
/**
 * ECDH using curve25519 aka x25519.
 * @example
 * import { x25519 } from '@noble/curves/ed25519';
 * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';
 * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';
 * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases
 * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);
 * x25519.getPublicKey(x25519.utils.randomSecretKey());
 */ exports.x25519 = (()=>{
    const P = Fp.ORDER;
    return (0, montgomery_ts_1.montgomery)({
        P,
        type: 'x25519',
        powPminus2: (x)=>{
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes
    });
})();
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (()=>(ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return {
        xMn: xn,
        xMd: xd,
        yMn: y,
        yMd: _1n
    }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [
        xd,
        yd
    ], true); // batch division
    return {
        x: Fp.mul(xn, xd_inv),
        y: Fp.mul(yn, yd_inv)
    }; //  13. return (xn, xd, yn, yd)
}
/** Hashing to ed25519 points / field. RFC 9380 methods. */ exports.ed25519_hasher = (()=>(0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
        encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
        p: ed25519_CURVE_p,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha2_js_1.sha512
    }))();
// (-1) aka (a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// (ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
// 1 / (a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
// 1-d
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
// (d-1)
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
// Calculates 1/(number)
const invertSqrt = (number)=>uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const bytes255ToNumberLE = (bytes)=>exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
/**
 * Computes Elligator map for Ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
 * the [website](https://ristretto.group/formulas/elligator.html).
 */ function calcElligatorRistrettoMap(r0) {
    const { d } = ed25519_CURVE;
    const P = ed25519_CURVE_p;
    const mod = (n)=>Fp.create(n);
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_ts_1.isNegativeLE)(s_, P)) s_ = mod(-s_);
    if (!Ns_D_is_sq) s = s_; // 7
    if (!Ns_D_is_sq) c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
function ristretto255_map(bytes) {
    (0, utils_js_1.abytes)(bytes, 64);
    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
}
/**
 * Wrapper over Edwards Point for ristretto255.
 *
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */ class _RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
    constructor(ep){
        super(ep);
    }
    static fromAffine(ap) {
        return new _RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
        if (!(other instanceof _RistrettoPoint)) throw new Error('RistrettoPoint expected');
    }
    init(ep) {
        return new _RistrettoPoint(ep);
    }
    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ static hashToCurve(hex) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)('ristrettoHash', hex, 64));
    }
    static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n)=>Fp.create(n);
        const s = bytes255ToNumberLE(bytes);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P)) throw new Error('invalid ristretto255 encoding 1');
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_ts_1.isNegativeLE)(x, P)) x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n) throw new Error('invalid ristretto255 encoding 2');
        return new _RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */ static fromHex(hex) {
        return _RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)('ristrettoHex', hex, 32));
    }
    static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(_RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */ toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod = (n)=>Fp.create(n);
        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1
        const u2 = mod(X * Y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * T); // 6
        let D; // 7
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
            let _x = mod(Y * SQRT_M1);
            let _y = mod(X * SQRT_M1);
            X = _x;
            Y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        } else D = D2; // 8
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P)) Y = mod(-Y); // 9
        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_ts_1.isNegativeLE)(s, P)) s = mod(-s);
        return Fp.toBytes(s); // 11
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */ equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod = (n)=>Fp.create(n);
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    is0() {
        return this.equals(_RistrettoPoint.ZERO);
    }
}
// Do NOT change syntax: the following gymnastics is done,
// because typescript strips comments, which makes bundlers disable tree-shaking.
// prettier-ignore
_RistrettoPoint.BASE = /* @__PURE__ */ (()=>new _RistrettoPoint(exports.ed25519.Point.BASE))();
// prettier-ignore
_RistrettoPoint.ZERO = /* @__PURE__ */ (()=>new _RistrettoPoint(exports.ed25519.Point.ZERO))();
// prettier-ignore
_RistrettoPoint.Fp = /* @__PURE__ */ (()=>Fp)();
// prettier-ignore
_RistrettoPoint.Fn = /* @__PURE__ */ (()=>Fn)();
exports.ristretto255 = {
    Point: _RistrettoPoint
};
/** Hashing to ristretto255 points / field. RFC 9380 methods. */ exports.ristretto255_hasher = {
    hashToCurve (msg, options) {
        const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
    },
    hashToScalar (msg, options = {
        DST: hash_to_curve_ts_1._DST_scalar
    }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
    }
};
// export const ristretto255_oprf: OPRF = createORPF({
//   name: 'ristretto255-SHA512',
//   Point: RistrettoPoint,
//   hash: sha512,
//   hashToGroup: ristretto255_hasher.hashToCurve,
//   hashToScalar: ristretto255_hasher.hashToScalar,
// });
/**
 * Weird / bogus points, useful for debugging.
 * All 8 ed25519 points of 8-torsion subgroup can be generated from the point
 * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.
 * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }
 */ exports.ED25519_TORSION_SUBGROUP = [
    '0100000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
    '0000000000000000000000000000000000000000000000000000000000000080',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
    '0000000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'
];
/** @deprecated use `ed25519.utils.toMontgomery` */ function edwardsToMontgomeryPub(edwardsPub) {
    return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)('pub', edwardsPub));
}
/** @deprecated use `ed25519.utils.toMontgomery` */ exports.edwardsToMontgomery = edwardsToMontgomeryPub;
/** @deprecated use `ed25519.utils.toMontgomerySecret` */ function edwardsToMontgomeryPriv(edwardsPriv) {
    return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)('pub', edwardsPriv));
}
/** @deprecated use `ristretto255.Point` */ exports.RistrettoPoint = _RistrettoPoint;
/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ exports.hashToCurve = (()=>exports.ed25519_hasher.hashToCurve)();
/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ exports.encodeToCurve = (()=>exports.ed25519_hasher.encodeToCurve)();
/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ exports.hashToRistretto255 = (()=>exports.ristretto255_hasher.hashToCurve)();
/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ exports.hash_to_ristretto255 = (()=>exports.ristretto255_hasher.hashToCurve)();

},{"346ee77fc212e399":"5Nc2s","800c6db25c913637":"fuxLy","5da4de0ce8ebfcf3":"gtZZm","8204d40c15abc71d":"COyOX","59425f280fcf046f":"7mgY5","e20cbf22035770bd":"1jGup","efe43c4320fa6488":"4BZtU","5ecae2b418609955":"b5Wru"}],"gtZZm":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wNAF = void 0;
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_ts_1 = require("d81db16f54728391");
const modular_ts_1 = require("72c8f755a25fddc3");
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */ function normalizeZ(c, points) {
    const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p)=>p.Z));
    return points.map((p, i)=>c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return {
        windows,
        windowSize,
        mask,
        maxNumber,
        shiftBy
    };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return {
        nextN,
        offset,
        isZero,
        isNeg,
        isNegF,
        offsetF
    };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points)) throw new Error('array expected');
    points.forEach((p, i)=>{
        if (!(p instanceof c)) throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars)) throw new Error('array of scalars expected');
    scalars.forEach((s, i)=>{
        if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    // To disable precomputes:
    // return 1;
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n) throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Table generation takes **30MB of ram and 10ms on high-end CPU**,
 * but may take much longer on slow devices. Actual generation will happen on
 * first call of `multiply()`. By default, `BASE` point is precomputed.
 *
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */ class wNAF {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits){
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while(n > _0n){
            if (n & _1n) p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for(let window = 0; window < windows; window++){
            base = p;
            points.push(base);
            // i=1, bc we skip 0
            for(let i = 1; i < windowSize; i++){
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */ wNAF(W, precomputes, n) {
        // Scalar should be smaller than field order
        if (!this.Fn.isValid(n)) throw new Error('invalid scalar');
        // Accumulators
        let p = this.ZERO;
        let f = this.BASE;
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        const wo = calcWOpts(W, this.bits);
        for(let window = 0; window < wo.windows; window++){
            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) // bits are 0: add garbage to fake point
            // Important part for const-time getPublicKey: add random "noise" point to f.
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
            else // bits are 1: add to result point
            p = p.add(negateCt(isNeg, precomputes[offset]));
        }
        assert0(n);
        // Return both real and fake points: JIT won't eliminate f.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return {
            p,
            f
        };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for(let window = 0; window < wo.windows; window++){
            if (n === _0n) break; // Early-exit, skip 0 value
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) continue;
            else {
                const item = precomputes[offset];
                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
            }
        }
        assert0(n);
        return acc;
    }
    getPrecomputes(W, point, transform) {
        // Calculate precomputes on a first run, reuse them after
        let comp = pointPrecomputes.get(point);
        if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
                // Doing transform outside of if brings 15% perf hit
                if (typeof transform === 'function') comp = transform(comp);
                pointPrecomputes.set(point, comp);
            }
        }
        return comp;
    }
    cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
    }
    hasCache(elm) {
        return getW(elm) !== 1;
    }
}
exports.wNAF = wNAF;
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */ function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while(k1 > _0n || k2 > _0n){
        if (k1 & _1n) p1 = p1.add(acc);
        if (k2 & _1n) p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return {
        p1,
        p2
    };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka secret keys / bigints)
 */ function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12) windowSize = wbits - 3;
    else if (wbits > 4) windowSize = wbits - 2;
    else if (wbits > 0) windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for(let i = lastBits; i >= 0; i -= windowSize){
        buckets.fill(zero);
        for(let j = 0; j < slength; j++){
            const scalar = scalars[j];
            const wbits = Number(scalar >> BigInt(i) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar  256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255  32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16  255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */ validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p)=>{
        const res = [];
        for(let i = 0, acc = p; i < tableSize; i++){
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars)=>{
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length) throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for(let i = 0; i < chunks; i++){
            // No need to double if accumulator is still zero.
            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for(let j = 0; j < scalars.length; j++){
                const n = scalars[j];
                const curr = Number(n >> shiftBy & MASK);
                if (!curr) continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */ function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field'
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger'
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        p: curve.Fp.ORDER
    });
}
function createField(order, field, isLE) {
    if (field) {
        if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    } else return (0, modular_ts_1.Field)(order, {
        isLE
    });
}
/** Validates CURVE opts and creates fields */ function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === undefined) FpFnLE = type === 'edwards';
    if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);
    for (const p of [
        'p',
        'n',
        'h'
    ]){
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n)) throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = [
        'Gx',
        'Gy',
        'a',
        _b
    ];
    for (const p of params){
        // @ts-ignore
        if (!Fp.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return {
        CURVE,
        Fp,
        Fn
    };
}

},{"d81db16f54728391":"b5Wru","72c8f755a25fddc3":"1jGup"}],"b5Wru":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports._abool2 = _abool2;
exports._abytes2 = _abytes2;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.copyBytes = copyBytes;
exports.asciiToBytes = asciiToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_js_1 = require("6297eb60667427c0");
var utils_js_2 = require("6297eb60667427c0");
Object.defineProperty(exports, "abytes", {
    enumerable: true,
    get: function() {
        return utils_js_2.abytes;
    }
});
Object.defineProperty(exports, "anumber", {
    enumerable: true,
    get: function() {
        return utils_js_2.anumber;
    }
});
Object.defineProperty(exports, "bytesToHex", {
    enumerable: true,
    get: function() {
        return utils_js_2.bytesToHex;
    }
});
Object.defineProperty(exports, "bytesToUtf8", {
    enumerable: true,
    get: function() {
        return utils_js_2.bytesToUtf8;
    }
});
Object.defineProperty(exports, "concatBytes", {
    enumerable: true,
    get: function() {
        return utils_js_2.concatBytes;
    }
});
Object.defineProperty(exports, "hexToBytes", {
    enumerable: true,
    get: function() {
        return utils_js_2.hexToBytes;
    }
});
Object.defineProperty(exports, "isBytes", {
    enumerable: true,
    get: function() {
        return utils_js_2.isBytes;
    }
});
Object.defineProperty(exports, "randomBytes", {
    enumerable: true,
    get: function() {
        return utils_js_2.randomBytes;
    }
});
Object.defineProperty(exports, "utf8ToBytes", {
    enumerable: true,
    get: function() {
        return utils_js_2.utf8ToBytes;
    }
});
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);
}
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */ function _abytes2(value, length, title = '') {
    const bytes = (0, utils_js_1.isBytes)(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || needsLen && len !== length) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') try {
        res = (0, utils_js_1.hexToBytes)(hex);
    } catch (e) {
        throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
    }
    else if ((0, utils_js_1.isBytes)(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
    else throw new Error(title + ' must be hex string or Uint8Array');
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
 * and Buffer#slice creates mutable copy. Never use Buffers!
 */ function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
/**
 * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols
 * Should be safe to use for things expected to be ASCII.
 * Returns exact same result as utf8ToBytes for ASCII or throws.
 */ function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i)=>{
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        return charCode;
    });
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ // export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */ // export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n)=>typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */ function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */ function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
/**
 * Sets single bit at position.
 */ function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len)=>new Uint8Array(len); // creates Uint8Array
    const u8of = (byte)=>Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0))=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === 'bigint',
    function: (val)=>typeof val === 'function',
    boolean: (val)=>typeof val === 'boolean',
    string: (val)=>typeof val === 'string',
    stringOrUint8Array: (val)=>typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === 'function' && Number.isSafeInteger(val.outputLen)
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function') throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object') throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined) return;
        const current = typeof val;
        if (current !== expectedType || val === null) throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v])=>checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v])=>checkField(k, v, true));
}
/**
 * throws not implemented error
 */ const notImplemented = ()=>{
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */ function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args)=>{
        const val = map.get(arg);
        if (val !== undefined) return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}

},{"6297eb60667427c0":"fuxLy"}],"1jGup":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_ts_1 = require("c4eee8297fe5084d");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
// prettier-ignore
const _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */ function invert(number, modulo) {
    if (number === _0n) throw new Error('invert: expected non-zero number');
    if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
}
// Based on RFC9380, Kong algorithm
// prettier-ignore
function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic
    return (Fp, n)=>{
        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4
        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1
        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1
        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1
        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x
        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x
        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x
        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2
        assertIsSquare(Fp, root, n);
        return root;
    };
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < _3n) throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while(Q % _2n === _0n){
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while(FpLegendre(_Fp, Z) === 1){
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1) return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n)) return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while(!Fp.eql(t, Fp.ONE)){
            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while(!Fp.eql(t_tmp, Fp.ONE)){
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M) throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P  3 (mod 4)
 * 2. P  5 (mod 8)
 * 3. P  9 (mod 16)
 * 4. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */ function FpSqrt(P) {
    // P  3 (mod 4) => n = n^((P+1)/4)
    if (P % _4n === _3n) return sqrt3mod4;
    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n) return sqrt5mod8;
    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)
    if (P % _16n === _9n) return sqrt9mod16(P);
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number'
    };
    const opts = FIELD_FIELDS.reduce((map, val)=>{
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ function FpPow(Fp, num, power) {
    if (power < _0n) throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n) return Fp.ONE;
    if (power === _1n) return num;
    let p = Fp.ONE;
    let d = num;
    while(power > _0n){
        if (power & _1n) p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */ function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i)=>{
        if (Fp.is0(num)) return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i)=>{
        if (Fp.is0(num)) return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p)  1    if a is a square (mod p), quadratic residue
 * * (a | p)  -1   if a is not a square (mod p), quadratic non residue
 * * (a | p)  0    if a  0 (mod p)
 */ function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined) (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength
    };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
    if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    let modFromBytes = false;
    let allowedLengths = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS) _nbitLength = _opts.BITS;
        if (_opts.sqrt) _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === 'boolean') modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
    } else {
        if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;
        if (opts.sqrt) _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths: allowedLengths,
        create: (num)=>mod(num, ORDER),
        isValid: (num)=>{
            if (typeof num !== 'bigint') throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num)=>num === _0n,
        // is valid and invertible
        isValidNot0: (num)=>!f.is0(num) && f.isValid(num),
        isOdd: (num)=>(num & _1n) === _1n,
        neg: (num)=>mod(-num, ORDER),
        eql: (lhs, rhs)=>lhs === rhs,
        sqr: (num)=>mod(num * num, ORDER),
        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),
        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),
        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),
        pow: (num, power)=>FpPow(f, num, power),
        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num)=>num * num,
        addN: (lhs, rhs)=>lhs + rhs,
        subN: (lhs, rhs)=>lhs - rhs,
        mulN: (lhs, rhs)=>lhs * rhs,
        inv: (num)=>invert(num, ORDER),
        sqrt: _sqrt || ((n)=>{
            if (!sqrtP) sqrtP = FpSqrt(ORDER);
            return sqrtP(f, n);
        }),
        toBytes: (num)=>isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes, skipValidation = true)=>{
            if (allowedLengths) {
                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);
                const padded = new Uint8Array(BYTES);
                // isLE add 0 to right, !isLE to the left.
                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
                bytes = padded;
            }
            if (bytes.length !== BYTES) throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes) scalar = mod(scalar, ORDER);
            if (!skipValidation) {
                if (!f.isValid(scalar)) throw new Error('invalid field element: outside of range 0..ORDER');
            }
            // NOTE: we don't validate scalar here, please use isValid. This done such way because some
            // protocol may allow non-reduced scalar that reduced later or changed some other way.
            return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst)=>FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c)=>c ? b : a
    });
    return Object.freeze(f);
}
// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?
// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).
// which mean we cannot force this via opts.
// Not sure what to do with randomBytes, we can accept it inside opts if wanted.
// Probably need to export getMinHashLength somewhere?
// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {
//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;
//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?
//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;
//   return reduced;
// },
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}

},{"c4eee8297fe5084d":"b5Wru"}],"COyOX":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrimeEdwardsPoint = void 0;
exports.edwards = edwards;
exports.eddsa = eddsa;
exports.twistedEdwards = twistedEdwards;
/**
 * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.
 * For design rationale of types / exports, see weierstrass module documentation.
 * Untwisted Edwards curves exist, but they aren't used in real-world protocols.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_ts_1 = require("19dcd5a92b1ed59d");
const curve_ts_1 = require("1f0d1b1cd4a4a1c6");
const modular_ts_1 = require("9dc554786fdce90a");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
function isEdValidXY(Fp, CURVE, x, y) {
    const x2 = Fp.sqr(x);
    const y2 = Fp.sqr(y);
    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
    return Fp.eql(left, right);
}
function edwards(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('edwards', params, extraOpts, extraOpts.FpFnLE);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, {
        uvRatio: 'function'
    });
    // Important:
    // There are some places where Fp.BYTES is used instead of nByteLength.
    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.
    // TODO: test and find curves which behave otherwise.
    const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
    const modP = (n)=>Fp.create(n); // Function overrides
    // sqrt(u/v)
    const uvRatio = extraOpts.uvRatio || ((u, v)=>{
        try {
            return {
                isValid: true,
                value: Fp.sqrt(Fp.div(u, v))
            };
        } catch (e) {
            return {
                isValid: false,
                value: _0n
            };
        }
    });
    // Validate whether the passed curve params are valid.
    // equation ax + y = 1 + dxy should work for generator point.
    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');
    /**
     * Asserts coordinate is valid: 0 <= n < MASK.
     * Coordinates >= Fp.ORDER are allowed for zip215.
     */ function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);
        return n;
    }
    function aextpoint(other) {
        if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz)=>{
        const { X, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null) iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0) return {
            x: _0n,
            y: _1n
        };
        if (zz !== _1n) throw new Error('invZ was invalid');
        return {
            x,
            y
        };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p)=>{
        const { a, d } = CURVE;
        if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax + y = 1 + dxy
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY
        const { X, Y, Z, T } = p;
        const X2 = modP(X * X); // X
        const Y2 = modP(Y * Y); // Y
        const Z2 = modP(Z * Z); // Z
        const Z4 = modP(Z2 * Z2); // Z
        const aX2 = modP(X2 * a); // aX
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY
        if (left !== right) throw new Error('bad point: equation left != right (1)');
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT) throw new Error('bad point: equation left != right (2)');
        return true;
    });
    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(X, Y, Z, T){
            this.X = acoord('x', X);
            this.Y = acoord('y', Y);
            this.Z = acoord('z', Z, true);
            this.T = acoord('t', T);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        static fromAffine(p) {
            if (p instanceof Point) throw new Error('extended point not allowed');
            const { x, y } = p || {};
            acoord('x', x);
            acoord('y', y);
            return new Point(x, y, _1n, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
            const len = Fp.BYTES;
            const { a, d } = CURVE;
            bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, 'point'));
            (0, utils_ts_1._abool2)(zip215, 'zip215');
            const normed = (0, utils_ts_1.copyBytes)(bytes); // copy again, we'll manipulate it
            const lastByte = bytes[len - 1]; // select last byte
            normed[len - 1] = lastByte & -129; // clear last bit
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)('point.y', y, _0n, max);
            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:
            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y - 1
            const v = modP(d * y2 - a); // v = d y + 1.
            let { isValid, value: x } = uvRatio(u, v); // (u/v)
            if (!isValid) throw new Error('bad point: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail
            throw new Error('bad point: x=0 and x_0=1');
            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({
                x,
                y
            });
        }
        static fromHex(bytes, zip215 = false) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('point', bytes), zip215);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy) this.multiply(_2n); // random number
            return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            aextpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
            // 1 <= scalar < L
            if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');
            const { p, f } = wnaf.cached(this, scalar, (p)=>(0, curve_ts_1.normalizeZ)(Point, p));
            return (0, curve_ts_1.normalizeZ)(Point, [
                p,
                f
            ])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
            // 0 <= scalar < L
            if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');
            if (scalar === _0n) return Point.ZERO;
            if (this.is0() || scalar === _1n) return this;
            return wnaf.unsafe(this, scalar, (p)=>(0, curve_ts_1.normalizeZ)(Point, p), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
            if (cofactor === _1n) return this;
            return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
            const { x, y } = this.toAffine();
            // Fp.toBytes() allows non-canonical encoding of y (>= p).
            const bytes = Fp.toBytes(y);
            // Each y has 2 valid points: (x, y), (x,-y).
            // When compressing, it's enough to store y and use the last byte to encode sign of x
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;
            return bytes;
        }
        toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
            return this.X;
        }
        get ey() {
            return this.Y;
        }
        get ez() {
            return this.Z;
        }
        get et() {
            return this.T;
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        toRawBytes() {
            return this.toBytes();
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    // zero / infinity / identity point
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
/**
 * Base class for prime-order points like Ristretto255 and Decaf448.
 * These points eliminate cofactor issues by representing equivalence classes
 * of Edwards curve points.
 */ class PrimeEdwardsPoint {
    constructor(ep){
        this.ep = ep;
    }
    // Static methods that must be implemented by subclasses
    static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
    }
    static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
    }
    get x() {
        return this.toAffine().x;
    }
    get y() {
        return this.toAffine().y;
    }
    // Common implementations
    clearCofactor() {
        // no-op for prime-order groups
        return this;
    }
    assertValidity() {
        this.ep.assertValidity();
    }
    toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
    }
    toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
        return this.toHex();
    }
    isTorsionFree() {
        return true;
    }
    isSmallOrder() {
        return false;
    }
    add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
    }
    subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return this.init(this.ep.double());
    }
    negate() {
        return this.init(this.ep.negate());
    }
    precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
    }
    /** @deprecated use `toBytes` */ toRawBytes() {
        return this.toBytes();
    }
}
exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
/**
 * Initializes EdDSA signatures over given Edwards curve.
 */ function eddsa(Point, cHash, eddsaOpts = {}) {
    if (typeof cHash !== 'function') throw new Error('"hash" function param is required');
    (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: 'function',
        randomBytes: 'function',
        domain: 'function',
        prehash: 'function',
        mapToCurve: 'function'
    });
    const { prehash } = eddsaOpts;
    const { BASE, Fp, Fn } = Point;
    const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes)=>bytes);
    const domain = eddsaOpts.domain || ((data, ctx, phflag)=>{
        (0, utils_ts_1._abool2)(phflag, 'phflag');
        if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');
        return data;
    }); // NOOP
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit
    }
    // Get the hashed private scalar per RFC8032 5.1.5
    function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)('private key', key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        return {
            head,
            prefix,
            scalar
        };
    }
    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */ function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toBytes();
        return {
            head,
            prefix,
            scalar,
            point,
            pointBytes
        };
    }
    /** Calculates EdDSA pub key. RFC8032 5.1.5. */ function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        if (prehash) msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = BASE.multiply(r).toBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L
        if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, 'result');
    }
    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
    const verifyOpts = {
        zip215: true
    };
    /**
     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
     * An extended group equation is checked.
     */ function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)('signature', sig, len);
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, lengths.publicKey);
        if (zip215 !== undefined) (0, utils_ts_1._abool2)(zip215, 'zip215');
        if (prehash) msg = prehash(msg); // for ed25519ph, etc
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            A = Point.fromBytes(publicKey, zip215);
            R = Point.fromBytes(r, zip215);
            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside
        } catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // Extended group equation
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().is0();
    }
    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448
    const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size
    };
    function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed');
    }
    function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return {
            secretKey,
            publicKey: getPublicKey(secretKey)
        };
    }
    function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
    }
    function isValidPublicKey(key, zip215) {
        try {
            return !!Point.fromBytes(key, zip215);
        } catch (error) {
            return false;
        }
    }
    const utils = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */ toMontgomery (publicKey) {
            const { y } = Point.fromBytes(publicKey);
            const size = lengths.publicKey;
            const is25519 = size === 32;
            if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');
            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
            return Fp.toBytes(u);
        },
        toMontgomerySecret (secretKey) {
            const size = lengths.secretKey;
            (0, utils_ts_1._abytes2)(secretKey, size);
            const hashed = cHash(secretKey.subarray(0, size));
            return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */ randomPrivateKey: randomSecretKey,
        /** @deprecated */ precompute (windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        }
    };
    return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        utils,
        Point,
        lengths
    });
}
function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = {
        Fp,
        Fn,
        uvRatio: c.uvRatio
    };
    const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve
    };
    return {
        CURVE,
        curveOpts,
        hash: c.hash,
        eddsaOpts
    };
}
function _eddsa_new_output_to_legacy(c, eddsa) {
    const Point = eddsa.Point;
    const legacy = Object.assign({}, eddsa, {
        ExtendedPoint: Point,
        CURVE: c,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES
    });
    return legacy;
}
// TODO: remove. Use eddsa
function twistedEdwards(c) {
    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point, hash, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
}

},{"19dcd5a92b1ed59d":"b5Wru","1f0d1b1cd4a4a1c6":"gtZZm","9dc554786fdce90a":"1jGup"}],"7mgY5":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._DST_scalar = void 0;
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = require("c5a89c7d485abffc");
const modular_ts_1 = require("eccb35e649679ca");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length) throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({
        length
    }).fill(0);
    for(let i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error('number expected');
}
function normDST(DST) {
    if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string') throw new Error('DST must be Uint8Array or string');
    return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */ function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(let i = 1; i <= ell; i++){
        const args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */ function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen
        }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function'
    });
    const { p, k, m, hash, expand, DST } = options;
    if (!(0, utils_ts_1.isHash)(options.hash)) throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    else if (expand === 'xof') prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    else if (expand === '_internal_pass') // for internal tests only
    prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for(let i = 0; i < count; i++){
        const e = new Array(m);
        for(let j = 0; j < m; j++){
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i)=>Array.from(i).reverse());
    return (x, y)=>{
        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [
            xd,
            yd
        ], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return {
            x,
            y
        };
    };
}
exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */ function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve (msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve (msg, options) {
            const optsDst = defaults.encodeDST ? {
                DST: defaults.encodeDST
            } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
        },
        /** See {@link H2CHasher} */ mapToCurve (scalars) {
            if (!Array.isArray(scalars)) throw new Error('expected array of bigints');
            for (const i of scalars)if (typeof i !== 'bigint') throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar (msg, options) {
            // @ts-ignore
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, {
                p: N,
                m: 1,
                DST: exports._DST_scalar
            }, options);
            return hash_to_field(msg, 1, opts)[0][0];
        }
    };
}

},{"c5a89c7d485abffc":"b5Wru","eccb35e649679ca":"1jGup"}],"4BZtU":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.montgomery = montgomery;
/**
 * Montgomery curve methods. It's not really whole montgomery curve,
 * just bunch of very specific methods for X25519 / X448 from
 * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_ts_1 = require("167d1de839f90fb4");
const modular_ts_1 = require("d01b1f463cd5a2a7");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function validateOpts(curve) {
    (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: 'function',
        powPminus2: 'function'
    });
    return Object.freeze({
        ...curve
    });
}
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type === 'x25519';
    if (!is25519 && type !== 'x448') throw new Error('invalid type');
    const randomBytes_ = rand || utils_ts_1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    // RFC 7748 #5:
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and
    // (156326 - 2) / 4 = 39081 for curve448/X448
    // const a = is25519 ? 156326n : 486662n;
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    // RFC: x25519 "the resulting integer is of the form 2^254 plus
    // eight times a value between 0 and 2^251 - 1 (inclusive)"
    // x448: "2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)"
    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
    const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)
    const modP = (n)=>(0, modular_ts_1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
    }
    function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);
        // RFC: When receiving such an array, implementations of X25519
        // (but not X448) MUST mask the most significant bit in the final byte.
        if (is25519) _u[31] &= 127; // 0b0111_1111
        // RFC: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.  The non-canonical
        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224
        // - 1 through 2^448 - 1 for X448.
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        // Some public keys are useless, of low-order. Curve author doesn't think
        // it needs to be validated, but we do it nonetheless.
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n) throw new Error('invalid private or public key received');
        return encodeU(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    // cswap from RFC7748 "example code"
    function cswap(swap, x_2, x_3) {
        // dummy = mask(swap) AND (x_2 XOR x_3)
        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2
        // and x_3, computed, e.g., as mask(swap) = 0 - swap.
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy
        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy
        return {
            x_2,
            x_3
        };
    }
    /**
     * Montgomery x-only multiplication ladder.
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */ function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)('u', u, _0n, P);
        (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){
            const k_t = k >> t & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent
        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))
    }
    const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen
    };
    const randomSecretKey = (seed = randomBytes_(fieldLen))=>{
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
    };
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return {
            secretKey,
            publicKey: scalarMultBase(secretKey)
        };
    }
    const utils = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey
    };
    return {
        keygen,
        getSharedSecret: (secretKey, publicKey)=>scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey)=>scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils,
        GuBytes: GuBytes.slice(),
        lengths
    };
}

},{"167d1de839f90fb4":"b5Wru","d01b1f463cd5a2a7":"1jGup"}],"ccEv4":[function(require,module,exports,__globalThis) {
/*!
 * hash-wasm (https://www.npmjs.com/package/hash-wasm)
 * (c) Dani Biro
 * @license MIT
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "adler32", ()=>adler32);
parcelHelpers.export(exports, "argon2Verify", ()=>argon2Verify);
parcelHelpers.export(exports, "argon2d", ()=>argon2d);
parcelHelpers.export(exports, "argon2i", ()=>argon2i);
parcelHelpers.export(exports, "argon2id", ()=>argon2id);
parcelHelpers.export(exports, "bcrypt", ()=>bcrypt);
parcelHelpers.export(exports, "bcryptVerify", ()=>bcryptVerify);
parcelHelpers.export(exports, "blake2b", ()=>blake2b);
parcelHelpers.export(exports, "blake2s", ()=>blake2s);
parcelHelpers.export(exports, "blake3", ()=>blake3);
parcelHelpers.export(exports, "crc32", ()=>crc32);
parcelHelpers.export(exports, "crc64", ()=>crc64);
parcelHelpers.export(exports, "createAdler32", ()=>createAdler32);
parcelHelpers.export(exports, "createBLAKE2b", ()=>createBLAKE2b);
parcelHelpers.export(exports, "createBLAKE2s", ()=>createBLAKE2s);
parcelHelpers.export(exports, "createBLAKE3", ()=>createBLAKE3);
parcelHelpers.export(exports, "createCRC32", ()=>createCRC32);
parcelHelpers.export(exports, "createCRC64", ()=>createCRC64);
parcelHelpers.export(exports, "createHMAC", ()=>createHMAC);
parcelHelpers.export(exports, "createKeccak", ()=>createKeccak);
parcelHelpers.export(exports, "createMD4", ()=>createMD4);
parcelHelpers.export(exports, "createMD5", ()=>createMD5);
parcelHelpers.export(exports, "createRIPEMD160", ()=>createRIPEMD160);
parcelHelpers.export(exports, "createSHA1", ()=>createSHA1);
parcelHelpers.export(exports, "createSHA224", ()=>createSHA224);
parcelHelpers.export(exports, "createSHA256", ()=>createSHA256);
parcelHelpers.export(exports, "createSHA3", ()=>createSHA3);
parcelHelpers.export(exports, "createSHA384", ()=>createSHA384);
parcelHelpers.export(exports, "createSHA512", ()=>createSHA512);
parcelHelpers.export(exports, "createSM3", ()=>createSM3);
parcelHelpers.export(exports, "createWhirlpool", ()=>createWhirlpool);
parcelHelpers.export(exports, "createXXHash128", ()=>createXXHash128);
parcelHelpers.export(exports, "createXXHash3", ()=>createXXHash3);
parcelHelpers.export(exports, "createXXHash32", ()=>createXXHash32);
parcelHelpers.export(exports, "createXXHash64", ()=>createXXHash64);
parcelHelpers.export(exports, "keccak", ()=>keccak);
parcelHelpers.export(exports, "md4", ()=>md4);
parcelHelpers.export(exports, "md5", ()=>md5);
parcelHelpers.export(exports, "pbkdf2", ()=>pbkdf2);
parcelHelpers.export(exports, "ripemd160", ()=>ripemd160);
parcelHelpers.export(exports, "scrypt", ()=>scrypt);
parcelHelpers.export(exports, "sha1", ()=>sha1);
parcelHelpers.export(exports, "sha224", ()=>sha224);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha3", ()=>sha3);
parcelHelpers.export(exports, "sha384", ()=>sha384);
parcelHelpers.export(exports, "sha512", ()=>sha512);
parcelHelpers.export(exports, "sm3", ()=>sm3);
parcelHelpers.export(exports, "whirlpool", ()=>whirlpool);
parcelHelpers.export(exports, "xxhash128", ()=>xxhash128);
parcelHelpers.export(exports, "xxhash3", ()=>xxhash3);
parcelHelpers.export(exports, "xxhash32", ()=>xxhash32);
parcelHelpers.export(exports, "xxhash64", ()=>xxhash64);
var global = arguments[3];
var name$l = "adler32";
var data$l = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAgUEAQECAgYOAn8BQYCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEK6wkGBQBBgAkLCgBBAEEBNgKECAvjCAEHf0EAKAKECCIBQf//A3EhAiABQRB2IQMCQAJAIABBAUcNACACQQAtAIAJaiIBQY+AfGogASABQfD/A0sbIgEgA2oiBEEQdCIFQYCAPGogBSAEQfD/A0sbIAFyIQEMAQsCQAJAAkACQAJAIABBEEkNAEGACSEGIABBsCtJDQFBgAkhBgNAQQAhBQNAIAYgBWoiASgCACIEQf8BcSACaiICIANqIAIgBEEIdkH/AXFqIgJqIAIgBEEQdkH/AXFqIgJqIAIgBEEYdmoiAmogAiABQQRqKAIAIgRB/wFxaiICaiACIARBCHZB/wFxaiICaiACIARBEHZB/wFxaiICaiACIARBGHZqIgJqIAIgAUEIaigCACIEQf8BcWoiAmogAiAEQQh2Qf8BcWoiAmogAiAEQRB2Qf8BcWoiAmogAiAEQRh2aiIEaiAEIAFBDGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiAmohAyAFQRBqIgVBsCtHDQALIANB8f8DcCEDIAJB8f8DcCECIAZBsCtqIQYgAEHQVGoiAEGvK0sNAAsgAEUNBCAAQQ9LDQEMAgsCQCAARQ0AAkACQCAAQQNxIgUNAEGACSEBIAAhBAwBCyAAQXxxIQRBACEBA0AgAiABQYAJai0AAGoiAiADaiEDIAUgAUEBaiIBRw0ACyAFQYAJaiEBCyAAQQRJDQADQCACIAEtAABqIgUgAS0AAWoiBiABLQACaiIAIAFBA2otAABqIgIgACAGIAUgA2pqamohAyABQQRqIQEgBEF8aiIEDQALCyACQY+AfGogAiACQfD/A0sbIANB8f8DcEEQdHIhAQwECwNAIAYoAgAiAUH/AXEgAmoiBCADaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgRqIAQgBkEEaigCACIBQf8BcWoiBGogBCABQQh2Qf8BcWoiBGogBCABQRB2Qf8BcWoiBGogBCABQRh2aiIEaiAEIAZBCGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiBGogBCAGQQxqKAIAIgFB/wFxaiIEaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgJqIQMgBkEQaiEGIABBcGoiAEEPSw0ACyAARQ0BCyAAQX9qIQcCQCAAQQNxIgVFDQAgAEF8cSEAIAUhBCAGIQEDQCACIAEtAABqIgIgA2ohAyABQQFqIQEgBEF/aiIEDQALIAYgBWohBgsgB0EDSQ0AA0AgAiAGLQAAaiIBIAYtAAFqIgQgBi0AAmoiBSAGQQNqLQAAaiICIAUgBCABIANqampqIQMgBkEEaiEGIABBfGoiAA0ACwsgA0Hx/wNwIQMgAkHx/wNwIQILIAIgA0EQdHIhAQtBACABNgKECAsxAQF/QQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwUAQYQICzsAQQBBATYChAggABACQQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwsVAgBBgAgLBAQAAAAAQYQICwQBAAAA";
var hash$l = "02ddbd17";
var wasmJson$l = {
    name: name$l,
    data: data$l,
    hash: hash$l
};
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
typeof SuppressedError === "function" && SuppressedError;
class Mutex {
    constructor(){
        this.mutex = Promise.resolve();
    }
    lock() {
        let begin = ()=>{};
        this.mutex = this.mutex.then(()=>new Promise(begin));
        return new Promise((res)=>{
            begin = res;
        });
    }
    dispatch(fn) {
        return __awaiter(this, void 0, void 0, function*() {
            const unlock = yield this.lock();
            try {
                return yield Promise.resolve(fn());
            } finally{
                unlock();
            }
        });
    }
}
var _a;
function getGlobal() {
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    return global;
}
const globalObject = getGlobal();
const nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
const textEncoder = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
function intArrayToString(arr, len) {
    return String.fromCharCode(...arr.subarray(0, len));
}
function hexCharCodesToInt(a, b) {
    return (a & 0xf) + (a >> 6 | a >> 3 & 0x8) << 4 | (b & 0xf) + (b >> 6 | b >> 3 & 0x8);
}
function writeHexToUInt8(buf, str) {
    const size = str.length >> 1;
    for(let i = 0; i < size; i++){
        const index = i << 1;
        buf[i] = hexCharCodesToInt(str.charCodeAt(index), str.charCodeAt(index + 1));
    }
}
function hexStringEqualsUInt8(str, buf) {
    if (str.length !== buf.length * 2) return false;
    for(let i = 0; i < buf.length; i++){
        const strIndex = i << 1;
        if (buf[i] !== hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) return false;
    }
    return true;
}
const alpha = "a".charCodeAt(0) - 10;
const digit = "0".charCodeAt(0);
function getDigestHex(tmpBuffer, input, hashLength) {
    let p = 0;
    for(let i = 0; i < hashLength; i++){
        let nibble = input[i] >>> 4;
        tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
        nibble = input[i] & 0xf;
        tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
    }
    return String.fromCharCode.apply(null, tmpBuffer);
}
const getUInt8Buffer = nodeBuffer !== null ? (data)=>{
    if (typeof data === "string") {
        const buf = nodeBuffer.from(data, "utf8");
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
    }
    if (nodeBuffer.isBuffer(data)) return new Uint8Array(data.buffer, data.byteOffset, data.length);
    if (ArrayBuffer.isView(data)) return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    throw new Error("Invalid data type!");
} : (data)=>{
    if (typeof data === "string") return textEncoder.encode(data);
    if (ArrayBuffer.isView(data)) return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    throw new Error("Invalid data type!");
};
const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const base64Lookup = new Uint8Array(256);
for(let i = 0; i < base64Chars.length; i++)base64Lookup[base64Chars.charCodeAt(i)] = i;
function encodeBase64(data, pad = true) {
    const len = data.length;
    const extraBytes = len % 3;
    const parts = [];
    const len2 = len - extraBytes;
    for(let i = 0; i < len2; i += 3){
        const tmp = (data[i] << 16 & 0xff0000) + (data[i + 1] << 8 & 0xff00) + (data[i + 2] & 0xff);
        const triplet = base64Chars.charAt(tmp >> 18 & 0x3f) + base64Chars.charAt(tmp >> 12 & 0x3f) + base64Chars.charAt(tmp >> 6 & 0x3f) + base64Chars.charAt(tmp & 0x3f);
        parts.push(triplet);
    }
    if (extraBytes === 1) {
        const tmp = data[len - 1];
        const a = base64Chars.charAt(tmp >> 2);
        const b = base64Chars.charAt(tmp << 4 & 0x3f);
        parts.push(`${a}${b}`);
        if (pad) parts.push("==");
    } else if (extraBytes === 2) {
        const tmp = (data[len - 2] << 8) + data[len - 1];
        const a = base64Chars.charAt(tmp >> 10);
        const b = base64Chars.charAt(tmp >> 4 & 0x3f);
        const c = base64Chars.charAt(tmp << 2 & 0x3f);
        parts.push(`${a}${b}${c}`);
        if (pad) parts.push("=");
    }
    return parts.join("");
}
function getDecodeBase64Length(data) {
    let bufferLength = Math.floor(data.length * 0.75);
    const len = data.length;
    if (data[len - 1] === "=") {
        bufferLength -= 1;
        if (data[len - 2] === "=") bufferLength -= 1;
    }
    return bufferLength;
}
function decodeBase64(data) {
    const bufferLength = getDecodeBase64Length(data);
    const len = data.length;
    const bytes = new Uint8Array(bufferLength);
    let p = 0;
    for(let i = 0; i < len; i += 4){
        const encoded1 = base64Lookup[data.charCodeAt(i)];
        const encoded2 = base64Lookup[data.charCodeAt(i + 1)];
        const encoded3 = base64Lookup[data.charCodeAt(i + 2)];
        const encoded4 = base64Lookup[data.charCodeAt(i + 3)];
        bytes[p] = encoded1 << 2 | encoded2 >> 4;
        p += 1;
        bytes[p] = (encoded2 & 15) << 4 | encoded3 >> 2;
        p += 1;
        bytes[p] = (encoded3 & 3) << 6 | encoded4 & 63;
        p += 1;
    }
    return bytes;
}
const MAX_HEAP = 16384;
const WASM_FUNC_HASH_LENGTH = 4;
const wasmMutex = new Mutex();
const wasmModuleCache = new Map();
function WASMInterface(binary, hashLength) {
    return __awaiter(this, void 0, void 0, function*() {
        let wasmInstance = null;
        let memoryView = null;
        let initialized = false;
        if (typeof WebAssembly === "undefined") throw new Error("WebAssembly is not supported in this environment!");
        const writeMemory = (data, offset = 0)=>{
            memoryView.set(data, offset);
        };
        const getMemory = ()=>memoryView;
        const getExports = ()=>wasmInstance.exports;
        const setMemorySize = (totalSize)=>{
            wasmInstance.exports.Hash_SetMemorySize(totalSize);
            const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
            const memoryBuffer = wasmInstance.exports.memory.buffer;
            memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
        };
        const getStateSize = ()=>{
            const view = new DataView(wasmInstance.exports.memory.buffer);
            const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
            return stateSize;
        };
        const loadWASMPromise = wasmMutex.dispatch(()=>__awaiter(this, void 0, void 0, function*() {
                if (!wasmModuleCache.has(binary.name)) {
                    const asm = decodeBase64(binary.data);
                    const promise = WebAssembly.compile(asm);
                    wasmModuleCache.set(binary.name, promise);
                }
                const module = yield wasmModuleCache.get(binary.name);
                wasmInstance = yield WebAssembly.instantiate(module, {
                });
            // wasmInstance.exports._start();
            }));
        const setupInterface = ()=>__awaiter(this, void 0, void 0, function*() {
                if (!wasmInstance) yield loadWASMPromise;
                const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
                const memoryBuffer = wasmInstance.exports.memory.buffer;
                memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
            });
        const init = (bits = null)=>{
            initialized = true;
            wasmInstance.exports.Hash_Init(bits);
        };
        const updateUInt8Array = (data)=>{
            let read = 0;
            while(read < data.length){
                const chunk = data.subarray(read, read + MAX_HEAP);
                read += chunk.length;
                memoryView.set(chunk);
                wasmInstance.exports.Hash_Update(chunk.length);
            }
        };
        const update = (data)=>{
            if (!initialized) throw new Error("update() called before init()");
            const Uint8Buffer = getUInt8Buffer(data);
            updateUInt8Array(Uint8Buffer);
        };
        const digestChars = new Uint8Array(hashLength * 2);
        const digest = (outputType, padding = null)=>{
            if (!initialized) throw new Error("digest() called before init()");
            initialized = false;
            wasmInstance.exports.Hash_Final(padding);
            if (outputType === "binary") // the data is copied to allow GC of the original memory object
            return memoryView.slice(0, hashLength);
            return getDigestHex(digestChars, memoryView, hashLength);
        };
        const save = ()=>{
            if (!initialized) throw new Error("save() can only be called after init() and before digest()");
            const stateOffset = wasmInstance.exports.Hash_GetState();
            const stateLength = getStateSize();
            const memoryBuffer = wasmInstance.exports.memory.buffer;
            const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
            // prefix is 4 bytes from SHA1 hash of the WASM binary
            // it is used to detect incompatible internal states between different versions of hash-wasm
            const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
            writeHexToUInt8(prefixedState, binary.hash);
            prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
            return prefixedState;
        };
        const load = (state)=>{
            if (!(state instanceof Uint8Array)) throw new Error("load() expects an Uint8Array generated by save()");
            const stateOffset = wasmInstance.exports.Hash_GetState();
            const stateLength = getStateSize();
            const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
            const memoryBuffer = wasmInstance.exports.memory.buffer;
            if (state.length !== overallLength) throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
            if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) throw new Error("This state was written by an incompatible hash implementation");
            const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
            new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
            initialized = true;
        };
        const isDataShort = (data)=>{
            if (typeof data === "string") // worst case is 4 bytes / char
            return data.length < MAX_HEAP / 4;
            return data.byteLength < MAX_HEAP;
        };
        let canSimplify = isDataShort;
        switch(binary.name){
            case "argon2":
            case "scrypt":
                canSimplify = ()=>true;
                break;
            case "blake2b":
            case "blake2s":
                // if there is a key at blake2 then cannot simplify
                canSimplify = (data, initParam)=>initParam <= 512 && isDataShort(data);
                break;
            case "blake3":
                // if there is a key at blake3 then cannot simplify
                canSimplify = (data, initParam)=>initParam === 0 && isDataShort(data);
                break;
            case "xxhash64":
            case "xxhash3":
            case "xxhash128":
            case "crc64":
                canSimplify = ()=>false;
                break;
        }
        // shorthand for (init + update + digest) for better performance
        const calculate = (data, initParam = null, digestParam = null)=>{
            if (!canSimplify(data, initParam)) {
                init(initParam);
                update(data);
                return digest("hex", digestParam);
            }
            const buffer = getUInt8Buffer(data);
            memoryView.set(buffer);
            wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
            return getDigestHex(digestChars, memoryView, hashLength);
        };
        yield setupInterface();
        return {
            getMemory,
            writeMemory,
            getExports,
            setMemorySize,
            init,
            update,
            digest,
            save,
            load,
            calculate,
            hashLength
        };
    });
}
function lockedCreate(mutex, binary, hashLength) {
    return __awaiter(this, void 0, void 0, function*() {
        const unlock = yield mutex.lock();
        const wasm = yield WASMInterface(binary, hashLength);
        unlock();
        return wasm;
    });
}
const mutex$l = new Mutex();
let wasmCache$l = null;
/**
 * Calculates Adler-32 hash. The resulting 32-bit hash is stored in
 * network byte order (big-endian).
 *
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function adler32(data) {
    if (wasmCache$l === null) return lockedCreate(mutex$l, wasmJson$l, 4).then((wasm)=>{
        wasmCache$l = wasm;
        return wasmCache$l.calculate(data);
    });
    try {
        const hash = wasmCache$l.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new Adler-32 hash instance
 */ function createAdler32() {
    return WASMInterface(wasmJson$l, 4).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 4,
            digestSize: 4
        };
        return obj;
    });
}
var name$k = "argon2";
var data$k = "AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvEyBVgBAn9BACEBAkAgAEEAKAKICCICRg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkD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";
var hash$k = "e4cdc523";
var wasmJson$k = {
    name: name$k,
    data: data$k,
    hash: hash$k
};
var name$j = "blake2b";
var data$j = "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";
var hash$j = "c6f286e6";
var wasmJson$j = {
    name: name$j,
    data: data$j,
    hash: hash$j
};
const mutex$k = new Mutex();
let wasmCache$k = null;
function validateBits$4(bits) {
    if (!Number.isInteger(bits) || bits < 8 || bits > 512 || bits % 8 !== 0) return new Error("Invalid variant! Valid values: 8, 16, ..., 512");
    return null;
}
function getInitParam$1(outputBits, keyBits) {
    return outputBits | keyBits << 16;
}
/**
 * Calculates BLAKE2b hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param bits Number of output bits, which has to be a number
 *             divisible by 8, between 8 and 512. Defaults to 512.
 * @param key Optional key (string, Buffer or TypedArray). Maximum length is 64 bytes.
 * @returns Computed hash as a hexadecimal string
 */ function blake2b(data, bits = 512, key = null) {
    if (validateBits$4(bits)) return Promise.reject(validateBits$4(bits));
    let keyBuffer = null;
    let initParam = bits;
    if (key !== null) {
        keyBuffer = getUInt8Buffer(key);
        if (keyBuffer.length > 64) return Promise.reject(new Error("Max key length is 64 bytes"));
        initParam = getInitParam$1(bits, keyBuffer.length);
    }
    const hashLength = bits / 8;
    if (wasmCache$k === null || wasmCache$k.hashLength !== hashLength) return lockedCreate(mutex$k, wasmJson$j, hashLength).then((wasm)=>{
        wasmCache$k = wasm;
        if (initParam > 512) wasmCache$k.writeMemory(keyBuffer);
        return wasmCache$k.calculate(data, initParam);
    });
    try {
        if (initParam > 512) wasmCache$k.writeMemory(keyBuffer);
        const hash = wasmCache$k.calculate(data, initParam);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new BLAKE2b hash instance
 * @param bits Number of output bits, which has to be a number
 *             divisible by 8, between 8 and 512. Defaults to 512.
 * @param key Optional key (string, Buffer or TypedArray). Maximum length is 64 bytes.
 */ function createBLAKE2b(bits = 512, key = null) {
    if (validateBits$4(bits)) return Promise.reject(validateBits$4(bits));
    let keyBuffer = null;
    let initParam = bits;
    if (key !== null) {
        keyBuffer = getUInt8Buffer(key);
        if (keyBuffer.length > 64) return Promise.reject(new Error("Max key length is 64 bytes"));
        initParam = getInitParam$1(bits, keyBuffer.length);
    }
    const outputSize = bits / 8;
    return WASMInterface(wasmJson$j, outputSize).then((wasm)=>{
        if (initParam > 512) wasm.writeMemory(keyBuffer);
        wasm.init(initParam);
        const obj = {
            init: initParam > 512 ? ()=>{
                wasm.writeMemory(keyBuffer);
                wasm.init(initParam);
                return obj;
            } : ()=>{
                wasm.init(initParam);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 128,
            digestSize: outputSize
        };
        return obj;
    });
}
function encodeResult(salt, options, res) {
    const parameters = [
        `m=${options.memorySize}`,
        `t=${options.iterations}`,
        `p=${options.parallelism}`
    ].join(",");
    return `$argon2${options.hashType}$v=19$${parameters}$${encodeBase64(salt, false)}$${encodeBase64(res, false)}`;
}
const uint32View = new DataView(new ArrayBuffer(4));
function int32LE(x) {
    uint32View.setInt32(0, x, true);
    return new Uint8Array(uint32View.buffer);
}
function hashFunc(blake512, buf, len) {
    return __awaiter(this, void 0, void 0, function*() {
        if (len <= 64) {
            const blake = yield createBLAKE2b(len * 8);
            blake.update(int32LE(len));
            blake.update(buf);
            return blake.digest("binary");
        }
        const r = Math.ceil(len / 32) - 2;
        const ret = new Uint8Array(len);
        blake512.init();
        blake512.update(int32LE(len));
        blake512.update(buf);
        let vp = blake512.digest("binary");
        ret.set(vp.subarray(0, 32), 0);
        for(let i = 1; i < r; i++){
            blake512.init();
            blake512.update(vp);
            vp = blake512.digest("binary");
            ret.set(vp.subarray(0, 32), i * 32);
        }
        const partialBytesNeeded = len - 32 * r;
        let blakeSmall;
        if (partialBytesNeeded === 64) {
            blakeSmall = blake512;
            blakeSmall.init();
        } else blakeSmall = yield createBLAKE2b(partialBytesNeeded * 8);
        blakeSmall.update(vp);
        vp = blakeSmall.digest("binary");
        ret.set(vp.subarray(0, partialBytesNeeded), r * 32);
        return ret;
    });
}
function getHashType(type) {
    switch(type){
        case "d":
            return 0;
        case "i":
            return 1;
        default:
            return 2;
    }
}
function argon2Internal(options) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a;
        const { parallelism, iterations, hashLength } = options;
        const password = getUInt8Buffer(options.password);
        const salt = getUInt8Buffer(options.salt);
        const version = 0x13;
        const hashType = getHashType(options.hashType);
        const { memorySize } = options; // in KB
        const secret = getUInt8Buffer((_a = options.secret) !== null && _a !== void 0 ? _a : "");
        const [argon2Interface, blake512] = yield Promise.all([
            WASMInterface(wasmJson$k, 1024),
            createBLAKE2b(512)
        ]);
        // last block is for storing the init vector
        argon2Interface.setMemorySize(memorySize * 1024 + 1024);
        const initVector = new Uint8Array(24);
        const initVectorView = new DataView(initVector.buffer);
        initVectorView.setInt32(0, parallelism, true);
        initVectorView.setInt32(4, hashLength, true);
        initVectorView.setInt32(8, memorySize, true);
        initVectorView.setInt32(12, iterations, true);
        initVectorView.setInt32(16, version, true);
        initVectorView.setInt32(20, hashType, true);
        argon2Interface.writeMemory(initVector, memorySize * 1024);
        blake512.init();
        blake512.update(initVector);
        blake512.update(int32LE(password.length));
        blake512.update(password);
        blake512.update(int32LE(salt.length));
        blake512.update(salt);
        blake512.update(int32LE(secret.length));
        blake512.update(secret);
        blake512.update(int32LE(0)); // associatedData length + associatedData
        const segments = Math.floor(memorySize / (parallelism * 4)); // length of each lane
        const lanes = segments * 4;
        const param = new Uint8Array(72);
        const H0 = blake512.digest("binary");
        param.set(H0);
        for(let lane = 0; lane < parallelism; lane++){
            param.set(int32LE(0), 64);
            param.set(int32LE(lane), 68);
            let position = lane * lanes;
            let chunk = yield hashFunc(blake512, param, 1024);
            argon2Interface.writeMemory(chunk, position * 1024);
            position += 1;
            param.set(int32LE(1), 64);
            chunk = yield hashFunc(blake512, param, 1024);
            argon2Interface.writeMemory(chunk, position * 1024);
        }
        const C = new Uint8Array(1024);
        writeHexToUInt8(C, argon2Interface.calculate(new Uint8Array([]), memorySize));
        const res = yield hashFunc(blake512, C, hashLength);
        if (options.outputType === "hex") {
            const digestChars = new Uint8Array(hashLength * 2);
            return getDigestHex(digestChars, res, hashLength);
        }
        if (options.outputType === "encoded") return encodeResult(salt, options, res);
        // return binary format
        return res;
    });
}
const validateOptions$3 = (options)=>{
    var _a;
    if (!options || typeof options !== "object") throw new Error("Invalid options parameter. It requires an object.");
    if (!options.password) throw new Error("Password must be specified");
    options.password = getUInt8Buffer(options.password);
    if (options.password.length < 1) throw new Error("Password must be specified");
    if (!options.salt) throw new Error("Salt must be specified");
    options.salt = getUInt8Buffer(options.salt);
    if (options.salt.length < 8) throw new Error("Salt should be at least 8 bytes long");
    options.secret = getUInt8Buffer((_a = options.secret) !== null && _a !== void 0 ? _a : "");
    if (!Number.isInteger(options.iterations) || options.iterations < 1) throw new Error("Iterations should be a positive number");
    if (!Number.isInteger(options.parallelism) || options.parallelism < 1) throw new Error("Parallelism should be a positive number");
    if (!Number.isInteger(options.hashLength) || options.hashLength < 4) throw new Error("Hash length should be at least 4 bytes.");
    if (!Number.isInteger(options.memorySize)) throw new Error("Memory size should be specified.");
    if (options.memorySize < 8 * options.parallelism) throw new Error("Memory size should be at least 8 * parallelism.");
    if (options.outputType === undefined) options.outputType = "hex";
    if (![
        "hex",
        "binary",
        "encoded"
    ].includes(options.outputType)) throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
};
/**
 * Calculates hash using the argon2i password-hashing function
 * @returns Computed hash
 */ function argon2i(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateOptions$3(options);
        return argon2Internal(Object.assign(Object.assign({}, options), {
            hashType: "i"
        }));
    });
}
/**
 * Calculates hash using the argon2id password-hashing function
 * @returns Computed hash
 */ function argon2id(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateOptions$3(options);
        return argon2Internal(Object.assign(Object.assign({}, options), {
            hashType: "id"
        }));
    });
}
/**
 * Calculates hash using the argon2d password-hashing function
 * @returns Computed hash
 */ function argon2d(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateOptions$3(options);
        return argon2Internal(Object.assign(Object.assign({}, options), {
            hashType: "d"
        }));
    });
}
const getHashParameters = (password, encoded, secret)=>{
    const regex = /^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/;
    const match = encoded.match(regex);
    if (!match) throw new Error("Invalid hash");
    const [, hashType, version, parameters, salt, hash] = match;
    if (version !== "19") throw new Error(`Unsupported version: ${version}`);
    const parsedParameters = {};
    const paramMap = {
        m: "memorySize",
        p: "parallelism",
        t: "iterations"
    };
    for (const x of parameters.split(",")){
        const [n, v] = x.split("=");
        parsedParameters[paramMap[n]] = Number(v);
    }
    return Object.assign(Object.assign({}, parsedParameters), {
        password,
        secret,
        hashType: hashType,
        salt: decodeBase64(salt),
        hashLength: getDecodeBase64Length(hash),
        outputType: "encoded"
    });
};
const validateVerifyOptions$1 = (options)=>{
    if (!options || typeof options !== "object") throw new Error("Invalid options parameter. It requires an object.");
    if (options.hash === undefined || typeof options.hash !== "string") throw new Error("Hash should be specified");
};
/**
 * Verifies password using the argon2 password-hashing function
 * @returns True if the encoded hash matches the password
 */ function argon2Verify(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateVerifyOptions$1(options);
        const params = getHashParameters(options.password, options.hash, options.secret);
        validateOptions$3(params);
        const hashStart = options.hash.lastIndexOf("$") + 1;
        const result = yield argon2Internal(params);
        return result.substring(hashStart) === options.hash.substring(hashStart);
    });
}
var name$i = "blake2s";
var data$i = "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";
var hash$i = "5c0ff166";
var wasmJson$i = {
    name: name$i,
    data: data$i,
    hash: hash$i
};
const mutex$j = new Mutex();
let wasmCache$j = null;
function validateBits$3(bits) {
    if (!Number.isInteger(bits) || bits < 8 || bits > 256 || bits % 8 !== 0) return new Error("Invalid variant! Valid values: 8, 16, ..., 256");
    return null;
}
function getInitParam(outputBits, keyBits) {
    return outputBits | keyBits << 16;
}
/**
 * Calculates BLAKE2s hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param bits Number of output bits, which has to be a number
 *             divisible by 8, between 8 and 256. Defaults to 256.
 * @param key Optional key (string, Buffer or TypedArray). Maximum length is 32 bytes.
 * @returns Computed hash as a hexadecimal string
 */ function blake2s(data, bits = 256, key = null) {
    if (validateBits$3(bits)) return Promise.reject(validateBits$3(bits));
    let keyBuffer = null;
    let initParam = bits;
    if (key !== null) {
        keyBuffer = getUInt8Buffer(key);
        if (keyBuffer.length > 32) return Promise.reject(new Error("Max key length is 32 bytes"));
        initParam = getInitParam(bits, keyBuffer.length);
    }
    const hashLength = bits / 8;
    if (wasmCache$j === null || wasmCache$j.hashLength !== hashLength) return lockedCreate(mutex$j, wasmJson$i, hashLength).then((wasm)=>{
        wasmCache$j = wasm;
        if (initParam > 512) wasmCache$j.writeMemory(keyBuffer);
        return wasmCache$j.calculate(data, initParam);
    });
    try {
        if (initParam > 512) wasmCache$j.writeMemory(keyBuffer);
        const hash = wasmCache$j.calculate(data, initParam);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new BLAKE2s hash instance
 * @param bits Number of output bits, which has to be a number
 *             divisible by 8, between 8 and 256. Defaults to 256.
 * @param key Optional key (string, Buffer or TypedArray). Maximum length is 32 bytes.
 */ function createBLAKE2s(bits = 256, key = null) {
    if (validateBits$3(bits)) return Promise.reject(validateBits$3(bits));
    let keyBuffer = null;
    let initParam = bits;
    if (key !== null) {
        keyBuffer = getUInt8Buffer(key);
        if (keyBuffer.length > 32) return Promise.reject(new Error("Max key length is 32 bytes"));
        initParam = getInitParam(bits, keyBuffer.length);
    }
    const outputSize = bits / 8;
    return WASMInterface(wasmJson$i, outputSize).then((wasm)=>{
        if (initParam > 512) wasm.writeMemory(keyBuffer);
        wasm.init(initParam);
        const obj = {
            init: initParam > 512 ? ()=>{
                wasm.writeMemory(keyBuffer);
                wasm.init(initParam);
                return obj;
            } : ()=>{
                wasm.init(initParam);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: outputSize
        };
        return obj;
    });
}
var name$h = "blake3";
var data$h = "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IQEgAkFAaiICQcAASw0ACwsCQEHAACAHQf8BcSIGayIFIAIgBSACSRsiCUUNACAJQQNxIQtBACEFAkAgCUEESQ0AIAAgBmohByAJQfwAcSEIQQAhBQNAIAcgBWoiAkEoaiABIAVqIgotAAA6AAAgAkEpaiAKQQFqLQAAOgAAIAJBKmogCkECai0AADoAACACQStqIApBA2otAAA6AAAgCCAFQQRqIgVHDQALCwJAIAtFDQAgASAFaiEBIAUgBmogAGpBKGohBQNAIAUgAS0AADoAACABQQFqIQEgBUEBaiEFIAtBf2oiCw0ACwsgAC0AaCEHCyAAIAcgCWo6AGggA0HAAGokAAveAwQFfwN+BX8GfiMAQdABayIBJAACQCAAe6ciAkEALQCQigEiA08NAEEALQCKigFBBHIhBCABQShqIQVBACkDmIkBIQBBACkDkIkBIQZBACkDiIkBIQdBACkDgIkBIQggAyEJA0AgASAANwMYIAEgBjcDECABIAc3AwggASAINwMAIAEgA0EFdCIDQdGJAWoiCikDADcDKCABIANB2YkBaiILKQMANwMwIAEgA0HhiQFqIgwpAwA3AzggASADQemJAWoiDSkDADcDQCABIANB8YkBaikDADcDSCABIANB+YkBaikDADcDUCABIANBgYoBaikDADcDWCADQYmKAWopAwAhDiABQcAAOgBoIAEgDjcDYCABQgA3AyAgASAEOgBpIAEgADcDiAEgASAGNwOAASABIAc3A3ggASAINwNwIAFBkAFqIAFB8ABqIAVBwABCACAEQf8BcRACIAEpA7ABIQ4gASkDkAEhDyABKQO4ASEQIAEpA5gBIREgASkDwAEhEiABKQOgASETIA0gASkDyAEgASkDqAGFNwMAIAwgEiAThTcDACALIBAgEYU3AwAgCiAOIA+FNwMAIAlBf2oiCUH/AXEiAyACSw0AC0EAIAk6AJCKAQsgAUHQAWokAAvHCQIKfwV+IwBB4AJrIgUkAAJAAkAgAUGACEsNACAFIAA2AvwBIAVB/AFqIAFBgAhGIgZBECACQQEgA0EBQQIgBBABIAZBCnQiByABTw0BIAVB4ABqIgZCADcDACAFQdgAaiIIQgA3AwAgBUHQAGoiCUIANwMAIAVByABqIgpCADcDACAFQcAAaiILQgA3AwAgBUE4aiIMQgA3AwAgBUEwaiINQgA3AwAgBSADOgBqIAVCADcDKCAFQQA7AWggBUEAKQOAiQE3AwAgBUEAKQOIiQE3AwggBUEAKQOQiQE3AxAgBUEAKQOYiQE3AxggBSABQYAIRiIOrSACfDcDICAFIAAgB2pBACABIA4bEAQgBUGIAWpBMGogDSkDADcDACAFQYgBakE4aiAMKQMANwMAIAUgBSkDACIPNwOIASAFIAUpAwgiEDcDkAEgBSAFKQMQIhE3A5gBIAUgBSkDGCISNwOgASAFIAUpAyg3A7ABIAUtAGohACAFLQBpIQcgBSkDICECIAUtAGghASAFQYgBakHAAGogCykDADcDACAFQYgBakHIAGogCikDADcDACAFQYgBakHQAGogCSkDADcDACAFQYgBakHYAGogCCkDADcDACAFQYgBakHgAGogBikDADcDACAFIAE6APABIAUgAjcDqAEgBSAAIAdFckECciIAOgDxASAFIBI3A5gCIAUgETcDkAIgBSAQNwOIAiAFIA83A4ACIAVBoAJqIAVBgAJqIAVBsAFqIAEgAiAAQf8BcRACIAUpA8ACIQIgBSkDoAIhDyAFKQPIAiEQIAUpA6gCIREgBSkD0AIhEiAFKQOwAiETIAQgDkEFdGoiASAFKQPYAiAFKQO4AoU3AxggASASIBOFNwMQIAEgECARhTcDCCABIAIgD4U3AwBBAkEBIA4bIQYMAQsgAEIBIAFBf2pBCnZBAXKteUI/hYYiD6dBCnQiDiACIAMgBRAGIQcgACAOaiABIA5rIA9C////AYMgAnwgAyAFQcAAQSAgDkGACEsbahAGIQECQCAHQQFHDQAgBCAFKQMANwMAIAQgBSkDCDcDCCAEIAUpAxA3AxAgBCAFKQMYNwMYIAQgBSkDIDcDICAEIAUpAyg3AyggBCAFKQMwNwMwIAQgBSkDODcDOEECIQYMAQtBACEGQQAhAAJAIAEgB2oiCUECSQ0AIAlBfmoiCkEBdkEBaiIGQQNxIQ5BACEHAkAgCkEGSQ0AIAZB/P///wdxIQhBACEHIAVBiAFqIQEgBSEAA0AgASAANgIAIAFBDGogAEHAAWo2AgAgAUEIaiAAQYABajYCACABQQRqIABBwABqNgIAIABBgAJqIQAgAUEQaiEBIAggB0EEaiIHRw0ACwsgCkF+cSEIAkAgDkUNACAFIAdBBnRqIQEgBUGIAWogB0ECdGohAANAIAAgATYCACABQcAAaiEBIABBBGohACAOQX9qIg4NAAsLIAhBAmohAAsgBUGIAWogBkEBQgBBACADQQRyQQBBACAEEAEgACAJTw0AIAQgBkEFdGoiASAFIAZBBnRqIgApAwA3AwAgASAAKQMINwMIIAEgACkDEDcDECABIAApAxg3AxggBkEBaiEGCyAFQeACaiQAIAYLrRAIAn8EfgF/AX4EfwR+BH8EfiMAQfABayIBJAACQCAARQ0AAkBBAC0AkIoBIgINACABQTBqQQApA9CJATcDACABQThqQQApA9iJATcDACABQQApA6CJASIDNwMAIAFBACkDqIkBIgQ3AwggAUEAKQOwiQEiBTcDECABQQApA7iJASIGNwMYIAFBACkDyIkBNwMoQQAtAIqKASECQQAtAImKASEHQQApA8CJASEIQQAtAIiKASEJIAFBwABqQQApA+CJATcDACABQcgAakEAKQPoiQE3AwAgAUHQAGpBACkD8IkBNwMAIAFB2ABqQQApA/iJATcDACABQeAAakEAKQOAigE3AwAgASAJOgBoIAEgCDcDICABIAIgB0VyIgJBAnI6AGkgAUEoaiEKQgAhCEGACSELIAJBCnJB/wFxIQwDQCABQbABaiABIAogCUH/AXEgCCAMEAIgASABKQPQASINIAEpA7ABhTcDcCABIAEpA9gBIg4gASkDuAGFNwN4IAEgASkD4AEiDyABKQPAAYU3A4ABIAEgASkD6AEiECAGhTcDqAEgASAPIAWFNwOgASABIA4gBIU3A5gBIAEgDSADhTcDkAEgASAQIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQAMAgsLAkACQAJAQQAtAImKASIHQQZ0QQBBAC0AiIoBIhFrRg0AIAEgEToAaCABQQApA4CKATcDYCABQQApA/iJATcDWCABQQApA/CJATcDUCABQQApA+iJATcDSCABQQApA+CJATcDQCABQQApA9iJATcDOCABQQApA9CJATcDMCABQQApA8iJATcDKCABQQApA8CJASIINwMgIAFBACkDuIkBIgM3AxggAUEAKQOwiQEiBDcDECABQQApA6iJASIFNwMIIAFBACkDoIkBIgY3AwAgAUEALQCKigEiEyAHRXJBAnIiCzoAaSATQQRyIRNBACkDmIkBIQ1BACkDkIkBIQ5BACkDiIkBIQ9BACkDgIkBIRAMAQtBwAAhESABQcAAOgBoQgAhCCABQgA3AyAgAUEAKQOYiQEiDTcDGCABQQApA5CJASIONwMQIAFBACkDiIkBIg83AwggAUEAKQOAiQEiEDcDACABQQAtAIqKAUEEciITOgBpIAEgAkF+aiICQQV0IgdByYoBaikDADcDYCABIAdBwYoBaikDADcDWCABIAdBuYoBaikDADcDUCABIAdBsYoBaikDADcDSCABIAdBqYoBaikDADcDQCABIAdBoYoBaikDADcDOCABIAdBmYoBaikDADcDMCABIAdBkYoBaikDADcDKCATIQsgECEGIA8hBSAOIQQgDSEDIAJFDQELIAJBf2oiB0EFdCIUQZGKAWopAwAhFSAUQZmKAWopAwAhFiAUQaGKAWopAwAhFyAUQamKAWopAwAhGCABIAM3A4gBIAEgBDcDgAEgASAFNwN4IAEgBjcDcCABQbABaiABQfAAaiABQShqIhQgESAIIAtB/wFxEAIgASATOgBpIAFBwAA6AGggASAYNwNAIAEgFzcDOCABIBY3AzAgASAVNwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggB0UNACACQQV0QemJAWohAiATQf8BcSERA0AgAkFoaikDACEIIAJBcGopAwAhAyACQXhqKQMAIQQgAikDACEFIAEgDTcDiAEgASAONwOAASABIA83A3ggASAQNwNwIAFBsAFqIAFB8ABqIBRBwABCACAREAIgASATOgBpIAFBwAA6AGggASAFNwNAIAEgBDcDOCABIAM3AzAgASAINwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggAkFgaiECIAdBf2oiBw0ACwsgAUEoaiEJQgAhCEGACSELIBNBCHJB/wFxIQoDQCABQbABaiABIAlBwAAgCCAKEAIgASABKQPQASIDIAEpA7ABhTcDcCABIAEpA9gBIgQgASkDuAGFNwN4IAEgASkD4AEiBSABKQPAAYU3A4ABIAEgDSABKQPoASIGhTcDqAEgASAOIAWFNwOgASABIA8gBIU3A5gBIAEgECADhTcDkAEgASAGIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQALCyABQfABaiQAC6MCAQR+AkACQCAAQSBGDQBCq7OP/JGjs/DbACEBQv+kuYjFkdqCm38hAkLy5rvjo6f9p6V/IQNC58yn0NbQ67O7fyEEQQAhAAwBC0EAKQOYCSEBQQApA5AJIQJBACkDiAkhA0EAKQOACSEEQRAhAAtBACAAOgCKigFBAEIANwOAigFBAEIANwP4iQFBAEIANwPwiQFBAEIANwPoiQFBAEIANwPgiQFBAEIANwPYiQFBAEIANwPQiQFBAEIANwPIiQFBAEIANwPAiQFBACABNwO4iQFBACACNwOwiQFBACADNwOoiQFBACAENwOgiQFBACABNwOYiQFBACACNwOQiQFBACADNwOIiQFBACAENwOAiQFBAEEAOgCQigFBAEEAOwGIigELBgAgABADCwYAIAAQBwsGAEGAiQELqwIBBH4CQAJAIAFBIEYNAEKrs4/8kaOz8NsAIQNC/6S5iMWR2oKbfyEEQvLmu+Ojp/2npX8hBULnzKfQ1tDrs7t/IQZBACEBDAELQQApA5gJIQNBACkDkAkhBEEAKQOICSEFQQApA4AJIQZBECEBC0EAIAE6AIqKAUEAQgA3A4CKAUEAQgA3A/iJAUEAQgA3A/CJAUEAQgA3A+iJAUEAQgA3A+CJAUEAQgA3A9iJAUEAQgA3A9CJAUEAQgA3A8iJAUEAQgA3A8CJAUEAIAM3A7iJAUEAIAQ3A7CJAUEAIAU3A6iJAUEAIAY3A6CJAUEAIAM3A5iJAUEAIAQ3A5CJAUEAIAU3A4iJAUEAIAY3A4CJAUEAQQA6AJCKAUEAQQA7AYiKASAAEAMgAhAHCwsLAQBBgAgLBHgHAAA=";
var hash$h = "215d875f";
var wasmJson$h = {
    name: name$h,
    data: data$h,
    hash: hash$h
};
const mutex$i = new Mutex();
let wasmCache$i = null;
function validateBits$2(bits) {
    if (!Number.isInteger(bits) || bits < 8 || bits % 8 !== 0) return new Error("Invalid variant! Valid values: 8, 16, ...");
    return null;
}
/**
 * Calculates BLAKE3 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param bits Number of output bits, which has to be a number
 *             divisible by 8. Defaults to 256.
 * @param key Optional key (string, Buffer or TypedArray). Length should be 32 bytes.
 * @returns Computed hash as a hexadecimal string
 */ function blake3(data, bits = 256, key = null) {
    if (validateBits$2(bits)) return Promise.reject(validateBits$2(bits));
    let keyBuffer = null;
    let initParam = 0; // key is empty by default
    if (key !== null) {
        keyBuffer = getUInt8Buffer(key);
        if (keyBuffer.length !== 32) return Promise.reject(new Error("Key length must be exactly 32 bytes"));
        initParam = 32;
    }
    const hashLength = bits / 8;
    const digestParam = hashLength;
    if (wasmCache$i === null || wasmCache$i.hashLength !== hashLength) return lockedCreate(mutex$i, wasmJson$h, hashLength).then((wasm)=>{
        wasmCache$i = wasm;
        if (initParam === 32) wasmCache$i.writeMemory(keyBuffer);
        return wasmCache$i.calculate(data, initParam, digestParam);
    });
    try {
        if (initParam === 32) wasmCache$i.writeMemory(keyBuffer);
        const hash = wasmCache$i.calculate(data, initParam, digestParam);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new BLAKE3 hash instance
 * @param bits Number of output bits, which has to be a number
 *             divisible by 8. Defaults to 256.
 * @param key Optional key (string, Buffer or TypedArray). Length should be 32 bytes.
 */ function createBLAKE3(bits = 256, key = null) {
    if (validateBits$2(bits)) return Promise.reject(validateBits$2(bits));
    let keyBuffer = null;
    let initParam = 0; // key is empty by default
    if (key !== null) {
        keyBuffer = getUInt8Buffer(key);
        if (keyBuffer.length !== 32) return Promise.reject(new Error("Key length must be exactly 32 bytes"));
        initParam = 32;
    }
    const outputSize = bits / 8;
    const digestParam = outputSize;
    return WASMInterface(wasmJson$h, outputSize).then((wasm)=>{
        if (initParam === 32) wasm.writeMemory(keyBuffer);
        wasm.init(initParam);
        const obj = {
            init: initParam === 32 ? ()=>{
                wasm.writeMemory(keyBuffer);
                wasm.init(initParam);
                return obj;
            } : ()=>{
                wasm.init(initParam);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType, digestParam),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: outputSize
        };
        return obj;
    });
}
var name$g = "crc32";
var data$g = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==";
var hash$g = "d2eba587";
var wasmJson$g = {
    name: name$g,
    data: data$g,
    hash: hash$g
};
const mutex$h = new Mutex();
let wasmCache$h = null;
function validatePoly(poly) {
    if (!Number.isInteger(poly) || poly < 0 || poly > 0xffffffff) return new Error("Polynomial must be a valid 32-bit long unsigned integer");
    return null;
}
/**
 * Calculates CRC-32 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param polynomial Input polynomial (defaults to 0xedb88320, for CRC32C use 0x82f63b78)
 * @returns Computed hash as a hexadecimal string
 */ function crc32(data, polynomial = 0xedb88320) {
    if (validatePoly(polynomial)) return Promise.reject(validatePoly(polynomial));
    if (wasmCache$h === null) return lockedCreate(mutex$h, wasmJson$g, 4).then((wasm)=>{
        wasmCache$h = wasm;
        return wasmCache$h.calculate(data, polynomial);
    });
    try {
        const hash = wasmCache$h.calculate(data, polynomial);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new CRC-32 hash instance
 * @param polynomial Input polynomial (defaults to 0xedb88320, for CRC32C use 0x82f63b78)
 */ function createCRC32(polynomial = 0xedb88320) {
    if (validatePoly(polynomial)) return Promise.reject(validatePoly(polynomial));
    return WASMInterface(wasmJson$g, 4).then((wasm)=>{
        wasm.init(polynomial);
        const obj = {
            init: ()=>{
                wasm.init(polynomial);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 4,
            digestSize: 4
        };
        return obj;
    });
}
var name$f = "crc64";
var data$f = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQZCJBgt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKgwgGBQBBgAkL9QMDAX4BfwJ+AkBBACkDgIkCQQApA4AJIgBRDQBBgIkBIQFCACECA0AgAUIAQgBCAEIAQgBCAEIAQgAgAkIBg30gAIMgAkIBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIU3AwAgAUEIaiEBIAJCAXwiAkKAAlINAAtBACEBA0AgAUGImQFqIAFBiIkBaikDACICp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiKkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiLkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiMkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiNkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiOkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiPkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhTcDACABQQhqIgFB+A9HDQALQQAgADcDgIkCC0EAQgA3A4iJAguUAwIBfgJ/QQApA4iJAkJ/hSEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAIpAwAgAYUiAUIwiKdB/wFxQQN0QYCZAWopAwAgAUI4iKdBA3RBgIkBaikDAIUgAUIoiKdB/wFxQQN0QYCpAWopAwCFIAFCIIinQf8BcUEDdEGAuQFqKQMAhSABpyIDQRV2QfgPcUGAyQFqKQMAhSADQQ12QfgPcUGA2QFqKQMAhSADQQV2QfgPcUGA6QFqKQMAhSADQf8BcUEDdEGA+QFqKQMAhSEBIAJBCGohAiAAQXhqIgBBB0sNAAsLAkAgAEUNAAJAAkAgAEEBcQ0AIAAhAwwBCyABQv8BgyACMQAAhadBA3RBgIkBaikDACABQgiIhSEBIAJBAWohAiAAQX9qIQMLIABBAUYNAANAIAFC/wGDIAIxAACFp0EDdEGAiQFqKQMAIAFCCIiFIgFC/wGDIAJBAWoxAACFp0EDdEGAiQFqKQMAIAFCCIiFIQEgAkECaiECIANBfmoiAw0ACwtBACABQn+FNwOIiQILZAEBfkEAQQApA4iJAiIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGIiQILAgALCwsBAEGACAsECAAAAA==";
var hash$f = "c5ac6c16";
var wasmJson$f = {
    name: name$f,
    data: data$f,
    hash: hash$f
};
const mutex$g = new Mutex();
let wasmCache$g = null;
const polyBuffer = new Uint8Array(8);
function parsePoly(poly) {
    const errText = "Polynomial must be provided as a 16 char long hex string";
    if (typeof poly !== "string" || poly.length !== 16) return {
        hi: 0,
        lo: 0,
        err: new Error(errText)
    };
    const hi = Number(`0x${poly.slice(0, 8)}`);
    const lo = Number(`0x${poly.slice(8)}`);
    if (Number.isNaN(hi) || Number.isNaN(lo)) return {
        hi,
        lo,
        err: new Error(errText)
    };
    return {
        hi,
        lo,
        err: null
    };
}
function writePoly(arr, lo, hi) {
    // write in little-endian format
    const buffer = new DataView(arr);
    buffer.setUint32(0, lo, true);
    buffer.setUint32(4, hi, true);
}
/**
 * Calculates CRC-64 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param polynomial Input polynomial (defaults to 'c96c5795d7870f42' - ECMA)
 * @returns Computed hash as a hexadecimal string
 */ function crc64(data, polynomial = "c96c5795d7870f42") {
    const { hi, lo, err } = parsePoly(polynomial);
    if (err !== null) return Promise.reject(err);
    if (wasmCache$g === null) return lockedCreate(mutex$g, wasmJson$f, 8).then((wasm)=>{
        wasmCache$g = wasm;
        writePoly(polyBuffer.buffer, lo, hi);
        wasmCache$g.writeMemory(polyBuffer);
        return wasmCache$g.calculate(data);
    });
    try {
        writePoly(polyBuffer.buffer, lo, hi);
        wasmCache$g.writeMemory(polyBuffer);
        const hash = wasmCache$g.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new CRC-64 hash instance
 * @param polynomial Input polynomial (defaults to 'c96c5795d7870f42' - ECMA)
 */ function createCRC64(polynomial = "c96c5795d7870f42") {
    const { hi, lo, err } = parsePoly(polynomial);
    if (err !== null) return Promise.reject(err);
    return WASMInterface(wasmJson$f, 8).then((wasm)=>{
        const instanceBuffer = new Uint8Array(8);
        writePoly(instanceBuffer.buffer, lo, hi);
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.writeMemory(instanceBuffer);
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 8,
            digestSize: 8
        };
        return obj;
    });
}
var name$e = "md4";
var data$e = "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";
var hash$e = "bd8ce7c7";
var wasmJson$e = {
    name: name$e,
    data: data$e,
    hash: hash$e
};
const mutex$f = new Mutex();
let wasmCache$f = null;
/**
 * Calculates MD4 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function md4(data) {
    if (wasmCache$f === null) return lockedCreate(mutex$f, wasmJson$e, 16).then((wasm)=>{
        wasmCache$f = wasm;
        return wasmCache$f.calculate(data);
    });
    try {
        const hash = wasmCache$f.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new MD4 hash instance
 */ function createMD4() {
    return WASMInterface(wasmJson$e, 16).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 16
        };
        return obj;
    });
}
var name$d = "md5";
var data$d = "AGFzbQEAAAABEgRgAAF/YAAAYAF/AGACf38BfwMIBwABAgMBAAIFBAEBAgIGDgJ/AUGgigULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAELSGFzaF9VcGRhdGUAAgpIYXNoX0ZpbmFsAAQNSGFzaF9HZXRTdGF0ZQAFDkhhc2hfQ2FsY3VsYXRlAAYKU1RBVEVfU0laRQMBCoMaBwUAQYAJCy0AQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQu+BQEHf0EAQQAoAoCJASIBIABqQf////8BcSICNgKAiQFBAEEAKAKEiQEgAiABSWogAEEddmo2AoSJAQJAAkACQAJAAkACQCABQT9xIgMNAEGACSEEDAELIABBwAAgA2siBUkNASAFQQNxIQZBACEBAkAgA0E/c0EDSQ0AIANBgIkBaiEEIAVB/ABxIQdBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAcgAUEEaiIBRw0ACwsCQCAGRQ0AIANBmIkBaiECA0AgAiABaiABQYAJai0AADoAACABQQFqIQEgBkF/aiIGDQALC0GYiQFBwAAQAxogACAFayEAIAVBgAlqIQQLIABBwABPDQEgACECDAILIABFDQIgAEEDcSEGQQAhAQJAIABBBEkNACADQYCJAWohBCAAQXxxIQBBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAiADQZiJAWohAgNAIAIgAWogAUGACWotAAA6AAAgAUEBaiEBIAZBf2oiBg0ADAMLCyAAQT9xIQIgBCAAQUBxEAMhBAsgAkUNACACQQNxIQZBACEBAkAgAkEESQ0AIAJBPHEhAEEAIQEDQCABQZiJAWogBCABaiICLQAAOgAAIAFBmYkBaiACQQFqLQAAOgAAIAFBmokBaiACQQJqLQAAOgAAIAFBm4kBaiACQQNqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAANAIAFBmIkBaiAEIAFqLQAAOgAAIAFBAWohASAGQX9qIgYNAAsLC4cQARl/QQAoApSJASECQQAoApCJASEDQQAoAoyJASEEQQAoAoiJASEFA0AgACgCCCIGIAAoAhgiByAAKAIoIgggACgCOCIJIAAoAjwiCiAAKAIMIgsgACgCHCIMIAAoAiwiDSAMIAsgCiANIAkgCCAHIAMgBmogAiAAKAIEIg5qIAUgBCACIANzcSACc2ogACgCACIPakH4yKq7fWpBB3cgBGoiECAEIANzcSADc2pB1u6exn5qQQx3IBBqIhEgECAEc3EgBHNqQdvhgaECakERdyARaiISaiAAKAIUIhMgEWogACgCECIUIBBqIAQgC2ogEiARIBBzcSAQc2pB7p33jXxqQRZ3IBJqIhAgEiARc3EgEXNqQa+f8Kt/akEHdyAQaiIRIBAgEnNxIBJzakGqjJ+8BGpBDHcgEWoiEiARIBBzcSAQc2pBk4zBwXpqQRF3IBJqIhVqIAAoAiQiFiASaiAAKAIgIhcgEWogDCAQaiAVIBIgEXNxIBFzakGBqppqakEWdyAVaiIQIBUgEnNxIBJzakHYsYLMBmpBB3cgEGoiESAQIBVzcSAVc2pBr++T2nhqQQx3IBFqIhIgESAQc3EgEHNqQbG3fWpBEXcgEmoiFWogACgCNCIYIBJqIAAoAjAiGSARaiANIBBqIBUgEiARc3EgEXNqQb6v88p4akEWdyAVaiIQIBUgEnNxIBJzakGiosDcBmpBB3cgEGoiESAQIBVzcSAVc2pBk+PhbGpBDHcgEWoiFSARIBBzcSAQc2pBjofls3pqQRF3IBVqIhJqIAcgFWogDiARaiAKIBBqIBIgFSARc3EgEXNqQaGQ0M0EakEWdyASaiIQIBJzIBVxIBJzakHiyviwf2pBBXcgEGoiESAQcyAScSAQc2pBwOaCgnxqQQl3IBFqIhIgEXMgEHEgEXNqQdG0+bICakEOdyASaiIVaiAIIBJqIBMgEWogDyAQaiAVIBJzIBFxIBJzakGqj9vNfmpBFHcgFWoiECAVcyAScSAVc2pB3aC8sX1qQQV3IBBqIhEgEHMgFXEgEHNqQdOokBJqQQl3IBFqIhIgEXMgEHEgEXNqQYHNh8V9akEOdyASaiIVaiAJIBJqIBYgEWogFCAQaiAVIBJzIBFxIBJzakHI98++fmpBFHcgFWoiECAVcyAScSAVc2pB5puHjwJqQQV3IBBqIhEgEHMgFXEgEHNqQdaP3Jl8akEJdyARaiISIBFzIBBxIBFzakGHm9Smf2pBDncgEmoiFWogBiASaiAYIBFqIBcgEGogFSAScyARcSASc2pB7anoqgRqQRR3IBVqIhAgFXMgEnEgFXNqQYXSj896akEFdyAQaiIRIBBzIBVxIBBzakH4x75nakEJdyARaiISIBFzIBBxIBFzakHZhby7BmpBDncgEmoiFWogFyASaiATIBFqIBkgEGogFSAScyARcSASc2pBipmp6XhqQRR3IBVqIhAgFXMiFSASc2pBwvJoakEEdyAQaiIRIBVzakGB7ce7eGpBC3cgEWoiEiARcyIaIBBzakGiwvXsBmpBEHcgEmoiFWogFCASaiAOIBFqIAkgEGogFSAac2pBjPCUb2pBF3cgFWoiECAVcyIVIBJzakHE1PulempBBHcgEGoiESAVc2pBqZ/73gRqQQt3IBFqIhIgEXMiCSAQc2pB4JbttX9qQRB3IBJqIhVqIA8gEmogGCARaiAIIBBqIBUgCXNqQfD4/vV7akEXdyAVaiIQIBVzIhUgEnNqQcb97cQCakEEdyAQaiIRIBVzakH6z4TVfmpBC3cgEWoiEiARcyIIIBBzakGF4bynfWpBEHcgEmoiFWogGSASaiAWIBFqIAcgEGogFSAIc2pBhbqgJGpBF3cgFWoiESAVcyIQIBJzakG5oNPOfWpBBHcgEWoiEiAQc2pB5bPutn5qQQt3IBJqIhUgEnMiByARc2pB+PmJ/QFqQRB3IBVqIhBqIAwgFWogDyASaiAGIBFqIBAgB3NqQeWssaV8akEXdyAQaiIRIBVBf3NyIBBzakHExKShf2pBBncgEWoiEiAQQX9zciARc2pBl/+rmQRqQQp3IBJqIhAgEUF/c3IgEnNqQafH0Nx6akEPdyAQaiIVaiALIBBqIBkgEmogEyARaiAVIBJBf3NyIBBzakG5wM5kakEVdyAVaiIRIBBBf3NyIBVzakHDs+2qBmpBBncgEWoiECAVQX9zciARc2pBkpmz+HhqQQp3IBBqIhIgEUF/c3IgEHNqQf3ov39qQQ93IBJqIhVqIAogEmogFyAQaiAOIBFqIBUgEEF/c3IgEnNqQdG7kax4akEVdyAVaiIQIBJBf3NyIBVzakHP/KH9BmpBBncgEGoiESAVQX9zciAQc2pB4M2zcWpBCncgEWoiEiAQQX9zciARc2pBlIaFmHpqQQ93IBJqIhVqIA0gEmogFCARaiAYIBBqIBUgEUF/c3IgEnNqQaGjoPAEakEVdyAVaiIQIBJBf3NyIBVzakGC/c26f2pBBncgEGoiESAVQX9zciAQc2pBteTr6XtqQQp3IBFqIhIgEEF/c3IgEXNqQbul39YCakEPdyASaiIVIARqIBYgEGogFSARQX9zciASc2pBkaeb3H5qQRV3aiEEIBUgA2ohAyASIAJqIQIgESAFaiEFIABBwABqIQAgAUFAaiIBDQALQQAgAjYClIkBQQAgAzYCkIkBQQAgBDYCjIkBQQAgBTYCiIkBIAALyAMBBX9BACgCgIkBQT9xIgBBmIkBakGAAToAACAAQQFqIQECQAJAAkACQCAAQT9zIgJBB0sNACACRQ0BIAFBmIkBakEAOgAAIAJBAUYNASAAQZqJAWpBADoAACACQQJGDQEgAEGbiQFqQQA6AAAgAkEDRg0BIABBnIkBakEAOgAAIAJBBEYNASAAQZ2JAWpBADoAACACQQVGDQEgAEGeiQFqQQA6AAAgAkEGRg0BIABBn4kBakEAOgAADAELIAJBCEYNAkE2IABrIgMhBAJAIAJBA3EiAEUNAEEAIABrIQRBACEAA0AgAEHPiQFqQQA6AAAgBCAAQX9qIgBHDQALIAMgAGohBAsgA0EDSQ0CDAELQZiJAUHAABADGkEAIQFBNyEECyABQYCJAWohAEF/IQIDQCAAIARqQRVqQQA2AAAgAEF8aiEAIAQgAkEEaiICRw0ACwtBAEEAKAKEiQE2AtSJAUEAQQAoAoCJASIAQRV2OgDTiQFBACAAQQ12OgDSiQFBACAAQQV2OgDRiQFBACAAQQN0IgA6ANCJAUEAIAA2AoCJAUGYiQFBwAAQAxpBAEEAKQKIiQE3A4AJQQBBACkCkIkBNwOICQsGAEGAiQELMwBBAEL+uevF6Y6VmRA3ApCJAUEAQoHGlLqW8ermbzcCiIkBQQBCADcCgIkBIAAQAhAECwsLAQBBgAgLBJgAAAA=";
var hash$d = "e6508e4b";
var wasmJson$d = {
    name: name$d,
    data: data$d,
    hash: hash$d
};
const mutex$e = new Mutex();
let wasmCache$e = null;
/**
 * Calculates MD5 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function md5(data) {
    if (wasmCache$e === null) return lockedCreate(mutex$e, wasmJson$d, 16).then((wasm)=>{
        wasmCache$e = wasm;
        return wasmCache$e.calculate(data);
    });
    try {
        const hash = wasmCache$e.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new MD5 hash instance
 */ function createMD5() {
    return WASMInterface(wasmJson$d, 16).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 16
        };
        return obj;
    });
}
var name$c = "sha1";
var data$c = "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";
var hash$c = "6b530c24";
var wasmJson$c = {
    name: name$c,
    data: data$c,
    hash: hash$c
};
const mutex$d = new Mutex();
let wasmCache$d = null;
/**
 * Calculates SHA-1 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function sha1(data) {
    if (wasmCache$d === null) return lockedCreate(mutex$d, wasmJson$c, 20).then((wasm)=>{
        wasmCache$d = wasm;
        return wasmCache$d.calculate(data);
    });
    try {
        const hash = wasmCache$d.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SHA-1 hash instance
 */ function createSHA1() {
    return WASMInterface(wasmJson$c, 20).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 20
        };
        return obj;
    });
}
var name$b = "sha3";
var data$b = "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";
var hash$b = "fb24e536";
var wasmJson$b = {
    name: name$b,
    data: data$b,
    hash: hash$b
};
const mutex$c = new Mutex();
let wasmCache$c = null;
function validateBits$1(bits) {
    if (![
        224,
        256,
        384,
        512
    ].includes(bits)) return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
    return null;
}
/**
 * Calculates SHA-3 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param bits Number of output bits. Valid values: 224, 256, 384, 512
 * @returns Computed hash as a hexadecimal string
 */ function sha3(data, bits = 512) {
    if (validateBits$1(bits)) return Promise.reject(validateBits$1(bits));
    const hashLength = bits / 8;
    if (wasmCache$c === null || wasmCache$c.hashLength !== hashLength) return lockedCreate(mutex$c, wasmJson$b, hashLength).then((wasm)=>{
        wasmCache$c = wasm;
        return wasmCache$c.calculate(data, bits, 0x06);
    });
    try {
        const hash = wasmCache$c.calculate(data, bits, 0x06);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SHA-3 hash instance
 * @param bits Number of output bits. Valid values: 224, 256, 384, 512
 */ function createSHA3(bits = 512) {
    if (validateBits$1(bits)) return Promise.reject(validateBits$1(bits));
    const outputSize = bits / 8;
    return WASMInterface(wasmJson$b, outputSize).then((wasm)=>{
        wasm.init(bits);
        const obj = {
            init: ()=>{
                wasm.init(bits);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType, 0x06),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 200 - 2 * outputSize,
            digestSize: outputSize
        };
        return obj;
    });
}
const mutex$b = new Mutex();
let wasmCache$b = null;
function validateBits(bits) {
    if (![
        224,
        256,
        384,
        512
    ].includes(bits)) return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
    return null;
}
/**
 * Calculates Keccak hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param bits Number of output bits. Valid values: 224, 256, 384, 512
 * @returns Computed hash as a hexadecimal string
 */ function keccak(data, bits = 512) {
    if (validateBits(bits)) return Promise.reject(validateBits(bits));
    const hashLength = bits / 8;
    if (wasmCache$b === null || wasmCache$b.hashLength !== hashLength) return lockedCreate(mutex$b, wasmJson$b, hashLength).then((wasm)=>{
        wasmCache$b = wasm;
        return wasmCache$b.calculate(data, bits, 0x01);
    });
    try {
        const hash = wasmCache$b.calculate(data, bits, 0x01);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new Keccak hash instance
 * @param bits Number of output bits. Valid values: 224, 256, 384, 512
 */ function createKeccak(bits = 512) {
    if (validateBits(bits)) return Promise.reject(validateBits(bits));
    const outputSize = bits / 8;
    return WASMInterface(wasmJson$b, outputSize).then((wasm)=>{
        wasm.init(bits);
        const obj = {
            init: ()=>{
                wasm.init(bits);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType, 0x01),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 200 - 2 * outputSize,
            digestSize: outputSize
        };
        return obj;
    });
}
var name$a = "sha256";
var data$a = "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c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJz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";
var hash$a = "8c18dd94";
var wasmJson$a = {
    name: name$a,
    data: data$a,
    hash: hash$a
};
const mutex$a = new Mutex();
let wasmCache$a = null;
/**
 * Calculates SHA-2 (SHA-224) hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function sha224(data) {
    if (wasmCache$a === null) return lockedCreate(mutex$a, wasmJson$a, 28).then((wasm)=>{
        wasmCache$a = wasm;
        return wasmCache$a.calculate(data, 224);
    });
    try {
        const hash = wasmCache$a.calculate(data, 224);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SHA-2 (SHA-224) hash instance
 */ function createSHA224() {
    return WASMInterface(wasmJson$a, 28).then((wasm)=>{
        wasm.init(224);
        const obj = {
            init: ()=>{
                wasm.init(224);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 28
        };
        return obj;
    });
}
const mutex$9 = new Mutex();
let wasmCache$9 = null;
/**
 * Calculates SHA-2 (SHA-256) hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function sha256(data) {
    if (wasmCache$9 === null) return lockedCreate(mutex$9, wasmJson$a, 32).then((wasm)=>{
        wasmCache$9 = wasm;
        return wasmCache$9.calculate(data, 256);
    });
    try {
        const hash = wasmCache$9.calculate(data, 256);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SHA-2 (SHA-256) hash instance
 */ function createSHA256() {
    return WASMInterface(wasmJson$a, 32).then((wasm)=>{
        wasm.init(256);
        const obj = {
            init: ()=>{
                wasm.init(256);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 32
        };
        return obj;
    });
}
var name$9 = "sha512";
var data$9 = "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";
var hash$9 = "f2e40eb1";
var wasmJson$9 = {
    name: name$9,
    data: data$9,
    hash: hash$9
};
const mutex$8 = new Mutex();
let wasmCache$8 = null;
/**
 * Calculates SHA-2 (SHA-384) hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function sha384(data) {
    if (wasmCache$8 === null) return lockedCreate(mutex$8, wasmJson$9, 48).then((wasm)=>{
        wasmCache$8 = wasm;
        return wasmCache$8.calculate(data, 384);
    });
    try {
        const hash = wasmCache$8.calculate(data, 384);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SHA-2 (SHA-384) hash instance
 */ function createSHA384() {
    return WASMInterface(wasmJson$9, 48).then((wasm)=>{
        wasm.init(384);
        const obj = {
            init: ()=>{
                wasm.init(384);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 128,
            digestSize: 48
        };
        return obj;
    });
}
const mutex$7 = new Mutex();
let wasmCache$7 = null;
/**
 * Calculates SHA-2 (SHA-512) hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function sha512(data) {
    if (wasmCache$7 === null) return lockedCreate(mutex$7, wasmJson$9, 64).then((wasm)=>{
        wasmCache$7 = wasm;
        return wasmCache$7.calculate(data, 512);
    });
    try {
        const hash = wasmCache$7.calculate(data, 512);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SHA-2 (SHA-512) hash instance
 */ function createSHA512() {
    return WASMInterface(wasmJson$9, 64).then((wasm)=>{
        wasm.init(512);
        const obj = {
            init: ()=>{
                wasm.init(512);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 128,
            digestSize: 64
        };
        return obj;
    });
}
var name$8 = "xxhash32";
var data$8 = "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";
var hash$8 = "4bb12485";
var wasmJson$8 = {
    name: name$8,
    data: data$8,
    hash: hash$8
};
const mutex$6 = new Mutex();
let wasmCache$6 = null;
function validateSeed$3(seed) {
    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) return new Error("Seed must be a valid 32-bit long unsigned integer.");
    return null;
}
/**
 * Calculates xxHash32 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param seed Number used to initialize the internal state of the algorithm (defaults to 0)
 * @returns Computed hash as a hexadecimal string
 */ function xxhash32(data, seed = 0) {
    if (validateSeed$3(seed)) return Promise.reject(validateSeed$3(seed));
    if (wasmCache$6 === null) return lockedCreate(mutex$6, wasmJson$8, 4).then((wasm)=>{
        wasmCache$6 = wasm;
        return wasmCache$6.calculate(data, seed);
    });
    try {
        const hash = wasmCache$6.calculate(data, seed);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new xxHash32 hash instance
 * @param data Input data (string, Buffer or TypedArray)
 * @param seed Number used to initialize the internal state of the algorithm (defaults to 0)
 */ function createXXHash32(seed = 0) {
    if (validateSeed$3(seed)) return Promise.reject(validateSeed$3(seed));
    return WASMInterface(wasmJson$8, 4).then((wasm)=>{
        wasm.init(seed);
        const obj = {
            init: ()=>{
                wasm.init(seed);
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 16,
            digestSize: 4
        };
        return obj;
    });
}
var name$7 = "xxhash64";
var data$7 = "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";
var hash$7 = "177fbfa3";
var wasmJson$7 = {
    name: name$7,
    data: data$7,
    hash: hash$7
};
const mutex$5 = new Mutex();
let wasmCache$5 = null;
const seedBuffer$2 = new Uint8Array(8);
function validateSeed$2(seed) {
    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
    return null;
}
function writeSeed$2(arr, low, high) {
    // write in little-endian format
    const buffer = new DataView(arr);
    buffer.setUint32(0, low, true);
    buffer.setUint32(4, high, true);
}
/**
 * Calculates xxHash64 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param seedLow Lower 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @param seedHigh Higher 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @returns Computed hash as a hexadecimal string
 */ function xxhash64(data, seedLow = 0, seedHigh = 0) {
    if (validateSeed$2(seedLow)) return Promise.reject(validateSeed$2(seedLow));
    if (validateSeed$2(seedHigh)) return Promise.reject(validateSeed$2(seedHigh));
    if (wasmCache$5 === null) return lockedCreate(mutex$5, wasmJson$7, 8).then((wasm)=>{
        wasmCache$5 = wasm;
        writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
        wasmCache$5.writeMemory(seedBuffer$2);
        return wasmCache$5.calculate(data);
    });
    try {
        writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
        wasmCache$5.writeMemory(seedBuffer$2);
        const hash = wasmCache$5.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new xxHash64 hash instance
 * @param seedLow Lower 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @param seedHigh Higher 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 */ function createXXHash64(seedLow = 0, seedHigh = 0) {
    if (validateSeed$2(seedLow)) return Promise.reject(validateSeed$2(seedLow));
    if (validateSeed$2(seedHigh)) return Promise.reject(validateSeed$2(seedHigh));
    return WASMInterface(wasmJson$7, 8).then((wasm)=>{
        const instanceBuffer = new Uint8Array(8);
        writeSeed$2(instanceBuffer.buffer, seedLow, seedHigh);
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.writeMemory(instanceBuffer);
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 32,
            digestSize: 8
        };
        return obj;
    });
}
var name$6 = "xxhash3";
var data$6 = "AGFzbQEAAAABNAhgAAF/YAR/f39/AGAHf39/f39/fwBgBH9+fn4BfmAEf39/fgF+YAN/f34BfmAAAGABfwADDg0AAQIDBAUFBQYHBgAGBQQBAQICBg4CfwFBwI4FC38AQcAJCwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQr6QQ0FAEGACgvkAwMPfgF/AX4CQCADRQ0AIAApAzAhBCAAKQM4IQUgACkDICEGIAApAyghByAAKQMQIQggACkDGCEJIAApAwAhCiAAKQMIIQsDQCAFIAFBMGopAwAiDHwgAkE4aikDACABQThqKQMAIg2FIgVCIIggBUL/////D4N+fCEFIAcgAUEgaikDACIOfCACQShqKQMAIAFBKGopAwAiD4UiB0IgiCAHQv////8Pg358IQcgCSABQRBqKQMAIhB8IAJBGGopAwAgAUEYaikDACIRhSIJQiCIIAlC/////w+DfnwhCSALIAEpAwAiEnwgAkEIaiITKQMAIAFBCGopAwAiFIUiC0IgiCALQv////8Pg358IQsgAkEwaikDACAMhSIMQiCIIAxC/////w+DfiAEfCANfCEEIAJBIGopAwAgDoUiDEIgiCAMQv////8Pg34gBnwgD3whBiACQRBqKQMAIBCFIgxCIIggDEL/////D4N+IAh8IBF8IQggAikDACAShSIMQiCIIAxC/////w+DfiAKfCAUfCEKIAFBwABqIQEgEyECIANBf2oiAw0ACyAAIAk3AxggACAKNwMAIAAgCzcDCCAAIAc3AyggACAINwMQIAAgBTcDOCAAIAY3AyAgACAENwMwCwveAgIBfwF+AkAgBCACIAEoAgAiB2siAkkNACAAIAMgBSAHQQN0aiACEAEgACAFIAZqIgcpAwAgACkDACIIQi+IhSAIhUKx893xCX43AwAgACAHKQMIIAApAwgiCEIviIUgCIVCsfPd8Ql+NwMIIAAgBykDECAAKQMQIghCL4iFIAiFQrHz3fEJfjcDECAAIAcpAxggACkDGCIIQi+IhSAIhUKx893xCX43AxggACAHKQMgIAApAyAiCEIviIUgCIVCsfPd8Ql+NwMgIAAgBykDKCAAKQMoIghCL4iFIAiFQrHz3fEJfjcDKCAAIAcpAzAgACkDMCIIQi+IhSAIhUKx893xCX43AzAgACAHKQM4IAApAzgiCEIviIUgCIVCsfPd8Ql+NwM4IAAgAyACQQZ0aiAFIAQgAmsiBxABIAEgBzYCAA8LIAAgAyAFIAdBA3RqIAQQASABIAcgBGo2AgALhQEBAX8gAiABhSADpyIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZycq1CIIYgA4V9QQA1AoCMAUIghiAAQfyLAWo1AgCEhSIDQjGJIANCGImFIAOFQqW+4/TRjIfZn39+IgNCI4ggAK18IAOFQqW+4/TRjIfZn39+IgNCHIggA4ULZwAgAiABc60gA3wiA0IhiEEALQCAjAFBEHQgAEEIdHIgAEEBdkGAjAFqLQAAQRh0ciAAQf+LAWotAAByrYUgA4VCz9bTvtLHq9lCfiIDQh2IIAOFQvnz3fGZ9pmrFn4iA0IgiCADhQuJAwEEfgJAIABBCUkNAEEAKQOAjAEgASkDICABKQMYhSACfIUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAArXwgAEH4iwFqKQMAIAEpAzAgASkDKIUgAn2FIgJ8IAJC/////w+DIgQgA0IgiCIFfiIGQv////8PgyACQiCIIgIgA0L/////D4MiA358IAQgA34iA0IgiHwiBEIghiADQv////8Pg4QgBkIgiCACIAV+fCAEQiCIfIV8IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFDwsCQCAAQQRJDQAgACABQQhqKQMAIAFBEGopAwAgAhADDwsCQCAARQ0AIAAgASgCACABQQRqKAIAIAIQBA8LIAEpAzggASkDQIUgAoUiA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC94IAQZ+IACtQoeVr6+Ytt6bnn9+IQMCQCAAQSFJDQACQCAAQcEASQ0AAkAgAEHhAEkNACABKQNoIAJ9QQApA7iMAYUiBEL/////D4MiBSABKQNgIAJ8QQApA7CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDeCACfSAAQciLAWopAwCFIgNC/////w+DIgQgASkDcCACfCAAQcCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQNIIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQNAIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDWCACfSAAQdiLAWopAwCFIgNC/////w+DIgQgASkDUCACfCAAQdCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMoIAJ9QQApA5iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA5CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDOCACfSAAQeiLAWopAwCFIgNC/////w+DIgQgASkDMCACfCAAQeCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMIIAJ9QQApA4iMAYUiBEL/////D4MiBSABKQMAIAJ8QQApA4CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDGCACfSAAQfiLAWopAwCFIgNC/////w+DIgQgASkDECACfCAAQfCLAWopAwCFIgJCIIgiBX4iBkL/////D4MgA0IgiCIDIAJC/////w+DIgJ+fCAEIAJ+IgJCIIh8IgRCIIYgAkL/////D4OEIAZCIIggAyAFfnwgBEIgiHyFfCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQv8CgQBfwV+An8BfkEAIQMgASkDeCACfUEAKQP4jAGFIgRC/////w+DIgUgASkDcCACfEEAKQPwjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpA2ggAn1BACkD6IwBhSIEQv////8PgyIFIAEpA2AgAnxBACkD4IwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQNYIAJ9QQApA9iMAYUiBEL/////D4MiBSABKQNQIAJ8QQApA9CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDSCACfUEAKQPIjAGFIgRC/////w+DIgUgASkDQCACfEEAKQPAjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAzggAn1BACkDuIwBhSIEQv////8PgyIFIAEpAzAgAnxBACkDsIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQMoIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDGCACfUEAKQOYjAGFIgRC/////w+DIgUgASkDECACfEEAKQOQjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAwggAn1BACkDiIwBhSIEQv////8PgyIFIAEpAwAgAnxBACkDgIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSAArUKHla+vmLbem55/fnx8fHx8fHx8IgRCJYggBIVC+fPd8ZnymasWfiIEQiCIIASFIQQCQCAAQZABSA0AIABBBHZBeGohCQNAIAEgA2oiCkELaikDACACfSADQYiNAWopAwCFIgVC/////w+DIgYgCkEDaikDACACfCADQYCNAWopAwCFIgdCIIgiCH4iC0L/////D4MgBUIgiCIFIAdC/////w+DIgd+fCAGIAd+IgZCIIh8IgdCIIYgBkL/////D4OEIAtCIIggBSAIfnwgB0IgiHyFIAR8IQQgA0EQaiEDIAlBf2oiCQ0ACwsgASkDfyACfSAAQfiLAWopAwCFIgVC/////w+DIgYgASkDdyACfCAAQfCLAWopAwCFIgJCIIgiB34iCEL/////D4MgBUIgiCIFIAJC/////w+DIgJ+fCAGIAJ+IgJCIIh8IgZCIIYgAkL/////D4OEIAhCIIggBSAHfnwgBkIgiHyFIAR8IgJCJYggAoVC+fPd8ZnymasWfiICQiCIIAKFC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAA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QQApA4CKATcDACACQQApA4iKATcDCCACQQApA5CKATcDECACQQApA5iKATcDGCACQQApA6CKATcDICACQQApA6iKATcDKCACQQApA7CKASIFNwMwIAJBACkDuIoBIgY3AzgCQAJAQQAoAoCOASIHQcAASQ0AIAJBACgCiI4BNgJAIAIgAkHAAGpBACgCmI4BQYCMASAHQX9qQQZ2IANBACgCnI4BIgAQAiADIABqIgBBeWopAwAhCCAAKQMJIQkgACkDGSEKIAApAykhCyAHQcCLAWopAwAhBSAAKQMBIQwgB0HIiwFqKQMAIQYgB0HQiwFqKQMAIQ0gACkDESEOIAdB2IsBaikDACEPIAdB4IsBaikDACEQIAApAyEhESAHQeiLAWopAwAhEiACKQMAIRMgAikDECEUIAIpAyAhFSACKQMwIRYgAikDCCEXIAIpAxghGCACKQMoIRkgAiACKQM4IAdB8IsBaikDACIafCAAKQMxIAdB+IsBaikDACIbhSIcQiCIIBxC/////w+Dfnw3AzggGSAQfCARIBKFIhFCIIggEUL/////D4N+fCERIBggDXwgDiAPhSIOQiCIIA5C/////w+DfnwhDiAXIAV8IAwgBoUiDEIgiCAMQv////8Pg358IQwgGyAWIAsgGoUiC0IgiCALQv////8Pg358fCELIBIgFSAKIBCFIhBCIIggEEL/////D4N+fHwhECAPIBQgCSANhSINQiCIIA1C/////w+Dfnx8IRIgBiATIAggBYUiBUIgiCAFQv////8Pg358fCEIDAELIAdBwI0BaiEdQcAAIAdrIR4gAkHAAGohAAJAAkACQCAHQThNDQAgHiEfDAELAkACQEE4IAdrQQN2QQFqQQdxIh8NACACQcAAaiEAIB4hHwwBCyACQcAAaiEAIB9BA3QiICEfA0AgACAdKQMANwMAIABBCGohACAdQQhqIR0gH0F4aiIfDQALQcAAIAcgIGprIR8LAkAgBw0AA0AgACAdKQMANwMAIABBCGogHUEIaikDADcDACAAQRBqIB1BEGopAwA3AwAgAEEYaiAdQRhqKQMANwMAIABBIGogHUEgaikDADcDACAAQShqIB1BKGopAwA3AwAgAEEwaiAdQTBqKQMANwMAIABBOGogHUE4aikDADcDACAAQcAAaiEAIB1BwABqIR0gH0FAaiIfQQdLDQALCyAfRQ0BCyAfQX9qISECQCAfQQdxIiBFDQAgH0F4cSEfA0AgACAdLQAAOgAAIABBAWohACAdQQFqIR0gIEF/aiIgDQALCyAhQQdJDQADQCAAIB0pAAA3AAAgAEEIaiEAIB1BCGohHSAfQXhqIh8NAAsLIAJBwABqIB5qIR1BgIwBIQACQAJAAkAgB0EISQ0AAkAgB0E4akEDdkEBakEHcSIfDQAMAgsgH0EDdCEgQYCMASEAA0AgHSAAKQMANwMAIB1BCGohHSAAQQhqIQAgH0F/aiIfDQALIAcgIGshBwsgB0UNAQJAAkAgB0EHcSIgDQAgByEfDAELIAdBeHEhHwNAIB0gAC0AADoAACAdQQFqIR0gAEEBaiEAICBBf2oiIA0ACwsgB0EISQ0BCwNAIB0gACkAADcAACAdQQhqIR0gAEEIaiEAIB9BeGoiHw0ACwsgA0EAKAKcjgFqIgBBeWopAwAhCiAAKQMJIRMgACkDGSEUIAApAykhCyAAKQMBIQwgACkDESEOIAApAyEhESACKQMAIRUgAikDECEWIAIpAyAhFyACKQMIIRggAikDQCENIAIpA0ghDyACKQMYIRkgAikDUCESIAIpA1ghCCACKQMoIRogAikDYCEQIAIpA2ghCSACIAYgAikDcCIbfCAAKQMxIAIpA3giBoUiHEIgiCAcQv////8Pg358NwM4IBogEHwgESAJhSIRQiCIIBFC/////w+DfnwhESAZIBJ8IA4gCIUiDkIgiCAOQv////8Pg358IQ4gGCANfCAMIA+FIgxCIIggDEL/////D4N+fCEMIAYgCyAbhSILQiCIIAtC/////w+DfiAFfHwhCyAJIBcgFCAQhSIFQiCIIAVC/////w+Dfnx8IRAgCCAWIBMgEoUiBUIgiCAFQv////8Pg358fCESIA8gFSAKIA2FIgVCIIggBUL/////D4N+fHwhCAsgAykDQyACKQM4hSIFQv////8PgyIGIAMpAzsgC4UiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDMyARhSIFQv////8PgyIGIAMpAysgEIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDIyAOhSIFQv////8PgyIGIAMpAxsgEoUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDEyAMhSIFQv////8PgyIGIAMpAwsgCIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgBEKHla+vmLbem55/fnx8fHwiBEIliCAEhUL5893xmfKZqxZ+IgRCIIggBIUhBAwBCyAEpyEAAkBBACkDoI4BIgRQDQACQCAAQRBLDQAgAEGACCAEEAUhBAwCCwJAIABBgAFLDQAgAEGACCAEEAYhBAwCCyAAQYAIIAQQByEEDAELAkAgAEEQSw0AIAAgA0IAEAUhBAwBCwJAIABBgAFLDQAgACADQgAQBiEEDAELIAAgA0IAEAchBAtBACAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwOACiABJAALBgBBgIoBCwIACwvMAQEAQYAIC8QBuP5sOSOkS758AYEs9yGtHN7UbemDkJfbckCkpLezZx/LeeZOzMDleIJa0H3M/3IhuAhGdPdDJI7gNZDmgTomTDwoUruRwwDLiNBlixtTLqNxZEiXog35TjgZ70ap3qzYqPp2P+OcND/53LvHxwtPHYpR4EvNtFkxyJ9+ydl4c2TqxayDNNPrw8WBoP/6E2PrFw3dUbfw2knTFlUmKdRonisWvlh9R6H8j/i40XrQMc5FyzqPlRYEKK/X+8q7S0B+QAIAAA==";
var hash$6 = "5a2fbdbb";
var wasmJson$6 = {
    name: name$6,
    data: data$6,
    hash: hash$6
};
const mutex$4 = new Mutex();
let wasmCache$4 = null;
const seedBuffer$1 = new Uint8Array(8);
function validateSeed$1(seed) {
    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
    return null;
}
function writeSeed$1(arr, low, high) {
    // write in little-endian format
    const buffer = new DataView(arr);
    buffer.setUint32(0, low, true);
    buffer.setUint32(4, high, true);
}
/**
 * Calculates xxHash3 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param seedLow Lower 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @param seedHigh Higher 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @returns Computed hash as a hexadecimal string
 */ function xxhash3(data, seedLow = 0, seedHigh = 0) {
    if (validateSeed$1(seedLow)) return Promise.reject(validateSeed$1(seedLow));
    if (validateSeed$1(seedHigh)) return Promise.reject(validateSeed$1(seedHigh));
    if (wasmCache$4 === null) return lockedCreate(mutex$4, wasmJson$6, 8).then((wasm)=>{
        wasmCache$4 = wasm;
        writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
        wasmCache$4.writeMemory(seedBuffer$1);
        return wasmCache$4.calculate(data);
    });
    try {
        writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
        wasmCache$4.writeMemory(seedBuffer$1);
        const hash = wasmCache$4.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new xxHash3 hash instance
 * @param seedLow Lower 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @param seedHigh Higher 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 */ function createXXHash3(seedLow = 0, seedHigh = 0) {
    if (validateSeed$1(seedLow)) return Promise.reject(validateSeed$1(seedLow));
    if (validateSeed$1(seedHigh)) return Promise.reject(validateSeed$1(seedHigh));
    return WASMInterface(wasmJson$6, 8).then((wasm)=>{
        const instanceBuffer = new Uint8Array(8);
        writeSeed$1(instanceBuffer.buffer, seedLow, seedHigh);
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.writeMemory(instanceBuffer);
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 512,
            digestSize: 8
        };
        return obj;
    });
}
var name$5 = "xxhash128";
var data$5 = "AGFzbQEAAAABKwdgAAF/YAR/f39/AGAHf39/f39/fwBgA39/fgF+YAR/f39+AGAAAGABfwADDQwAAQIDBAQEBQYFAAUFBAEBAgIGDgJ/AUHAjgULfwBBwAkLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAcLSGFzaF9VcGRhdGUACApIYXNoX0ZpbmFsAAkNSGFzaF9HZXRTdGF0ZQAKDkhhc2hfQ2FsY3VsYXRlAAsKU1RBVEVfU0laRQMBCqBNDAUAQYAKC+QDAw9+AX8BfgJAIANFDQAgACkDMCEEIAApAzghBSAAKQMgIQYgACkDKCEHIAApAxAhCCAAKQMYIQkgACkDACEKIAApAwghCwNAIAUgAUEwaikDACIMfCACQThqKQMAIAFBOGopAwAiDYUiBUIgiCAFQv////8Pg358IQUgByABQSBqKQMAIg58IAJBKGopAwAgAUEoaikDACIPhSIHQiCIIAdC/////w+DfnwhByAJIAFBEGopAwAiEHwgAkEYaikDACABQRhqKQMAIhGFIglCIIggCUL/////D4N+fCEJIAsgASkDACISfCACQQhqIhMpAwAgAUEIaikDACIUhSILQiCIIAtC/////w+DfnwhCyACQTBqKQMAIAyFIgxCIIggDEL/////D4N+IAR8IA18IQQgAkEgaikDACAOhSIMQiCIIAxC/////w+DfiAGfCAPfCEGIAJBEGopAwAgEIUiDEIgiCAMQv////8Pg34gCHwgEXwhCCACKQMAIBKFIgxCIIggDEL/////D4N+IAp8IBR8IQogAUHAAGohASATIQIgA0F/aiIDDQALIAAgCTcDGCAAIAo3AwAgACALNwMIIAAgBzcDKCAAIAg3AxAgACAFNwM4IAAgBjcDICAAIAQ3AzALC94CAgF/AX4CQCAEIAIgASgCACIHayICSQ0AIAAgAyAFIAdBA3RqIAIQASAAIAUgBmoiBykDACAAKQMAIghCL4iFIAiFQrHz3fEJfjcDACAAIAcpAwggACkDCCIIQi+IhSAIhUKx893xCX43AwggACAHKQMQIAApAxAiCEIviIUgCIVCsfPd8Ql+NwMQIAAgBykDGCAAKQMYIghCL4iFIAiFQrHz3fEJfjcDGCAAIAcpAyAgACkDICIIQi+IhSAIhUKx893xCX43AyAgACAHKQMoIAApAygiCEIviIUgCIVCsfPd8Ql+NwMoIAAgBykDMCAAKQMwIghCL4iFIAiFQrHz3fEJfjcDMCAAIAcpAzggACkDOCIIQi+IhSAIhUKx893xCX43AzggACADIAJBBnRqIAUgBCACayIHEAEgASAHNgIADwsgACADIAUgB0EDdGogBBABIAEgByAEajYCAAvtAwEFfiABKQM4IAApAziFIgNC/////w+DIgQgASkDMCAAKQMwhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMoIAApAyiFIgNC/////w+DIgQgASkDICAAKQMghSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMYIAApAxiFIgNC/////w+DIgQgASkDECAAKQMQhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMIIAApAwiFIgNC/////w+DIgQgASkDACAAKQMAhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSACfHx8fCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQu6CAIFfgN/AkAgAUEJSQ0AIAAgAUH4iwFqKQMAIgQgAikDOCACKQMwhSADfIUiBUL/////D4NC95Svrwh+IAVCgICAgHCDfEEAKQOAjAEgAikDKCACKQMghSADfYUgBIUiA0IgiCIEQrHz3fEJfnwgBEKHla+vCH4iBEIgiHwgBEL/////D4MgA0L/////D4MiA0Kx893xCX58IANCh5Wvrwh+IgRCIIh8IgVCIIh8IgNCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQgBEL/////D4MgAUF/aq1CNoaEIAVCIIZ8hSIEQiCIIgVCz9bTvgJ+IgZC/////w+DIARC/////w+DIgRCvdzKlQx+fCAEQs/W074CfiIEQiCIfCIHQiCGIghCJYggCCAEQv////8Pg4SFQvnz3fGZ8pmrFn4iBEIgiCAEhTcDACAAIAVCvdzKlQx+IANCz9bTvtLHq9lCfnwgBkIgiHwgB0IgiHwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4U3AwgPCwJAIAFBBEkNACAAIAIpAxggAikDEIUgA6ciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnKtQiCGIAOFfCABQfyLAWo1AgBCIIZBADUCgIwBhIUiA0IgiCIEIAFBAnRBh5Wvr3hqrSIFfiIGQiCIIARCsfPd8Ql+fCAGQv////8PgyADQv////8PgyIDQrHz3fEJfnwgAyAFfiIDQiCIfCIEQiCIfCAEQiCGIANC/////w+DhCIEQgGGfCIDQiWIIAOFQvnz3fGZ8pmrFn4iBUIgiCAFhTcDCCAAIANCA4ggBIUiA0IjiCADhUKlvuP00YyH2Z9/fiIDQhyIIAOFNwMADwsCQCABRQ0AIAAgAigCBCACKAIAc60gA3wiBEIhiEEALQCAjAFBEHQgAUEIdHIiCSABQQF2QYCMAWotAABBGHRyIgogAUH/iwFqLQAAIgFyIguthSAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMAIAAgAigCDCACKAIIc60gA30iA0IhiCABQRh0IAtBgP4DcUEIdHIgCUEIdkGA/gNxIApBGHZyckENd62FIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwgPCyAAIAIpA1AgAikDWIUgA4UiBEIhiCAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMIIAAgAikDQCACKQNIhSADhSIDQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwALwwoBCn4gAa0iBEKHla+vmLbem55/fiEFAkACQCABQSFPDQBCACEGDAELQgAhBwJAIAFBwQBJDQBCACEHAkAgAUHhAEkNACACQfgAaikDACADfSABQciLAWopAwAiCIUiB0L/////D4MiCSACKQNwIAN8IAFBwIsBaikDACIKhSILQiCIIgx+Ig1CIIggB0IgiCIHIAx+fCANQv////8PgyAHIAtC/////w+DIgt+fCAJIAt+IgdCIIh8IglCIIh8QQApA7iMASILQQApA7CMASIMfIUgCUIghiAHQv////8Pg4SFIQcgAkHoAGopAwAgA30gC4UiCUL/////D4MiCyACKQNgIAN8IAyFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCALIAx+IgtCIIh8IgxCIIYgC0L/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAV8IAggCnyFIQULIAJB2ABqKQMAIAN9IAFB2IsBaikDACIIhSIJQv////8PgyIKIAIpA1AgA3wgAUHQiwFqKQMAIguFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCAKIAx+IgpCIIh8IgxCIIYgCkL/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAd8QQApA6iMASIJQQApA6CMASIKfIUhByACQcgAaikDACADfSAJhSIJQv////8PgyIMIAIpA0AgA3wgCoUiCkIgiCINfiIGQv////8PgyAJQiCIIgkgCkL/////D4MiCn58IAwgCn4iCkIgiHwiDEIghiAKQv////8Pg4QgBkIgiCAJIA1+fCAMQiCIfIUgBXwgCCALfIUhBQsgAkE4aikDACADfSABQeiLAWopAwAiCIUiCUL/////D4MiCiACKQMwIAN8IAFB4IsBaikDACILhSIMQiCIIg1+IgZC/////w+DIAlCIIgiCSAMQv////8PgyIMfnwgCiAMfiIKQiCIfCIMQiCGIApC/////w+DhCAGQiCIIAkgDX58IAxCIIh8hSAHfEEAKQOYjAEiB0EAKQOQjAEiCXyFIQYgAkEoaikDACADfSAHhSIHQv////8PgyIKIAIpAyAgA3wgCYUiCUIgiCIMfiINQv////8PgyAHQiCIIgcgCUL/////D4MiCX58IAogCX4iCUIgiHwiCkIghiAJQv////8Pg4QgDUIgiCAHIAx+fCAKQiCIfIUgBXwgCCALfIUhBQsgACACQRhqKQMAIAN9IAFB+IsBaikDACIHhSIIQv////8PgyIJIAIpAxAgA3wgAUHwiwFqKQMAIgqFIgtCIIgiDH4iDUL/////D4MgCEIgiCIIIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAZ8QQApA4iMASIIQQApA4CMASIJfIUiCyACQQhqKQMAIAN9IAiFIghC/////w+DIgwgAikDACADfCAJhSIJQiCIIg1+IgZC/////w+DIAhCIIgiCCAJQv////8PgyIJfnwgDCAJfiIJQiCIfCIMQiCGIAlC/////w+DhCAGQiCIIAggDX58IAxCIIh8hSAFfCAHIAp8hSIFfCIHQiWIIAeFQvnz3fGZ8pmrFn4iB0IgiCAHhTcDACAAQgAgBUKHla+vmLbem55/fiAEIAN9Qs/W077Sx6vZQn58IAtC49zKlfzO8vWFf358IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFfTcDCAuhDwMBfxR+An9BACEEIAJB+ABqKQMAIAN9QQApA/iMASIFhSIGQv////8PgyIHIAIpA3AgA3xBACkD8IwBIgiFIglCIIgiCn4iC0L/////D4MgBkIgiCIGIAlC/////w+DIgl+fCAHIAl+IgdCIIh8IglCIIYgB0L/////D4OEIAtCIIggBiAKfnwgCUIgiHyFIAJB2ABqKQMAIAN9QQApA9iMASIHhSIGQv////8PgyIJIAIpA1AgA3xBACkD0IwBIgqFIgtCIIgiDH4iDUL/////D4MgBkIgiCIGIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAJBOGopAwAgA31BACkDuIwBIgmFIgZC/////w+DIgsgAikDMCADfEEAKQOwjAEiDIUiDUIgiCIOfiIPQv////8PgyAGQiCIIgYgDUL/////D4MiDX58IAsgDX4iC0IgiHwiDUIghiALQv////8Pg4QgD0IgiCAGIA5+fCANQiCIfIUgAkEYaikDACADfUEAKQOYjAEiC4UiBkL/////D4MiDSACKQMQIAN8QQApA5CMASIOhSIPQiCIIhB+IhFC/////w+DIAZCIIgiBiAPQv////8PgyIPfnwgDSAPfiINQiCIfCIPQiCGIA1C/////w+DhCARQiCIIAYgEH58IA9CIIh8hUEAKQOIjAEiDUEAKQOAjAEiD3yFfEEAKQOojAEiEEEAKQOgjAEiEXyFfEEAKQPIjAEiEkEAKQPAjAEiE3yFfEEAKQPojAEiFEEAKQPgjAEiFXyFIgZCJYggBoVC+fPd8ZnymasWfiIGQiCIIAaFIQYgAkHoAGopAwAgA30gFIUiFEL/////D4MiFiACKQNgIAN8IBWFIhVCIIgiF34iGEL/////D4MgFEIgiCIUIBVC/////w+DIhV+fCAWIBV+IhVCIIh8IhZCIIYgFUL/////D4OEIBhCIIggFCAXfnwgFkIgiHyFIAJByABqKQMAIAN9IBKFIhJC/////w+DIhQgAikDQCADfCAThSITQiCIIhV+IhZC/////w+DIBJCIIgiEiATQv////8PgyITfnwgFCATfiITQiCIfCIUQiCGIBNC/////w+DhCAWQiCIIBIgFX58IBRCIIh8hSACQShqKQMAIAN9IBCFIhBC/////w+DIhIgAikDICADfCARhSIRQiCIIhN+IhRC/////w+DIBBCIIgiECARQv////8PgyIRfnwgEiARfiIRQiCIfCISQiCGIBFC/////w+DhCAUQiCIIBAgE358IBJCIIh8hSACQQhqKQMAIAN9IA2FIg1C/////w+DIhAgAikDACADfCAPhSIPQiCIIhF+IhJC/////w+DIA1CIIgiDSAPQv////8PgyIPfnwgECAPfiIPQiCIfCIQQiCGIA9C/////w+DhCASQiCIIA0gEX58IBBCIIh8hSABrSIPQoeVr6+Ytt6bnn9+fCALIA58hXwgCSAMfIV8IAcgCnyFfCAFIAh8hSIFQiWIIAWFQvnz3fGZ8pmrFn4iBUIgiCAFhSEFAkAgAUGgAUgNACABQQV2QXxqIRkDQCACIARqIhpBG2opAwAgA30gBEGYjQFqKQMAIgeFIghC/////w+DIgkgGkETaikDACADfCAEQZCNAWopAwAiCoUiC0IgiCIMfiINQv////8PgyAIQiCIIgggC0L/////D4MiC358IAkgC34iCUIgiHwiC0IghiAJQv////8Pg4QgDUIgiCAIIAx+fCALQiCIfIUgBnwgBEGIjQFqKQMAIgggBEGAjQFqKQMAIgl8hSEGIBpBC2opAwAgA30gCIUiCEL/////D4MiCyAaQQNqKQMAIAN8IAmFIglCIIgiDH4iDUL/////D4MgCEIgiCIIIAlC/////w+DIgl+fCALIAl+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAV8IAcgCnyFIQUgBEEgaiEEIBlBf2oiGQ0ACwsgACACQf8AaikDACADfCABQeiLAWopAwAiB4UiCEL/////D4MiCSACKQN3IAN9IAFB4IsBaikDACIKhSILQiCIIgx+Ig1C/////w+DIAhCIIgiCCALQv////8PgyILfnwgCSALfiIJQiCIfCILQiCGIAlC/////w+DhCANQiCIIAggDH58IAtCIIh8hSAGfCABQfiLAWopAwAiBiABQfCLAWopAwAiCHyFIgkgAkHvAGopAwAgA3wgBoUiBkL/////D4MiCyACKQNnIAN9IAiFIghCIIgiDH4iDUL/////D4MgBkIgiCIGIAhC/////w+DIgh+fCALIAh+IghCIIh8IgtCIIYgCEL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAV8IAcgCnyFIgZ8IgVCJYggBYVC+fPd8ZnymasWfiIFQiCIIAWFNwMAIABCACAGQoeVr6+Ytt6bnn9+IA8gA31Cz9bTvtLHq9lCfnwgCULj3MqV/M7y9YV/fnwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4V9NwMIC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAAfTcDqIsBQQAgAEKo9dv7s5ynmj98NwOgiwFBAEK4sry3lNW31lggAH03A5iLAUEAIABC8cihuqm0w/zOAHw3A5CLAUEAQoihl9u445SXo38gAH03A4iL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AkHAAGogDGohC0GAjAEhAAJAAkACQCAHQQhJDQACQCAHQThqQQN2QQFqQQdxIg0NAAwCCyANQQN0IQ5BgIwBIQADQCALIAApAwA3AwAgC0EIaiELIABBCGohACANQX9qIg0NAAsgByAOayEHCyAHRQ0BAkACQCAHQQdxIg4NACAHIQ0MAQsgB0F4cSENA0AgCyAALQAAOgAAIAtBAWohCyAAQQFqIQAgDkF/aiIODQALCyAHQQhJDQELA0AgCyAAKQAANwAAIAtBCGohCyAAQQhqIQAgDUF4aiINDQALCyACIAIpAwggAikDQCIIfCADQQAoApyOAWoiACkDASACKQNIIgmFIgpCIIggCkL/////D4N+fDcDCCACIAIpAxggAikDUCIKfCAAKQMRIAIpA1giEIUiEUIgiCARQv////8Pg358NwMYIAIgECAKIAApAwmFIgpCIIggCkL/////D4N+IAIpAxB8fDcDECACIAkgCCAAQXlqKQMAhSIIQiCIIAhC/////w+DfiACKQMAfHw3AwAgACkDGSEIIAIpAyAhCSACIAIpAyggAikDYCIKfCAAKQMhIAIpA2giEIUiEUIgiCARQv////8Pg358NwMoIAIgECAJIAggCoUiCEIgiCAIQv////8Pg358fDcDICACIAYgAikDcCIIfCAAKQMxIAIpA3giBoUiCUIgiCAJQv////8Pg358NwM4IAIgBiAIIAApAymFIghCIIggCEL/////D4N+IAV8fDcDMAsgAiACIANBC2ogBEKHla+vmLbem55/fhADNwNAIAIgAiADQQAoApyOAWpBdWogBELP1tO+0ser2UJ+Qn+FEAM3A0gMAQsgBKchAAJAQQApA6COASIEUA0AAkAgAEEQSw0AIAJBwABqIABBgAggBBAEDAILAkAgAEGAAUsNACACQcAAaiAAQYAIIAQQBQwCCyACQcAAaiAAQYAIIAQQBgwBCwJAIABBEEsNACACQcAAaiAAIANCABAEDAELAkAgAEGAAUsNACACQcAAaiAAIANCABAFDAELIAJBwABqIAAgA0IAEAYLQQAgAikDcDcDuApBACACKQNgNwOoCkEAIAIpA1A3A5gKQQAgAkH4AGopAwA3A8AKQQAgAkHoAGopAwA3A7AKQQAgAkHYAGopAwA3A6AKQQAgAikDSCIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIgQ3A4AKQQAgBDcDkApBACACKQNAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQ3A4gKIAEkAAsGAEGAigELAgALC8wBAQBBgAgLxAG4/mw5I6RLvnwBgSz3Ia0c3tRt6YOQl9tyQKSkt7NnH8t55k7MwOV4glrQfcz/ciG4CEZ090MkjuA1kOaBOiZMPChSu5HDAMuI0GWLG1Muo3FkSJeiDflOOBnvRqnerNio+nY/45w0P/ncu8fHC08dilHgS820WTHIn37J2XhzZOrFrIM00+vDxYGg//oTY+sXDd1Rt/DaSdMWVSYp1GieKxa+WH1HofyP+LjRetAxzkXLOo+VFgQor9f7yrtLQH5AAgAA";
var hash$5 = "b9ab74e2";
var wasmJson$5 = {
    name: name$5,
    data: data$5,
    hash: hash$5
};
const mutex$3 = new Mutex();
let wasmCache$3 = null;
const seedBuffer = new Uint8Array(8);
function validateSeed(seed) {
    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
    return null;
}
function writeSeed(arr, low, high) {
    // write in little-endian format
    const buffer = new DataView(arr);
    buffer.setUint32(0, low, true);
    buffer.setUint32(4, high, true);
}
/**
 * Calculates xxHash128 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @param seedLow Lower 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @param seedHigh Higher 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @returns Computed hash as a hexadecimal string
 */ function xxhash128(data, seedLow = 0, seedHigh = 0) {
    if (validateSeed(seedLow)) return Promise.reject(validateSeed(seedLow));
    if (validateSeed(seedHigh)) return Promise.reject(validateSeed(seedHigh));
    if (wasmCache$3 === null) return lockedCreate(mutex$3, wasmJson$5, 16).then((wasm)=>{
        wasmCache$3 = wasm;
        writeSeed(seedBuffer.buffer, seedLow, seedHigh);
        wasmCache$3.writeMemory(seedBuffer);
        return wasmCache$3.calculate(data);
    });
    try {
        writeSeed(seedBuffer.buffer, seedLow, seedHigh);
        wasmCache$3.writeMemory(seedBuffer);
        const hash = wasmCache$3.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new xxHash128 hash instance
 * @param seedLow Lower 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 * @param seedHigh Higher 32 bits of the number used to
 *  initialize the internal state of the algorithm (defaults to 0)
 */ function createXXHash128(seedLow = 0, seedHigh = 0) {
    if (validateSeed(seedLow)) return Promise.reject(validateSeed(seedLow));
    if (validateSeed(seedHigh)) return Promise.reject(validateSeed(seedHigh));
    return WASMInterface(wasmJson$5, 16).then((wasm)=>{
        const instanceBuffer = new Uint8Array(8);
        writeSeed(instanceBuffer.buffer, seedLow, seedHigh);
        wasm.writeMemory(instanceBuffer);
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.writeMemory(instanceBuffer);
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 512,
            digestSize: 16
        };
        return obj;
    });
}
var name$4 = "ripemd160";
var data$4 = "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";
var hash$4 = "6abbce74";
var wasmJson$4 = {
    name: name$4,
    data: data$4,
    hash: hash$4
};
const mutex$2 = new Mutex();
let wasmCache$2 = null;
/**
 * Calculates RIPEMD-160 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function ripemd160(data) {
    if (wasmCache$2 === null) return lockedCreate(mutex$2, wasmJson$4, 20).then((wasm)=>{
        wasmCache$2 = wasm;
        return wasmCache$2.calculate(data);
    });
    try {
        const hash = wasmCache$2.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new RIPEMD-160 hash instance
 */ function createRIPEMD160() {
    return WASMInterface(wasmJson$4, 20).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 20
        };
        return obj;
    });
}
function calculateKeyBuffer(hasher, key) {
    const { blockSize } = hasher;
    const buf = getUInt8Buffer(key);
    if (buf.length > blockSize) {
        hasher.update(buf);
        const uintArr = hasher.digest("binary");
        hasher.init();
        return uintArr;
    }
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
}
function calculateHmac(hasher, key) {
    hasher.init();
    const { blockSize } = hasher;
    const keyBuf = calculateKeyBuffer(hasher, key);
    const keyBuffer = new Uint8Array(blockSize);
    keyBuffer.set(keyBuf);
    const opad = new Uint8Array(blockSize);
    for(let i = 0; i < blockSize; i++){
        const v = keyBuffer[i];
        opad[i] = v ^ 0x5c;
        keyBuffer[i] = v ^ 0x36;
    }
    hasher.update(keyBuffer);
    const obj = {
        init: ()=>{
            hasher.init();
            hasher.update(keyBuffer);
            return obj;
        },
        update: (data)=>{
            hasher.update(data);
            return obj;
        },
        digest: (outputType)=>{
            const uintArr = hasher.digest("binary");
            hasher.init();
            hasher.update(opad);
            hasher.update(uintArr);
            return hasher.digest(outputType);
        // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
        },
        save: ()=>{
            throw new Error("save() not supported");
        },
        load: ()=>{
            throw new Error("load() not supported");
        },
        blockSize: hasher.blockSize,
        digestSize: hasher.digestSize
    };
    return obj;
}
/**
 * Calculates HMAC hash
 * @param hash Hash algorithm to use. It has to be the return value of a function like createSHA1()
 * @param key Key (string, Buffer or TypedArray)
 */ function createHMAC(hash, key) {
    if (!hash || !hash.then) throw new Error('Invalid hash function is provided! Usage: createHMAC(createMD5(), "key").');
    return hash.then((hasher)=>calculateHmac(hasher, key));
}
function calculatePBKDF2(digest, salt, iterations, hashLength, outputType) {
    return __awaiter(this, void 0, void 0, function*() {
        const DK = new Uint8Array(hashLength);
        const block1 = new Uint8Array(salt.length + 4);
        const block1View = new DataView(block1.buffer);
        const saltBuffer = getUInt8Buffer(salt);
        const saltUIntBuffer = new Uint8Array(saltBuffer.buffer, saltBuffer.byteOffset, saltBuffer.length);
        block1.set(saltUIntBuffer);
        let destPos = 0;
        const hLen = digest.digestSize;
        const l = Math.ceil(hashLength / hLen);
        let T = null;
        let U = null;
        for(let i = 1; i <= l; i++){
            block1View.setUint32(salt.length, i);
            digest.init();
            digest.update(block1);
            T = digest.digest("binary");
            U = T.slice();
            for(let j = 1; j < iterations; j++){
                digest.init();
                digest.update(U);
                U = digest.digest("binary");
                for(let k = 0; k < hLen; k++)T[k] ^= U[k];
            }
            DK.set(T.subarray(0, hashLength - destPos), destPos);
            destPos += hLen;
        }
        if (outputType === "binary") return DK;
        const digestChars = new Uint8Array(hashLength * 2);
        return getDigestHex(digestChars, DK, hashLength);
    });
}
const validateOptions$2 = (options)=>{
    if (!options || typeof options !== "object") throw new Error("Invalid options parameter. It requires an object.");
    if (!options.hashFunction || !options.hashFunction.then) throw new Error('Invalid hash function is provided! Usage: pbkdf2("password", "salt", 1000, 32, createSHA1()).');
    if (!Number.isInteger(options.iterations) || options.iterations < 1) throw new Error("Iterations should be a positive number");
    if (!Number.isInteger(options.hashLength) || options.hashLength < 1) throw new Error("Hash length should be a positive number");
    if (options.outputType === undefined) options.outputType = "hex";
    if (![
        "hex",
        "binary"
    ].includes(options.outputType)) throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
};
/**
 * Generates a new PBKDF2 hash for the supplied password
 */ function pbkdf2(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateOptions$2(options);
        const hmac = yield createHMAC(options.hashFunction, options.password);
        return calculatePBKDF2(hmac, options.salt, options.iterations, options.hashLength, options.outputType);
    });
}
var name$3 = "scrypt";
var data$3 = "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cyICajYCOCAAIAAoAjwgAiAKakESdyAGc2o2AjwLvxIDFX8Bfg5/AkAgAkUNACAAQQd0IgNBQGoiBEEAKAKACCIFIAMgAmwiBmogAyABbGoiByADaiIIaiEJIAAgAkEHdCIKIAFBB3RqIgtsIQwgACALQYABamwhDSAAQQV0IgtBASALQQFLGyILQWBxIQ4gC0EBcSEPIAdBeGohECAHQXBqIREgB0FoaiESIAdBYGohEyAHQVhqIRQgB0FQaiEVIAdBSGohFiAHQUBqIRcgAa1Cf3whGCAEIAdqIRkgByAAQQh0IhpqIRsgACAKQYABamwhHCALQQRJIR1BACEeQQAhHwNAQQAoAoAIIiAgAyAfbGohIQJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgByALaiIEICMgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AIAcgIkECdCILaiAhIAtqKAIANgIACwJAIAFFDQBBACElIBwhIyAGISYDQCAFISQgACEiAkACQCAADQAgGyAXKQMANwMAIBsgFikDADcDCCAbIBUpAwA3AxAgGyAUKQMANwMYIBsgEykDADcDICAbIBIpAwA3AyggGyARKQMANwMwIBsgECkDADcDOAwBCwNAICQgJmoiCyAkIAxqIgQpAwA3AwAgC0EIaiAEQQhqKQMANwMAIAtBEGogBEEQaikDADcDACALQRhqIARBGGopAwA3AwAgC0EgaiAEQSBqKQMANwMAIAtBKGogBEEoaikDADcDACALQTBqIARBMGopAwA3AwAgC0E4aiAEQThqKQMANwMAIAtBwABqIARBwABqKQMANwMAIAtByABqIARByABqKQMANwMAIAtB0ABqIARB0ABqKQMANwMAIAtB2ABqIARB2ABqKQMANwMAIAtB4ABqIARB4ABqKQMANwMAIAtB6ABqIARB6ABqKQMANwMAIAtB8ABqIARB8ABqKQMANwMAIAtB+ABqIARB+ABqKQMANwMAICRBgAFqISQgIkF/aiIiDQALIAcgCCAbIAAQAiAFISQgACEiA0AgJCAjaiILICQgDWoiBCkDADcDACALQQhqIARBCGopAwA3AwAgC0EQaiAEQRBqKQMANwMAIAtBGGogBEEYaikDADcDACALQSBqIARBIGopAwA3AwAgC0EoaiAEQShqKQMANwMAIAtBMGogBEEwaikDADcDACALQThqIARBOGopAwA3AwAgC0HAAGogBEHAAGopAwA3AwAgC0HIAGogBEHIAGopAwA3AwAgC0HQAGogBEHQAGopAwA3AwAgC0HYAGogBEHYAGopAwA3AwAgC0HgAGogBEHgAGopAwA3AwAgC0HoAGogBEHoAGopAwA3AwAgC0HwAGogBEHwAGopAwA3AwAgC0H4AGogBEH4AGopAwA3AwAgJEGAAWohJCAiQX9qIiINAAsLIAggByAbIAAQAiAjIBpqISMgJiAaaiEmICVBAmoiJSABSQ0AC0EAISUDQAJAAkAgAA0AIBsgFykDADcDACAbIBYpAwA3AwggGyAVKQMANwMQIBsgFCkDADcDGCAbIBMpAwA3AyAgGyASKQMANwMoIBsgESkDADcDMCAbIBApAwA3AzgMAQsgACAKIBkpAgAgGIOnQQd0amwhJiAFISQgACEiA0AgJCAMaiILIAspAwAgJCAmaiIEKQMAhTcDACALQQhqIiMgIykDACAEQQhqKQMAhTcDACALQRBqIiMgIykDACAEQRBqKQMAhTcDACALQRhqIiMgIykDACAEQRhqKQMAhTcDACALQSBqIiMgIykDACAEQSBqKQMAhTcDACALQShqIiMgIykDACAEQShqKQMAhTcDACALQTBqIiMgIykDACAEQTBqKQMAhTcDACALQThqIiMgIykDACAEQThqKQMAhTcDACALQcAAaiIjICMpAwAgBEHAAGopAwCFNwMAIAtByABqIiMgIykDACAEQcgAaikDAIU3AwAgC0HQAGoiIyAjKQMAIARB0ABqKQMAhTcDACALQdgAaiIjICMpAwAgBEHYAGopAwCFNwMAIAtB4ABqIiMgIykDACAEQeAAaikDAIU3AwAgC0HoAGoiIyAjKQMAIARB6ABqKQMAhTcDACALQfAAaiIjICMpAwAgBEHwAGopAwCFNwMAIAtB+ABqIgsgCykDACAEQfgAaikDAIU3AwAgJEGAAWohJCAiQX9qIiINAAsgByAIIBsgABACIAAgCiAJKQIAIBiDp0EHdGpsISYgBSEkIAAhIgNAICQgDWoiCyALKQMAICQgJmoiBCkDAIU3AwAgC0EIaiIjICMpAwAgBEEIaikDAIU3AwAgC0EQaiIjICMpAwAgBEEQaikDAIU3AwAgC0EYaiIjICMpAwAgBEEYaikDAIU3AwAgC0EgaiIjICMpAwAgBEEgaikDAIU3AwAgC0EoaiIjICMpAwAgBEEoaikDAIU3AwAgC0EwaiIjICMpAwAgBEEwaikDAIU3AwAgC0E4aiIjICMpAwAgBEE4aikDAIU3AwAgC0HAAGoiIyAjKQMAIARBwABqKQMAhTcDACALQcgAaiIjICMpAwAgBEHIAGopAwCFNwMAIAtB0ABqIiMgIykDACAEQdAAaikDAIU3AwAgC0HYAGoiIyAjKQMAIARB2ABqKQMAhTcDACALQeAAaiIjICMpAwAgBEHgAGopAwCFNwMAIAtB6ABqIiMgIykDACAEQegAaikDAIU3AwAgC0HwAGoiIyAjKQMAIARB8ABqKQMAhTcDACALQfgAaiILIAspAwAgBEH4AGopAwCFNwMAICRBgAFqISQgIkF/aiIiDQALCyAIIAcgGyAAEAIgJUECaiIlIAFJDQALCwJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgIyALaiIEIAcgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AICEgIkECdCILaiAHIAtqKAIANgIACyAeIANqIR4gH0EBaiIfIAJHDQALCws=";
var hash$3 = "b32721f8";
var wasmJson$3 = {
    name: name$3,
    data: data$3,
    hash: hash$3
};
function scryptInternal(options) {
    return __awaiter(this, void 0, void 0, function*() {
        const { costFactor, blockSize, parallelism, hashLength } = options;
        const SHA256Hasher = createSHA256();
        const blockData = yield pbkdf2({
            password: options.password,
            salt: options.salt,
            iterations: 1,
            hashLength: 128 * blockSize * parallelism,
            hashFunction: SHA256Hasher,
            outputType: "binary"
        });
        const scryptInterface = yield WASMInterface(wasmJson$3, 0);
        // last block is for storing the temporary vectors
        const VSize = 128 * blockSize * costFactor;
        const XYSize = 256 * blockSize;
        scryptInterface.setMemorySize(blockData.length + VSize + XYSize);
        scryptInterface.writeMemory(blockData, 0);
        // mix blocks
        scryptInterface.getExports().scrypt(blockSize, costFactor, parallelism);
        const expensiveSalt = scryptInterface.getMemory().subarray(0, 128 * blockSize * parallelism);
        const outputData = yield pbkdf2({
            password: options.password,
            salt: expensiveSalt,
            iterations: 1,
            hashLength,
            hashFunction: SHA256Hasher,
            outputType: "binary"
        });
        if (options.outputType === "hex") {
            const digestChars = new Uint8Array(hashLength * 2);
            return getDigestHex(digestChars, outputData, hashLength);
        }
        // return binary format
        return outputData;
    });
}
const isPowerOfTwo = (v)=>v && !(v & v - 1);
const validateOptions$1 = (options)=>{
    if (!options || typeof options !== "object") throw new Error("Invalid options parameter. It requires an object.");
    if (!Number.isInteger(options.blockSize) || options.blockSize < 1) throw new Error("Block size should be a positive number");
    if (!Number.isInteger(options.costFactor) || options.costFactor < 2 || !isPowerOfTwo(options.costFactor)) throw new Error("Cost factor should be a power of 2, greater than 1");
    if (!Number.isInteger(options.parallelism) || options.parallelism < 1) throw new Error("Parallelism should be a positive number");
    if (!Number.isInteger(options.hashLength) || options.hashLength < 1) throw new Error("Hash length should be a positive number.");
    if (options.outputType === undefined) options.outputType = "hex";
    if (![
        "hex",
        "binary"
    ].includes(options.outputType)) throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
};
/**
 * Calculates hash using the scrypt password-based key derivation function
 * @returns Computed hash as a hexadecimal string or as
 *          Uint8Array depending on the outputType option
 */ function scrypt(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateOptions$1(options);
        return scryptInternal(options);
    });
}
var name$2 = "bcrypt";
var data$2 = "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";
var hash$2 = "8bd8822d";
var wasmJson$2 = {
    name: name$2,
    data: data$2,
    hash: hash$2
};
function bcryptInternal(options) {
    return __awaiter(this, void 0, void 0, function*() {
        const { costFactor, password, salt } = options;
        const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
        bcryptInterface.writeMemory(getUInt8Buffer(salt), 0);
        const passwordBuffer = getUInt8Buffer(password);
        bcryptInterface.writeMemory(passwordBuffer, 16);
        const shouldEncode = options.outputType === "encoded" ? 1 : 0;
        bcryptInterface.getExports().bcrypt(passwordBuffer.length, costFactor, shouldEncode);
        const memory = bcryptInterface.getMemory();
        if (options.outputType === "encoded") return intArrayToString(memory, 60);
        if (options.outputType === "hex") {
            const digestChars = new Uint8Array(48);
            return getDigestHex(digestChars, memory, 24);
        }
        // return binary format
        // the data is copied to allow GC of the original memory buffer
        return memory.slice(0, 24);
    });
}
const validateOptions = (options)=>{
    if (!options || typeof options !== "object") throw new Error("Invalid options parameter. It requires an object.");
    if (!Number.isInteger(options.costFactor) || options.costFactor < 4 || options.costFactor > 31) throw new Error("Cost factor should be a number between 4 and 31");
    options.password = getUInt8Buffer(options.password);
    if (options.password.length < 1) throw new Error("Password should be at least 1 byte long");
    if (options.password.length > 72) throw new Error("Password should be at most 72 bytes long");
    options.salt = getUInt8Buffer(options.salt);
    if (options.salt.length !== 16) throw new Error("Salt should be 16 bytes long");
    if (options.outputType === undefined) options.outputType = "encoded";
    if (![
        "hex",
        "binary",
        "encoded"
    ].includes(options.outputType)) throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
};
/**
 * Calculates hash using the bcrypt password-hashing function
 * @returns Computed hash
 */ function bcrypt(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateOptions(options);
        return bcryptInternal(options);
    });
}
const validateHashCharacters = (hash)=>{
    if (!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(hash)) return false;
    if (hash[4] === "0" && Number(hash[5]) < 4) return false;
    if (hash[4] === "3" && Number(hash[5]) > 1) return false;
    return true;
};
const validateVerifyOptions = (options)=>{
    if (!options || typeof options !== "object") throw new Error("Invalid options parameter. It requires an object.");
    if (options.hash === undefined || typeof options.hash !== "string") throw new Error("Hash should be specified");
    if (options.hash.length !== 60) throw new Error("Hash should be 60 bytes long");
    if (!validateHashCharacters(options.hash)) throw new Error("Invalid hash");
    options.password = getUInt8Buffer(options.password);
    if (options.password.length < 1) throw new Error("Password should be at least 1 byte long");
    if (options.password.length > 72) throw new Error("Password should be at most 72 bytes long");
};
/**
 * Verifies password using bcrypt password-hashing function
 * @returns True if the encoded hash matches the password
 */ function bcryptVerify(options) {
    return __awaiter(this, void 0, void 0, function*() {
        validateVerifyOptions(options);
        const { hash, password } = options;
        const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
        bcryptInterface.writeMemory(getUInt8Buffer(hash), 0);
        const passwordBuffer = getUInt8Buffer(password);
        bcryptInterface.writeMemory(passwordBuffer, 60);
        return !!bcryptInterface.getExports().bcrypt_verify(passwordBuffer.length);
    });
}
var name$1 = "whirlpool";
var data$1 = "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";
var hash$1 = "8d8f6035";
var wasmJson$1 = {
    name: name$1,
    data: data$1,
    hash: hash$1
};
const mutex$1 = new Mutex();
let wasmCache$1 = null;
/**
 * Calculates Whirlpool hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function whirlpool(data) {
    if (wasmCache$1 === null) return lockedCreate(mutex$1, wasmJson$1, 64).then((wasm)=>{
        wasmCache$1 = wasm;
        return wasmCache$1.calculate(data);
    });
    try {
        const hash = wasmCache$1.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new Whirlpool hash instance
 */ function createWhirlpool() {
    return WASMInterface(wasmJson$1, 64).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 64
        };
        return obj;
    });
}
var name = "sm3";
var data = "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";
var hash = "b6fb4b8e";
var wasmJson = {
    name: name,
    data: data,
    hash: hash
};
const mutex = new Mutex();
let wasmCache = null;
/**
 * Calculates SM3 hash
 * @param data Input data (string, Buffer or TypedArray)
 * @returns Computed hash as a hexadecimal string
 */ function sm3(data) {
    if (wasmCache === null) return lockedCreate(mutex, wasmJson, 32).then((wasm)=>{
        wasmCache = wasm;
        return wasmCache.calculate(data);
    });
    try {
        const hash = wasmCache.calculate(data);
        return Promise.resolve(hash);
    } catch (err) {
        return Promise.reject(err);
    }
}
/**
 * Creates a new SM3 hash instance
 */ function createSM3() {
    return WASMInterface(wasmJson, 32).then((wasm)=>{
        wasm.init();
        const obj = {
            init: ()=>{
                wasm.init();
                return obj;
            },
            update: (data)=>{
                wasm.update(data);
                return obj;
            },
            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            digest: (outputType)=>wasm.digest(outputType),
            save: ()=>wasm.save(),
            load: (data)=>{
                wasm.load(data);
                return obj;
            },
            blockSize: 64,
            digestSize: 32
        };
        return obj;
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"5uiZs":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Random = void 0;
class Random {
    /**
     * Returns `count` cryptographically secure random bytes
     */ static getBytes(count) {
        const out = new Uint8Array(count);
        globalThis.crypto.getRandomValues(out);
        return out;
    }
}
exports.Random = Random;

},{}],"20zbp":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Ripemd160 = void 0;
exports.ripemd160 = ripemd160;
const legacy_js_1 = require("f452d3c69fe715a1");
const utils_1 = require("961036af405dd278");
class Ripemd160 {
    blockSize = 64;
    impl = legacy_js_1.ripemd160.create();
    constructor(firstData){
        if (firstData) this.update(firstData);
    }
    update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
    }
    digest() {
        return this.impl.digest();
    }
}
exports.Ripemd160 = Ripemd160;
/** Convenience function equivalent to `new Ripemd160(data).digest()` */ function ripemd160(data) {
    return new Ripemd160(data).digest();
}

},{"f452d3c69fe715a1":"latsQ","961036af405dd278":"7UmIW"}],"latsQ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
/**

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
 * @module
 */ const _md_ts_1 = require("2f20739411ceab2");
const utils_ts_1 = require("608dba3c6b412388");
/** Initial SHA1 state */ const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
    0xc3d2e1f0
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
/** SHA1 legacy hash class. */ class SHA1 extends _md_ts_1.HashMD {
    constructor(){
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [
            A,
            B,
            C,
            D,
            E
        ];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)SHA1_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 80; i++)SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for(let i = 0; i < 80; i++){
            let F, K;
            if (i < 20) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                K = 0x5a827999;
            } else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            } else if (i < 60) {
                F = (0, _md_ts_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            } else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;
            E = D;
            D = C;
            C = (0, utils_ts_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA1 = SHA1;
/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */ exports.sha1 = (0, utils_ts_1.createHasher)(()=>new SHA1());
/** Per-round constants */ const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({
    length: 64
}, (_, i)=>Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */ const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
/** MD5 legacy hash class. */ class MD5 extends _md_ts_1.HashMD {
    constructor(){
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [
            A,
            B,
            C,
            D
        ];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for(let i = 0; i < 64; i++){
            let F, g, s;
            if (i < 16) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                g = i;
                s = [
                    7,
                    12,
                    17,
                    22
                ];
            } else if (i < 32) {
                F = (0, _md_ts_1.Chi)(D, B, C);
                g = (5 * i + 1) % 16;
                s = [
                    5,
                    9,
                    14,
                    20
                ];
            } else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [
                    4,
                    11,
                    16,
                    23
                ];
            } else {
                F = C ^ (B | ~D);
                g = 7 * i % 16;
                s = [
                    6,
                    10,
                    15,
                    21
                ];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.MD5 = MD5;
/**
 * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.
 * MD5 architecture is similar to SHA1, with some differences:
 * - Reduced output length: 16 bytes (128 bit) instead of 20
 * - 64 rounds, instead of 80
 * - Little-endian: could be faster, but will require more code
 * - Non-linear index selection: huge speed-up for unroll
 * - Per round constants: more memory accesses, additional speed-up for unroll
 */ exports.md5 = (0, utils_ts_1.createHasher)(()=>new MD5());
// RIPEMD-160
const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]);
const Id160 = /* @__PURE__ */ (()=>Uint8Array.from(new Array(16).fill(0).map((_, i)=>i)))();
const Pi160 = /* @__PURE__ */ (()=>Id160.map((i)=>(9 * i + 5) % 16))();
const idxLR = /* @__PURE__ */ (()=>{
    const L = [
        Id160
    ];
    const R = [
        Pi160
    ];
    const res = [
        L,
        R
    ];
    for(let i = 0; i < 4; i++)for (let j of res)j.push(j[i].map((k)=>Rho160[k]));
    return res;
})();
const idxL = /* @__PURE__ */ (()=>idxLR[0])();
const idxR = /* @__PURE__ */ (()=>idxLR[1])();
// const [idxL, idxR] = idxLR;
const shifts160 = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((i)=>Uint8Array.from(i));
const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i)=>idx.map((j)=>shifts160[i][j]));
const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i)=>idx.map((j)=>shifts160[i][j]));
const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
]);
const Kr160 = /* @__PURE__ */ Uint32Array.from([
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
]);
// It's called f() in spec.
function ripemd_f(group, x, y, z) {
    if (group === 0) return x ^ y ^ z;
    if (group === 1) return x & y | ~x & z;
    if (group === 2) return (x | ~y) ^ z;
    if (group === 3) return x & z | y & ~z;
    return x ^ (y | ~z);
}
// Reusable temporary buffer
const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_ts_1.HashMD {
    constructor(){
        super(64, 20, 8, true);
        this.h0 = 1732584193;
        this.h1 = -271733879;
        this.h2 = -1732584194;
        this.h3 = 271733878;
        this.h4 = -1009589776;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [
            h0,
            h1,
            h2,
            h3,
            h4
        ];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)BUF_160[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for(let group = 0; group < 5; group++){
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore
            for(let i = 0; i < 16; i++){
                const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for(let i = 0; i < 16; i++){
                const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a legacy hash function from 1990s.
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 */ exports.ripemd160 = (0, utils_ts_1.createHasher)(()=>new RIPEMD160());

},{"2f20739411ceab2":"dkX9O","608dba3c6b412388":"fuxLy"}],"duDm8":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Secp256k1 = void 0;
const encoding_1 = require("3d4bed654d8486d7");
const utils_1 = require("4fa4fb375bc0a36c");
const secp256k1_1 = require("6b38a64e5cc71981");
const secp256k1signature_1 = require("26a3ea6174d54ec0");
function unsignedBigIntToBytes(a) {
    (0, utils_1.assert)(a >= 0n);
    let hex = a.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    return (0, encoding_1.fromHex)(hex);
}
function bytesToUnsignedBigInt(a) {
    return BigInt("0x" + (0, encoding_1.toHex)(a));
}
class Secp256k1 {
    /**
     * Takes a 32 byte private key and returns a privkey/pubkey pair.
     *
     * The resulting pubkey is uncompressed. For the use in Cosmos it should
     * be compressed first using `Secp256k1.compressPubkey`.
     */ static async makeKeypair(privkey) {
        if (privkey.length !== 32) throw new Error("input data is not a valid secp256k1 private key");
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(privkey)) // not strictly smaller than N
        throw new Error("input data is not a valid secp256k1 private key");
        const out = {
            privkey: privkey,
            // encodes uncompressed as
            // - 1-byte prefix "04"
            // - 32-byte x coordinate
            // - 32-byte y coordinate
            pubkey: secp256k1_1.secp256k1.getPublicKey(privkey, false)
        };
        return out;
    }
    /**
     * Creates a signature that is
     * - deterministic (RFC 6979)
     * - lowS signature
     * - DER encoded
     */ static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) throw new Error("Message hash must not be empty");
        if (messageHash.length > 32) throw new Error("Message hash length must not exceed 32 bytes");
        const { recovery, r, s } = secp256k1_1.secp256k1.sign(messageHash, privkey, {
            lowS: true
        });
        if (typeof recovery !== "number") throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(unsignedBigIntToBytes(r), unsignedBigIntToBytes(s), recovery);
    }
    static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) throw new Error("Message hash must not be empty");
        if (messageHash.length > 32) throw new Error("Message hash length must not exceed 32 bytes");
        const encodedSig = secp256k1_1.secp256k1.Signature.fromDER(signature.toDer());
        return secp256k1_1.secp256k1.verify(encodedSig, messageHash, pubkey, {
            lowS: false
        });
    }
    static recoverPubkey(signature, messageHash) {
        const pk = new secp256k1_1.secp256k1.Signature(bytesToUnsignedBigInt(signature.r()), bytesToUnsignedBigInt(signature.s()), signature.recovery).recoverPublicKey(messageHash);
        return pk.toBytes(false);
    }
    /**
     * Takes a compressed or uncompressed pubkey and return a compressed one.
     *
     * This function is idempotent.
     */ static compressPubkey(pubkey) {
        switch(pubkey.length){
            case 33:
                return pubkey;
            case 65:
                return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(true);
            default:
                throw new Error("Invalid pubkey length");
        }
    }
    /**
     * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
     *
     * This function is idempotent.
     */ static uncompressPubkey(pubkey) {
        switch(pubkey.length){
            case 33:
                return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(false);
            case 65:
                return pubkey;
            default:
                throw new Error("Invalid pubkey length");
        }
    }
    static trimRecoveryByte(signature) {
        switch(signature.length){
            case 64:
                return signature;
            case 65:
                return signature.slice(0, 64);
            default:
                throw new Error("Invalid signature length");
        }
    }
}
exports.Secp256k1 = Secp256k1;

},{"3d4bed654d8486d7":"enCPS","4fa4fb375bc0a36c":"3R4mb","6b38a64e5cc71981":"8NuVo","26a3ea6174d54ec0":"4pSav"}],"8NuVo":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
/**
 * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,
 * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha2_js_1 = require("2d3d9615fb2f3b65");
const utils_js_1 = require("3cb47869d29f5bb0");
const _shortw_utils_ts_1 = require("8a5ef77428763709");
const hash_to_curve_ts_1 = require("992867e7d1ef8b");
const modular_ts_1 = require("6a274edd04635854");
const weierstrass_ts_1 = require("4687d8e71912c9bd");
const utils_ts_1 = require("cc8f5f969869190c");
// Seems like generator was produced from some seed:
// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`
// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n
const secp256k1_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8')
};
const secp256k1_ENDO = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    basises: [
        [
            BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
            -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')
        ],
        [
            BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
            BigInt('0x3086d221a7d46bcde86c90e49284eb15')
        ]
    ]
};
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P; // x^3, 11
    const b3 = b2 * b2 * y % P; // x^7
    const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
    const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, modular_ts_1.pow2)(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, {
    sqrt: sqrtMod
});
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = secp256k1.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = secp256k1.sign(msg, secretKey);
 * const isValid = secp256k1.verify(sig, msg, publicKey) === true;
 * ```
 */ exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({
    ...secp256k1_CURVE,
    Fp: Fpk1,
    lowS: true,
    endo: secp256k1_ENDO
}, sha2_js_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point)=>point.toBytes(true).slice(1);
const Pointk1 = /* @__PURE__ */ (()=>exports.secp256k1.Point)();
const hasEven = (y)=>y % _2n === _0n;
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    const { Fn, BASE } = Pointk1;
    const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
    const p = BASE.multiply(d_); // P = d'G; 0 < d' < n check is done inside
    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
    return {
        scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    const Fp = Fpk1;
    if (!Fp.isValidNot0(x)) throw new Error("invalid x: Fail if x \u2265 p");
    const xx = Fp.create(x * x);
    const c = Fp.create(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().
    // Return the unique point P such that x(P) = x and
    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    if (!hasEven(y)) y = Fp.neg(y);
    const p = Pointk1.fromAffine({
        x,
        y
    });
    p.assertValidity();
    return p;
}
const num = utils_ts_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge(...args) {
    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(secretKey) {
    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
    const { Fn } = Pointk1;
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder
    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'G
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    const { Fn, BASE } = Pointk1;
    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p)) return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n)) return false;
        // int(challenge(bytes(r)||bytes(P)||m))%n
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        // R = sG - eP, where -eP == (n-e)P
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
        if (R.is0() || !hasEven(y) || x !== r) return false;
        return true;
    } catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * @example
 * ```js
 * import { schnorr } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = schnorr.keygen();
 * // const publicKey = schnorr.getPublicKey(secretKey);
 * const msg = new TextEncoder().encode('hello');
 * const sig = schnorr.sign(msg, secretKey);
 * const isValid = schnorr.verify(sig, msg, publicKey);
 * ```
 */ exports.schnorr = (()=>{
    const size = 32;
    const seedLength = 48;
    const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength))=>{
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
    };
    // TODO: remove
    exports.secp256k1.utils.randomSecretKey;
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return {
            secretKey,
            publicKey: schnorrGetPublicKey(secretKey)
        };
    }
    return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
            randomSecretKey: randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod
        },
        lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength
        }
    };
})();
const isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
        // xNum
        [
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'
        ],
        // xDen
        [
            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ],
        // yNum
        [
            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'
        ],
        // yDen
        [
            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ]
    ].map((i)=>i.map((j)=>BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
        B: BigInt('1771'),
        Z: Fpk1.create(BigInt('-11'))
    }))();
/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ exports.secp256k1_hasher = (()=>(0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars)=>{
        const { x, y } = mapSWU(Fpk1.create(scalars[0]));
        return isoMap(x, y);
    }, {
        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
        p: Fpk1.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha2_js_1.sha256
    }))();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ exports.hashToCurve = (()=>exports.secp256k1_hasher.hashToCurve)();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ exports.encodeToCurve = (()=>exports.secp256k1_hasher.encodeToCurve)();

},{"2d3d9615fb2f3b65":"5Nc2s","3cb47869d29f5bb0":"fuxLy","8a5ef77428763709":"aB8tU","992867e7d1ef8b":"7mgY5","6a274edd04635854":"1jGup","4687d8e71912c9bd":"lULXb","cc8f5f969869190c":"b5Wru"}],"aB8tU":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const weierstrass_ts_1 = require("bceff96a5b87336d");
/** connects noble-curves to noble-hashes */ function getHash(hash) {
    return {
        hash
    };
}
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */ function createCurve(curveDef, defHash) {
    const create = (hash)=>(0, weierstrass_ts_1.weierstrass)({
            ...curveDef,
            hash: hash
        });
    return {
        ...create(defHash),
        create
    };
}

},{"bceff96a5b87336d":"lULXb"}],"lULXb":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DER = exports.DERErr = void 0;
exports._splitEndoScalar = _splitEndoScalar;
exports._normFnElement = _normFnElement;
exports.weierstrassN = weierstrassN;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
exports.ecdh = ecdh;
exports.ecdsa = ecdsa;
exports.weierstrassPoints = weierstrassPoints;
exports._legacyHelperEquat = _legacyHelperEquat;
exports.weierstrass = weierstrass;
/**
 * Short Weierstrass curve methods. The formula is: y = x + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_js_1 = require("2cddc0c4a6771b1c");
const utils_1 = require("e1294e71d2eee917");
const utils_ts_1 = require("b6604ca0d54115a2");
const curve_ts_1 = require("11f68d725b0f6f5d");
const modular_ts_1 = require("d8b1615c256fe3fa");
// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)
const divNearest = (num, den)=>(num + (num >= 0 ? den : -den) / _2n) / den;
/**
 * Splits scalar for GLV endomorphism.
 */ function _splitEndoScalar(k, basis, n) {
    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`
    // Since part can be negative, we need to do this on point.
    // TODO: verifyScalar function which consumes lambda
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    // |k1|/|k2| is < sqrt(N), but can be negative.
    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n;
    const k2neg = k2 < _0n;
    if (k1neg) k1 = -k1;
    if (k2neg) k2 = -k2;
    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.
    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.
    const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N
    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) throw new Error('splitScalar (endomorphism): failed, k=' + k);
    return {
        k1neg,
        k1,
        k2neg,
        k2
    };
}
function validateSigFormat(format) {
    if (![
        'compact',
        'recovered',
        'der'
    ].includes(format)) throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
}
function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def))// @ts-ignore
    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];
    (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');
    (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');
    if (optsn.format !== undefined) validateSigFormat(optsn.format);
    return optsn;
}
class DERErr extends Error {
    constructor(m = ''){
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */ exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data)=>{
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');
            if (data.length & 1) throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode (tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong) length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)length = length << 8 | b;
                pos += lenLen;
                if (length < 128) throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length) throw new E('tlv.decode: wrong value length');
            return {
                v,
                l: data.subarray(pos + length)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (num) {
            const { Err: E } = exports.DER;
            if (num < _0n) throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 8) hex = '00' + hex;
            if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode (data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128) throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128)) throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        }
    },
    toSig (hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');
        return {
            r: int.decode(rBytes),
            s: int.decode(sBytes)
        };
    },
    hexFromSig (sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === 'bigint') num = key;
    else {
        let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
        try {
            num = Fn.fromBytes(bytes);
        } catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
    }
    if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');
    return num;
}
/**
 * Creates weierstrass Point constructor, based on specified curve options.
 *
 * @example
```js
const opts = {
  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
  h: BigInt(1),
  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
 */ function weierstrassN(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean'
    });
    const { endo } = extraOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
        if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === comp && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y = x + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y ^ (p+1)/4
            } catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd) y = Fp.neg(y);
            return {
                x,
                y
            };
        } else if (length === uncomp && head === 0x04) {
            // TODO: more checks
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');
            return {
                x,
                y
            };
        } else throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x * x
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b
    }
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y == x + ax + b */ function isValidXY(x, y) {
        const left = Fp.sqr(y); // y
        const right = weierstrassEquation(x); // x + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y = x + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');
    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */ function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
    }
    function splitEndoScalarN(k) {
        if (!endo || !endo.basises) throw new Error('no endo');
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z)  (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz)=>{
        const { X, Y, Z } = p;
        // Fast-path for normalized points
        if (Fp.eql(Z, Fp.ONE)) return {
            x: X,
            y: Y
        };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0) return {
            x: Fp.ZERO,
            y: Fp.ZERO
        };
        if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
        return {
            x,
            y
        };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p)=>{
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(X, Y, Z){
            this.X = acoord('x', X);
            this.Y = acoord('y', Y, true);
            this.Z = acoord('z', Z);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
            if (p instanceof Point) throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));
            P.assertValidity();
            return P;
        }
        static fromHex(hex) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */ precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy) this.multiply(_3n); // random number
            return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */ assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd) throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */ equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ multiply(scalar) {
            const { endo } = extraOpts;
            if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n)=>wnaf.cached(this, n, (p)=>(0, curve_ts_1.normalizeZ)(Point, p));
            /** See docs for {@link EndomorphismOpts} */ if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            } else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return (0, curve_ts_1.normalizeZ)(Point, [
                point,
                fake
            ])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */ multiplyUnsafe(sc) {
            const { endo } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0()) return Point.ZERO;
            if (sc === _1n) return p; // fast-path
            if (wnaf.hasCache(this)) return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            } else return wnaf.unsafe(p, sc);
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */ toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */ isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n) return true;
            if (isTorsionFree) return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
            // can we use this.clearCofactor()?
            return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v)=>{
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(let i = c1; i > _1n; i--){
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v)=>{
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u)=>{
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [
            tv4
        ], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return {
            x,
            y
        };
    };
}
function getWLengths(Fp, Fn) {
    return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES
    };
}
/**
 * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
 * This helper ensures no signature functionality is present. Less code, smaller bundle size.
 */ function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), {
        seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER)
    });
    function isValidSecretKey(secretKey) {
        try {
            return !!_normFnElement(Fn, secretKey);
        } catch (error) {
            return false;
        }
    }
    function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
            const l = publicKey.length;
            if (isCompressed === true && l !== comp) return false;
            if (isCompressed === false && l !== publicKeyUncompressed) return false;
            return !!Point.fromBytes(publicKey);
        } catch (error) {
            return false;
        }
    }
    /**
     * Produces cryptographically secure secret key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */ function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);
    }
    /**
     * Computes public key for a secret key. Checks for validity of the secret key.
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return {
            secretKey,
            publicKey: getPublicKey(secretKey)
        };
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        if (typeof item === 'bigint') return false;
        if (item instanceof Point) return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey) return undefined;
        const l = (0, utils_ts_1.ensureBytes)('key', item).length;
        return l === publicKey || l === publicKeyUncompressed;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from secret key A and public key B.
     * Checks: 1) secret key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');
        if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB); // checks for being on-curve
        return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),
        precompute (windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        }
    };
    return Object.freeze({
        getPublicKey,
        getSharedSecret,
        keygen,
        Point,
        utils,
        lengths
    });
}
/**
 * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
 * We need `hash` for 2 features:
 * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
 * 2. k generation in `sign`, using HMAC-drbg(hash)
 *
 * ECDSAOpts are only rarely needed.
 *
 * @example
 * ```js
 * const p256_Point = weierstrass(...);
 * const p256_sha256 = ecdsa(p256_Point, sha256);
 * const p256_sha224 = ecdsa(p256_Point, sha224);
 * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
 * ```
 */ function ecdsa(Point, hash, ecdsaOpts = {}) {
    (0, utils_1.ahash)(hash);
    (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function'
    });
    const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac = ecdsaOpts.hmac || ((key, ...msgs)=>(0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,
        format: undefined,
        extraEntropy: false
    };
    const defaultSigOpts_format = 'compact';
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function validateRS(title, num) {
        if (!Fn.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
    }
    function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
     */ class Signature {
        constructor(r, s, recovery){
            this.r = validateRS('r', r); // r in [1..N-1];
            this.s = validateRS('s', s); // s in [1..N-1];
            if (recovery != null) this.recovery = recovery;
            Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === 'der') {
                const { r, s } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
                return new Signature(r, s);
            }
            if (format === 'recovered') {
                recid = bytes[0];
                format = 'compact';
                bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0()) throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === 'der') return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === 'recovered') {
                if (this.recovery == null) throw new Error('recovery bit must be present');
                return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {}
        static fromCompact(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');
        }
        static fromDER(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
        // Our custom check "just in case", for protection against DoS
        if (bytes.length > 8192) throw new Error('input is too large');
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
        const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
        return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // Pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */ function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, undefined, 'message');
        return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;
    }
    /**
     * Steps A, D of RFC6979 3.2.
     * Creates RFC6979 seed; converts msg/privKey to numbers.
     * Used only in sign, not in verify.
     *
     * Warning: we cannot assume here that message has same amount of bytes as curve order,
     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
     */ function prepSig(message, privateKey, opts) {
        if ([
            'recovered',
            'canonical'
        ].some((k)=>k in opts)) throw new Error('sign() legacy options not supported');
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint
        const seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (extraEntropy != null && extraEntropy !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            // gen random bytes OR pass as-is
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // To transform k => Signature:
        // q = kG
        // r = q.x mod n
        // s = k^-1(m + rd) mod n
        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // mod n, not mod p
            if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = kG
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n) return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n) return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = Fn.neg(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed,
            k2sig
        };
    }
    /**
     * Signs message hash with a secret key.
     *
     * ```
     * sign(m, d) where
     *   k = rfc6979_hmac_drbg(m, d)
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr) / k mod n
     * ```
     */ function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)('message', message);
        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G
        return sig;
    }
    function tryParsingSig(sg) {
        // Try to deduce format
        let sig = undefined;
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && sg !== null && typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint';
        if (!isHex && !isObj) throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        if (isObj) sig = new Signature(sg.r, sg.s);
        else if (isHex) {
            try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');
            } catch (derError) {
                if (!(derError instanceof exports.DER.Err)) throw derError;
            }
            if (!sig) try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');
            } catch (error) {
                return false;
            }
        }
        if (!sig) return false;
        return sig;
    }
    /**
     * Verifies a signature against message and public key.
     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   u1 = hs^-1 mod n
     *   u2 = rs^-1 mod n
     *   R = u1G + u2P
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);
        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
        const sig = format === undefined ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);
        if (sig === false) return false;
        try {
            const P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS()) return false;
            const { r, s } = sig;
            const h = bits2int_modN(message); // mod n, not mod p
            const is = Fn.inv(s); // s^-1 mod n
            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P
            if (R.is0()) return false;
            const v = Fn.create(R.x); // v = r.x mod n
            return v === r;
        } catch (e) {
            return false;
        }
    }
    function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash
    });
}
/** @deprecated use `weierstrass` in newer releases */ function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
    };
    const Fp = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l)=>Math.ceil(l / 2)))) : undefined;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: c.wrapPrivateKey
    });
    const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes
    };
    return {
        CURVE,
        curveOpts
    };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN
    };
    return {
        CURVE,
        curveOpts,
        hash: c.hash,
        ecdsaOpts
    };
}
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.
     * @returns y
     */ function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b
    }
    return weierstrassEquation;
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder
    });
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}

},{"2cddc0c4a6771b1c":"higgt","e1294e71d2eee917":"fuxLy","b6604ca0d54115a2":"b5Wru","11f68d725b0f6f5d":"gtZZm","d8b1615c256fe3fa":"1jGup"}],"4pSav":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;
function trimLeadingNullBytes(inData) {
    let numberOfLeadingNullBytes = 0;
    for (const byte of inData){
        if (byte === 0x00) numberOfLeadingNullBytes++;
        else break;
    }
    return inData.slice(numberOfLeadingNullBytes);
}
const derTagInteger = 0x02;
class Secp256k1Signature {
    /**
     * Takes the pair of integers (r, s) as 2x32 byte of binary data.
     *
     * Note: This is the format Cosmos SDK uses natively.
     *
     * @param data a 64 byte value containing integers r and s.
     */ static fromFixedLength(data) {
        if (data.length !== 64) throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);
        return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));
    }
    static fromDer(data) {
        let pos = 0;
        if (data[pos++] !== 0x30) throw new Error("Prefix 0x30 expected");
        const bodyLength = data[pos++];
        if (data.length - pos !== bodyLength) throw new Error("Data length mismatch detected");
        // r
        const rTag = data[pos++];
        if (rTag !== derTagInteger) throw new Error("INTEGER tag expected");
        const rLength = data[pos++];
        if (rLength >= 0x80) throw new Error("Decoding length values above 127 not supported");
        const rData = data.slice(pos, pos + rLength);
        pos += rLength;
        // s
        const sTag = data[pos++];
        if (sTag !== derTagInteger) throw new Error("INTEGER tag expected");
        const sLength = data[pos++];
        if (sLength >= 0x80) throw new Error("Decoding length values above 127 not supported");
        const sData = data.slice(pos, pos + sLength);
        pos += sLength;
        return new Secp256k1Signature(// r/s data can contain leading 0 bytes to express integers being non-negative in DER
        trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));
    }
    data;
    constructor(r, s){
        if (r.length > 32 || r.length === 0 || r[0] === 0x00) throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        if (s.length > 32 || s.length === 0 || s[0] === 0x00) throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        this.data = {
            r: r,
            s: s
        };
    }
    r(length) {
        if (length === undefined) return this.data.r;
        else {
            const paddingLength = length - this.data.r.length;
            if (paddingLength < 0) throw new Error("Length too small to hold parameter r");
            const padding = new Uint8Array(paddingLength);
            return new Uint8Array([
                ...padding,
                ...this.data.r
            ]);
        }
    }
    s(length) {
        if (length === undefined) return this.data.s;
        else {
            const paddingLength = length - this.data.s.length;
            if (paddingLength < 0) throw new Error("Length too small to hold parameter s");
            const padding = new Uint8Array(paddingLength);
            return new Uint8Array([
                ...padding,
                ...this.data.s
            ]);
        }
    }
    toFixedLength() {
        return new Uint8Array([
            ...this.r(32),
            ...this.s(32)
        ]);
    }
    toDer() {
        // DER supports negative integers but our data is unsigned. Thus we need to prepend
        // a leading 0 byte when the highest bit is set to differentiate negative values
        const rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([
            0,
            ...this.data.r
        ]) : this.data.r;
        const sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([
            0,
            ...this.data.s
        ]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data = new Uint8Array([
            derTagInteger,
            rLength,
            ...rEncoded,
            derTagInteger,
            sLength,
            ...sEncoded
        ]);
        return new Uint8Array([
            0x30,
            data.length,
            ...data
        ]);
    }
}
exports.Secp256k1Signature = Secp256k1Signature;
/**
 * A Secp256k1Signature plus the recovery parameter
 */ class ExtendedSecp256k1Signature extends Secp256k1Signature {
    /**
     * Decode extended signature from the simple fixed length encoding
     * described in toFixedLength().
     */ static fromFixedLength(data) {
        if (data.length !== 65) throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);
        return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);
    }
    recovery;
    constructor(r, s, recovery){
        super(r, s);
        if (!Number.isInteger(recovery)) throw new Error("The recovery parameter must be an integer.");
        if (recovery < 0 || recovery > 4) throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        this.recovery = recovery;
    }
    /**
     * A simple custom encoding that encodes the extended signature as
     * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
     * where | denotes concatenation of bonary data.
     */ toFixedLength() {
        return new Uint8Array([
            ...this.r(32),
            ...this.s(32),
            this.recovery
        ]);
    }
}
exports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;

},{}],"fhULm":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Slip10 = exports.Slip10RawIndex = exports.Slip10Curve = void 0;
exports.slip10CurveFromString = slip10CurveFromString;
exports.pathToString = pathToString;
exports.stringToPath = stringToPath;
const encoding_1 = require("6a33ae5f9f1a656e");
const math_1 = require("adeb990ea03fb2e0");
const utils_1 = require("f3beda875206ad2b");
const secp256k1_1 = require("28dca93cb3dbf325");
const hmac_1 = require("2b93e536cfb5b557");
const sha_1 = require("3fc1e366e4ea240e");
/**
 * Raw values must match the curve string in SLIP-0010 master key generation
 *
 * @see https://github.com/satoshilabs/slips/blob/master/slip-0010.md#master-key-generation
 */ var Slip10Curve;
(function(Slip10Curve) {
    Slip10Curve["Secp256k1"] = "Bitcoin seed";
    Slip10Curve["Ed25519"] = "ed25519 seed";
})(Slip10Curve || (exports.Slip10Curve = Slip10Curve = {}));
function bytesToUnsignedBigInt(a) {
    return BigInt("0x" + (0, encoding_1.toHex)(a));
}
function intTo32be(n) {
    (0, utils_1.assert)(n >= 0n);
    (0, utils_1.assert)(n < 2n ** (32n * 8n));
    // 32 bytes is 64 hexadecimal characters
    const hex = n.toString(16).padStart(64, "0");
    return (0, encoding_1.fromHex)(hex);
}
/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */ /**
 * Reverse mapping of Slip10Curve
 */ function slip10CurveFromString(curveString) {
    switch(curveString){
        case Slip10Curve.Ed25519:
            return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
            return Slip10Curve.Secp256k1;
        default:
            throw new Error(`Unknown curve string: '${curveString}'`);
    }
}
class Slip10RawIndex extends math_1.Uint32 {
    static hardened(hardenedIndex) {
        return new Slip10RawIndex(hardenedIndex + 2 ** 31);
    }
    static normal(normalIndex) {
        return new Slip10RawIndex(normalIndex);
    }
    isHardened() {
        return this.data >= 2 ** 31;
    }
}
exports.Slip10RawIndex = Slip10RawIndex;
// Universal private key derivation according to
// https://github.com/satoshilabs/slips/blob/master/slip-0010.md
class Slip10 {
    static derivePath(curve, seed, path) {
        let result = this.master(curve, seed);
        for (const rawIndex of path)result = this.child(curve, result.privkey, result.chainCode, rawIndex);
        return result;
    }
    static master(curve, seed) {
        const i = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) return this.master(curve, i);
        return {
            chainCode: ir,
            privkey: il
        };
    }
    static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i;
        if (rawIndex.isHardened()) {
            const payload = new Uint8Array([
                0x00,
                ...parentPrivkey,
                ...rawIndex.toBytesBigEndian()
            ]);
            i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
            if (curve === Slip10Curve.Ed25519) throw new Error("Normal keys are not allowed with ed25519");
            else {
                // Step 1 of https://github.com/satoshilabs/slips/blob/master/slip-0010.md#private-parent-key--private-child-key
                // Calculate I = HMAC-SHA512(Key = c_par, Data = ser_P(point(k_par)) || ser_32(i)).
                // where the functions point() and ser_p() are defined in BIP-0032
                const data = new Uint8Array([
                    ...Slip10.serializedPoint(curve, bytesToUnsignedBigInt(parentPrivkey)),
                    ...rawIndex.toBytesBigEndian()
                ]);
                i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data).digest();
            }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i);
    }
    /**
     * Implementation of ser_P(point(k_par)) from BIP-0032
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
     */ static serializedPoint(curve, p) {
        switch(curve){
            case Slip10Curve.Secp256k1:
                return secp256k1_1.secp256k1.Point.BASE.multiply(p).toBytes(true);
            default:
                throw new Error("curve not supported");
        }
    }
    static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i) {
        // step 2 (of the Private parent key  private child key algorithm)
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        // step 3
        const returnChainCode = ir;
        // step 4
        if (curve === Slip10Curve.Ed25519) return {
            chainCode: returnChainCode,
            privkey: il
        };
        // step 5
        const n = this.n(curve);
        const returnChildKeyAsNumber = (bytesToUnsignedBigInt(il) + bytesToUnsignedBigInt(parentPrivkey)) % n;
        const returnChildKey = intTo32be(returnChildKeyAsNumber);
        // step 6
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
            const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([
                0x01,
                ...ir,
                ...rawIndex.toBytesBigEndian()
            ])).digest();
            return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        // step 7
        return {
            chainCode: returnChainCode,
            privkey: returnChildKey
        };
    }
    static isZero(privkey) {
        return privkey.every((byte)=>byte === 0);
    }
    static isGteN(curve, privkey) {
        const keyAsNumber = bytesToUnsignedBigInt(privkey);
        return keyAsNumber >= this.n(curve);
    }
    static n(curve) {
        switch(curve){
            case Slip10Curve.Secp256k1:
                return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
            default:
                throw new Error("curve not supported");
        }
    }
}
exports.Slip10 = Slip10;
function pathToString(path) {
    return path.reduce((current, component)=>{
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
    }, "m");
}
function stringToPath(input) {
    if (!input.startsWith("m")) throw new Error("Path string must start with 'm'");
    let rest = input.slice(1);
    const out = new Array();
    while(rest){
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match) throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31) throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe) out.push(Slip10RawIndex.hardened(value));
        else out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
    }
    return out;
}

},{"6a33ae5f9f1a656e":"enCPS","adeb990ea03fb2e0":"e8aug","f3beda875206ad2b":"3R4mb","28dca93cb3dbf325":"8NuVo","2b93e536cfb5b557":"b5ho1","3fc1e366e4ea240e":"kKVwh"}],"g8Pi0":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
exports.encodeEd25519Pubkey = encodeEd25519Pubkey;
exports.decodeAminoPubkey = decodeAminoPubkey;
exports.decodeBech32Pubkey = decodeBech32Pubkey;
exports.encodeAminoPubkey = encodeAminoPubkey;
exports.encodeBech32Pubkey = encodeBech32Pubkey;
const encoding_1 = require("1d5e411552bf8d73");
const math_1 = require("68680725ac4cc954");
const utils_1 = require("66073795c073e90b");
const pubkeys_1 = require("823bdc48ecfd5023");
/**
 * Takes a Secp256k1 public key as raw bytes and returns the Amino JSON
 * representation of it (the type/value wrapper object).
 */ function encodeSecp256k1Pubkey(pubkey) {
    if (pubkey.length !== 33 || pubkey[0] !== 0x02 && pubkey[0] !== 0x03) throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
    return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
    };
}
/**
 * Takes an Edd25519 public key as raw bytes and returns the Amino JSON
 * representation of it (the type/value wrapper object).
 */ function encodeEd25519Pubkey(pubkey) {
    if (pubkey.length !== 32) throw new Error("Ed25519 public key must be 32 bytes long");
    return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
    };
}
// As discussed in https://github.com/binance-chain/javascript-sdk/issues/163
// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography
// Last bytes is varint-encoded length prefix
const pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)("eb5ae98721" /* fixed length */ );
const pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)("1624de6420" /* fixed length */ );
const pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)("0dfb100520" /* fixed length */ );
/** See https://github.com/tendermint/tendermint/commit/38b401657e4ad7a7eeb3c30a3cbf512037df3740 */ const pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)("22c1f7e2" /* variable length not included */ );
/**
 * Decodes a pubkey in the Amino binary format to a type/value object.
 */ function decodeAminoPubkey(data) {
    if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSecp256k1)) {
        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        return {
            type: pubkeys_1.pubkeyType.secp256k1,
            value: (0, encoding_1.toBase64)(rest)
        };
    } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixEd25519)) {
        const rest = data.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        return {
            type: pubkeys_1.pubkeyType.ed25519,
            value: (0, encoding_1.toBase64)(rest)
        };
    } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSr25519)) {
        const rest = data.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        return {
            type: pubkeys_1.pubkeyType.sr25519,
            value: (0, encoding_1.toBase64)(rest)
        };
    } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixMultisigThreshold)) // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return decodeMultisigPubkey(data);
    else throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data.slice(0, 5)));
}
/**
 * Decodes a bech32 pubkey to Amino binary, which is then decoded to a type/value object.
 * The bech32 prefix is ignored and discarded.
 *
 * @param bechEncoded the bech32 encoded pubkey
 */ function decodeBech32Pubkey(bechEncoded) {
    const { data } = (0, encoding_1.fromBech32)(bechEncoded);
    return decodeAminoPubkey(data);
}
/**
 * Uvarint decoder for Amino.
 * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/decoder.go#L64-76
 * @returns varint as number, and bytes count occupied by varint
 */ function decodeUvarint(reader) {
    if (reader.length < 1) throw new Error("Can't decode varint. EOF");
    if (reader[0] > 127) throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
    return [
        reader[0],
        1
    ];
}
/**
 * Decodes a multisig pubkey to type object.
 * Pubkey structure [ prefix + const + threshold + loop:(const + pubkeyLength + pubkey            ) ]
 *                  [   4b   + 1b    +  varint   + loop:(1b    +    varint    + pubkeyLength bytes) ]
 * @param data encoded pubkey
 */ function decodeMultisigPubkey(data) {
    const reader = Array.from(data);
    // remove multisig amino prefix;
    const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
    if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) throw new Error("Invalid multisig prefix.");
    // remove 0x08 threshold prefix;
    if (reader.shift() != 0x08) throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
    // read threshold
    const [threshold, thresholdBytesLength] = decodeUvarint(reader);
    reader.splice(0, thresholdBytesLength);
    // read participants pubkeys
    const pubkeys = [];
    while(reader.length > 0){
        // remove 0x12 threshold prefix;
        if (reader.shift() != 0x12) throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        // read pubkey length
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        // verify that we can read pubkey
        if (reader.length < pubkeyLength) throw new Error("Invalid multisig data length.");
        // read and decode participant pubkey
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
    }
    return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
            threshold: threshold.toString(),
            pubkeys: pubkeys
        }
    };
}
/**
 * Uvarint encoder for Amino. This is the same encoding as `binary.PutUvarint` from the Go
 * standard library.
 *
 * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/encoder.go#L77-L85
 */ function encodeUvarint(value) {
    const checked = math_1.Uint53.fromString(value.toString()).toNumber();
    if (checked > 127) throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
    return [
        checked
    ];
}
/**
 * Encodes a public key to binary Amino.
 */ function encodeAminoPubkey(pubkey) {
    if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(0x08); // TODO: What is this?
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p)=>encodeAminoPubkey(p))){
            out.push(0x12); // TODO: What is this?
            out.push(...encodeUvarint(pubkeyData.length));
            out.push(...pubkeyData);
        }
        return new Uint8Array(out);
    } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) return new Uint8Array([
        ...pubkeyAminoPrefixEd25519,
        ...(0, encoding_1.fromBase64)(pubkey.value)
    ]);
    else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) return new Uint8Array([
        ...pubkeyAminoPrefixSecp256k1,
        ...(0, encoding_1.fromBase64)(pubkey.value)
    ]);
    else throw new Error("Unsupported pubkey type");
}
/**
 * Encodes a public key to binary Amino and then to bech32.
 *
 * @param pubkey the public key to encode
 * @param prefix the bech32 prefix (human readable part)
 */ function encodeBech32Pubkey(pubkey, prefix) {
    return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
}

},{"1d5e411552bf8d73":"enCPS","68680725ac4cc954":"e8aug","66073795c073e90b":"3R4mb","823bdc48ecfd5023":"gbh6J"}],"gbh6J":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pubkeyType = void 0;
exports.isEd25519Pubkey = isEd25519Pubkey;
exports.isSecp256k1Pubkey = isSecp256k1Pubkey;
exports.isSinglePubkey = isSinglePubkey;
exports.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
function isEd25519Pubkey(pubkey) {
    return pubkey.type === "tendermint/PubKeyEd25519";
}
function isSecp256k1Pubkey(pubkey) {
    return pubkey.type === "tendermint/PubKeySecp256k1";
}
exports.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */ secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */ ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */ sr25519: "tendermint/PubKeySr25519",
    multisigThreshold: "tendermint/PubKeyMultisigThreshold"
};
function isSinglePubkey(pubkey) {
    const singPubkeyTypes = [
        exports.pubkeyType.ed25519,
        exports.pubkeyType.secp256k1,
        exports.pubkeyType.sr25519
    ];
    return singPubkeyTypes.includes(pubkey.type);
}
function isMultisigThresholdPubkey(pubkey) {
    return pubkey.type === "tendermint/PubKeyMultisigThreshold";
}

},{}],"R7jkn":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.coin = coin;
exports.coins = coins;
exports.parseCoins = parseCoins;
exports.addCoins = addCoins;
const math_1 = require("f839f61e3522dcdf");
/**
 * Creates a coin.
 *
 * If your values do not exceed the safe integer range of JS numbers (53 bit),
 * you can use the number type here. This is the case for all typical Cosmos SDK
 * chains that use the default 6 decimals.
 *
 * In case you need to support larger values, use unsigned integer strings instead.
 */ function coin(amount, denom) {
    let outAmount;
    if (typeof amount === "number") try {
        outAmount = new math_1.Uint53(amount).toString();
    } catch (_err) {
        throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
    }
    else {
        if (!amount.match(/^[0-9]+$/)) throw new Error("Invalid unsigned integer string format");
        outAmount = amount.replace(/^0*/, "") || "0";
    }
    return {
        amount: outAmount,
        denom: denom
    };
}
/**
 * Creates a list of coins with one element.
 */ function coins(amount, denom) {
    return [
        coin(amount, denom)
    ];
}
/**
 * Takes a coins list like "819966000ucosm,700000000ustake" and parses it.
 *
 * Starting with CosmJS 0.32.3, the following imports are all synonym and support
 * a variety of denom types such as IBC denoms or tokenfactory. If you need to
 * restrict the denom to something very minimal, this needs to be implemented
 * separately in the caller.
 *
 * ```
 * import { parseCoins } from "@cosmjs/proto-signing";
 * // equals
 * import { parseCoins } from "@cosmjs/stargate";
 * // equals
 * import { parseCoins } from "@cosmjs/amino";
 * ```
 *
 * This function is not made for supporting decimal amounts and does not support
 * parsing gas prices.
 */ function parseCoins(input) {
    return input.replace(/\s/g, "").split(",").filter(Boolean).map((part)=>{
        // Denom regex from Cosmos SDK 0.53 (https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/types/coin.go#L846)
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/:._-]{2,127})$/);
        if (!match) throw new Error("Got an invalid coin string");
        return {
            amount: match[1].replace(/^0+/, "") || "0",
            denom: match[2]
        };
    });
}
/**
 * Function to sum up coins with type Coin
 */ function addCoins(lhs, rhs) {
    if (lhs.denom !== rhs.denom) throw new Error("Trying to add two coins with different denoms");
    return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
    };
}

},{"f839f61e3522dcdf":"e8aug"}],"b2dH1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compareArrays = compareArrays;
exports.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
const encoding_1 = require("48bfe3757f6ea0ff");
const math_1 = require("6793d339827dada5");
const addresses_1 = require("b4a894816166dfda");
/**
 * Compare arrays lexicographically.
 *
 * Returns value < 0 if `a < b`.
 * Returns value > 0 if `a > b`.
 * Returns 0 if `a === b`.
 */ function compareArrays(a, b) {
    const aHex = (0, encoding_1.toHex)(a);
    const bHex = (0, encoding_1.toHex)(b);
    return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
}
function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
    const uintThreshold = new math_1.Uint53(threshold);
    if (uintThreshold.toNumber() > pubkeys.length) throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
    const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs)=>{
        // https://github.com/cosmos/cosmos-sdk/blob/v0.42.2/client/keys/add.go#L172-L174
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
    });
    return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
            threshold: uintThreshold.toString(),
            pubkeys: outPubkeys
        }
    };
}

},{"48bfe3757f6ea0ff":"enCPS","6793d339827dada5":"e8aug","b4a894816166dfda":"jpNc8"}],"574NG":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.omitDefault = omitDefault;
/**
 * Returns the given input. If the input is the default value
 * of protobuf, undefined is returned. Use this when creating Amino JSON converters.
 */ function omitDefault(input) {
    switch(typeof input){
        case "string":
            return input === "" ? undefined : input;
        case "number":
            return input === 0 ? undefined : input;
        case "bigint":
            return input === BigInt(0) ? undefined : input;
        case "boolean":
            return !input ? undefined : input;
        default:
            throw new Error(`Got unsupported type '${typeof input}'`);
    }
}

},{}],"hdWZv":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeCosmoshubPath = makeCosmoshubPath;
const crypto_1 = require("9960d71878ecb4bf");
/**
 * The Cosmos Hub derivation path in the form `m/44'/118'/0'/0/a`
 * with 0-based account index `a`.
 */ function makeCosmoshubPath(a) {
    return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
    ];
}

},{"9960d71878ecb4bf":"kTd5b"}],"fLhzh":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Secp256k1HdWallet = void 0;
exports.extractKdfConfiguration = extractKdfConfiguration;
const crypto_1 = require("bf557efe044f1957");
const encoding_1 = require("f0331bce450fb1bc");
const utils_1 = require("f84de96b69818aba");
const addresses_1 = require("36b12f5209800701");
const paths_1 = require("fcdacd62aa98c32");
const signature_1 = require("c292de170e6e4573");
const signdoc_1 = require("4b1040d5daa1eab5");
const wallet_1 = require("8543848abf7eec7d");
const serializationTypeV1 = "secp256k1wallet-v1";
/**
 * A KDF configuration that is not very strong but can be used on the main thread.
 * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.
 */ const basicPasswordHashingOptions = {
    algorithm: "argon2id",
    params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12288
    }
};
function isDerivationJson(thing) {
    if (!(0, utils_1.isNonNullObject)(thing)) return false;
    if (typeof thing.hdPath !== "string") return false;
    if (typeof thing.prefix !== "string") return false;
    return true;
}
function extractKdfConfigurationV1(doc) {
    return doc.kdf;
}
function extractKdfConfiguration(serialization) {
    const root = JSON.parse(serialization);
    if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
    switch(root.type){
        case serializationTypeV1:
            return extractKdfConfigurationV1(root);
        default:
            throw new Error("Unsupported serialization type");
    }
}
const defaultOptions = {
    bip39Password: "",
    hdPaths: [
        (0, paths_1.makeCosmoshubPath)(0)
    ],
    prefix: "cosmos"
};
class Secp256k1HdWallet {
    /**
     * Restores a wallet from the given BIP39 mnemonic.
     *
     * @param mnemonic Any valid English mnemonic.
     * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */ static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new Secp256k1HdWallet(mnemonicChecked, {
            ...options,
            seed: seed
        });
    }
    /**
     * Generates a new wallet with a BIP39 mnemonic of the given length.
     *
     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
     * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */ static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
    }
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * @param password The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
        switch(root.type){
            case serializationTypeV1:
                return Secp256k1HdWallet.deserializeTypeV1(serialization, password);
            default:
                throw new Error("Unsupported serialization type");
        }
    }
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch(untypedRoot.type){
            case serializationTypeV1:
                {
                    const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
                    const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
                    const { mnemonic, accounts } = decryptedDocument;
                    (0, utils_1.assert)(typeof mnemonic === "string");
                    if (!Array.isArray(accounts)) throw new Error("Property 'accounts' is not an array");
                    if (!accounts.every((account)=>isDerivationJson(account))) throw new Error("Account is not in the correct format.");
                    const firstPrefix = accounts[0].prefix;
                    if (!accounts.every(({ prefix })=>prefix === firstPrefix)) throw new Error("Accounts do not all have the same prefix");
                    const hdPaths = accounts.map(({ hdPath })=>(0, crypto_1.stringToPath)(hdPath));
                    return Secp256k1HdWallet.fromMnemonic(mnemonic, {
                        hdPaths: hdPaths,
                        prefix: firstPrefix
                    });
                }
            default:
                throw new Error("Unsupported serialization type");
        }
    }
    static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root)) throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
    }
    /** Base secret */ secret;
    /** BIP39 seed */ seed;
    /** Derivation instruction */ accounts;
    constructor(mnemonic, options){
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        const prefix = options.prefix ?? defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath)=>({
                hdPath: hdPath,
                prefix
            }));
    }
    get mnemonic() {
        return this.secret.toString();
    }
    async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address })=>({
                algo: algo,
                pubkey: pubkey,
                address: address
            }));
    }
    async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address })=>address === signerAddress);
        if (account === undefined) throw new Error(`Address ${signerAddress} not found in wallet`);
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([
            ...signature.r(32),
            ...signature.s(32)
        ]);
        return {
            signed: signDoc,
            signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
    }
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * @param password The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
    }
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF options. If this
     * is not the case, the wallet cannot be restored with the original password.
     *
     * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
     */ async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
            mnemonic: this.mnemonic,
            accounts: this.accounts.map(({ hdPath, prefix })=>({
                    hdPath: (0, crypto_1.pathToString)(hdPath),
                    prefix: prefix
                }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
            algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
            type: serializationTypeV1,
            kdf: kdfConfiguration,
            encryption: encryptionConfiguration,
            data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
    }
    async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
            privkey: privkey,
            pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
    }
    async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix })=>{
            const { privkey, pubkey } = await this.getKeyPair(hdPath);
            const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
            return {
                algo: "secp256k1",
                privkey: privkey,
                pubkey: pubkey,
                address: address
            };
        }));
    }
}
exports.Secp256k1HdWallet = Secp256k1HdWallet;

},{"bf557efe044f1957":"kTd5b","f0331bce450fb1bc":"enCPS","f84de96b69818aba":"3R4mb","36b12f5209800701":"jpNc8","fcdacd62aa98c32":"hdWZv","c292de170e6e4573":"2oD6x","4b1040d5daa1eab5":"amSWz","8543848abf7eec7d":"9EHAa"}],"2oD6x":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeSecp256k1Signature = encodeSecp256k1Signature;
exports.decodeSignature = decodeSignature;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("7ef68ff2c53bc1a1");
const encoding_2 = require("7ee6e8d3900c7624");
const pubkeys_1 = require("77fef0e267e765c2");
/**
 * Takes a binary pubkey and signature to create a signature object
 *
 * @param pubkey a compressed secp256k1 public key
 * @param signature a 64 byte fixed length representation of secp256k1 signature components r and s
 */ function encodeSecp256k1Signature(pubkey, signature) {
    if (signature.length !== 64) throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
    return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
    };
}
function decodeSignature(signature) {
    switch(signature.pub_key.type){
        // Note: please don't add cases here without writing additional unit tests
        case pubkeys_1.pubkeyType.secp256k1:
            return {
                pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
                signature: (0, encoding_1.fromBase64)(signature.signature)
            };
        default:
            throw new Error("Unsupported pubkey type");
    }
}

},{"7ef68ff2c53bc1a1":"enCPS","7ee6e8d3900c7624":"g8Pi0","77fef0e267e765c2":"gbh6J"}],"amSWz":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sortedJsonStringify = sortedJsonStringify;
exports.makeSignDoc = makeSignDoc;
exports.escapeCharacters = escapeCharacters;
exports.serializeSignDoc = serializeSignDoc;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("5d667c5a04e456e5");
const math_1 = require("188a71d5ab7b7470");
function sortedObject(obj) {
    if (typeof obj !== "object" || obj === null) return obj;
    if (Array.isArray(obj)) return obj.map(sortedObject);
    const sortedKeys = Object.keys(obj).sort();
    const result = {};
    // NOTE: Use forEach instead of reduce for performance with large objects eg Wasm code
    sortedKeys.forEach((key)=>{
        result[key] = sortedObject(obj[key]);
    });
    return result;
}
/** Returns a JSON string with objects sorted by key */ // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function sortedJsonStringify(obj) {
    return JSON.stringify(sortedObject(obj));
}
function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
    return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee: fee,
        msgs: msgs,
        memo: memo || "",
        ...timeout_height && {
            timeout_height: timeout_height.toString()
        }
    };
}
/**
 * Takes a valid JSON document and performs the following escapings in string values:
 *
 * `&` -> `\u0026`
 * `<` -> `\u003c`
 * `>` -> `\u003e`
 *
 * Since those characters do not occur in other places of the JSON document, only
 * string values are affected.
 *
 * If the input is invalid JSON, the behaviour is undefined.
 */ function escapeCharacters(input) {
    // When we migrate to target es2021 or above, we can use replaceAll instead of global patterns.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll
    const amp = /&/g;
    const lt = /</g;
    const gt = />/g;
    return input.replace(amp, "\\u0026").replace(lt, "\\u003c").replace(gt, "\\u003e");
}
function serializeSignDoc(signDoc) {
    const serialized = escapeCharacters(sortedJsonStringify(signDoc));
    return (0, encoding_1.toUtf8)(serialized);
}

},{"5d667c5a04e456e5":"enCPS","188a71d5ab7b7470":"e8aug"}],"9EHAa":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
exports.executeKdf = executeKdf;
exports.encrypt = encrypt;
exports.decrypt = decrypt;
const crypto_1 = require("793f682caa756e9b");
const encoding_1 = require("a60f7d1f21c2b3e5");
const utils_1 = require("673524512a0f23c2");
/**
 * A fixed salt is chosen to archive a deterministic password to key derivation.
 * This reduces the scope of a potential rainbow attack to all CosmJS users.
 * Must be 16 bytes due to implementation limitations.
 */ exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
/**
 * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
 */ async function executeKdf(password, configuration) {
    switch(configuration.algorithm){
        case "argon2id":
            {
                const options = configuration.params;
                if (!(0, crypto_1.isArgon2idOptions)(options)) throw new Error("Invalid format of argon2id params");
                // Emulate a slower implementation. The fast WASM code may get removed.
                // This approximates the speed of using a pure JS implementation (@noble/hashes) in Node 22.
                const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
                const result = await crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
                await screamTest;
                return result;
            }
        default:
            throw new Error("Unsupported KDF algorithm");
    }
}
exports.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
};
/**
 * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
 */ async function encrypt(plaintext, encryptionKey, config) {
    switch(config.algorithm){
        case exports.supportedAlgorithms.xchacha20poly1305Ietf:
            {
                const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
                // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api
                return new Uint8Array([
                    ...nonce,
                    ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
                ]);
            }
        default:
            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
    }
}
/**
 * @deprecated Encryption support may be removed from CosmJS in a future version. If you actually use this, comment at https://github.com/cosmos/cosmjs/issues/1796
 */ async function decrypt(ciphertext, encryptionKey, config) {
    switch(config.algorithm){
        case exports.supportedAlgorithms.xchacha20poly1305Ietf:
            {
                const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
                return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
            }
        default:
            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
    }
}

},{"793f682caa756e9b":"kTd5b","a60f7d1f21c2b3e5":"enCPS","673524512a0f23c2":"3R4mb"}],"7pTgv":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Secp256k1Wallet = void 0;
const crypto_1 = require("6606b753a397575b");
const encoding_1 = require("36e2de7e6c8bb956");
const addresses_1 = require("ec20e0e780c91438");
const signature_1 = require("3e36a0ea31b568b4");
const signdoc_1 = require("c6d6715dd8562119");
/**
 * A wallet that holds a single secp256k1 keypair.
 *
 * If you want to work with BIP39 mnemonics and multiple accounts, use Secp256k1HdWallet.
 */ class Secp256k1Wallet {
    /**
     * Creates a Secp256k1Wallet from the given private key
     *
     * @param privkey The private key.
     * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
     */ static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
    }
    pubkey;
    privkey;
    prefix;
    constructor(privkey, pubkey, prefix){
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
    }
    get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
    }
    async getAccounts() {
        return [
            {
                algo: "secp256k1",
                address: this.address,
                pubkey: this.pubkey
            }
        ];
    }
    async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) throw new Error(`Address ${signerAddress} not found in wallet`);
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([
            ...signature.r(32),
            ...signature.s(32)
        ]);
        return {
            signed: signDoc,
            signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
    }
}
exports.Secp256k1Wallet = Secp256k1Wallet;

},{"6606b753a397575b":"kTd5b","36e2de7e6c8bb956":"enCPS","ec20e0e780c91438":"jpNc8","3e36a0ea31b568b4":"2oD6x","c6d6715dd8562119":"amSWz"}],"gEESx":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isStdTx = isStdTx;
exports.makeStdTx = makeStdTx;
function isStdTx(txValue) {
    const { memo, msg, fee, signatures } = txValue;
    return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
}
function makeStdTx(content, signatures) {
    return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [
            signatures
        ]
    };
}

},{}],"g8GJ3":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeAuthInfoBytes = makeAuthInfoBytes;
exports.makeSignDoc = makeSignDoc;
exports.makeSignBytes = makeSignBytes;
const utils_1 = require("c24b4be5dddcb7bd");
const signing_1 = require("d1132727b580df73");
const tx_1 = require("3ad56ce65fd72dc");
/**
 * Create signer infos from the provided signers.
 *
 * This implementation does not support different signing modes for the different signers.
 */ function makeSignerInfos(signers, signMode) {
    return signers.map(({ pubkey, sequence })=>({
            publicKey: pubkey,
            modeInfo: {
                single: {
                    mode: signMode
                }
            },
            sequence: BigInt(sequence)
        }));
}
/**
 * Creates and serializes an AuthInfo document.
 *
 * This implementation does not support different signing modes for the different signers.
 */ function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
    // Required arguments 4 and 5 were added in CosmJS 0.29. Use runtime checks to help our non-TS users.
    (0, utils_1.assert)(feeGranter === undefined || typeof feeGranter === "string", "feeGranter must be undefined or string");
    (0, utils_1.assert)(feePayer === undefined || typeof feePayer === "string", "feePayer must be undefined or string");
    const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
            amount: [
                ...feeAmount
            ],
            gasLimit: BigInt(gasLimit),
            granter: feeGranter,
            payer: feePayer
        }
    });
    return tx_1.AuthInfo.encode(authInfo).finish();
}
function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
    return {
        bodyBytes: bodyBytes,
        authInfoBytes: authInfoBytes,
        chainId: chainId,
        accountNumber: BigInt(accountNumber)
    };
}
function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
    const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber: accountNumber,
        authInfoBytes: authInfoBytes,
        bodyBytes: bodyBytes,
        chainId: chainId
    });
    return tx_1.SignDoc.encode(signDoc).finish();
}

},{"c24b4be5dddcb7bd":"3R4mb","d1132727b580df73":"9PT9z","3ad56ce65fd72dc":"dbom9"}],"3QlLM":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
exports.executeKdf = executeKdf;
exports.encrypt = encrypt;
exports.decrypt = decrypt;
const crypto_1 = require("f069ca4316f3d6f1");
const encoding_1 = require("652a1d07f7f8ab86");
const utils_1 = require("59c2e90fce49cef8");
/**
 * A fixed salt is chosen to archive a deterministic password to key derivation.
 * This reduces the scope of a potential rainbow attack to all CosmJS users.
 * Must be 16 bytes due to implementation limitations.
 */ exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
async function executeKdf(password, configuration) {
    switch(configuration.algorithm){
        case "argon2id":
            {
                const options = configuration.params;
                if (!(0, crypto_1.isArgon2idOptions)(options)) throw new Error("Invalid format of argon2id params");
                // Emulate a slower implementation. The fast WASM code may get removed.
                // This approximates the speed of using a pure JS implementation (@noble/hashes) in Node 22.
                const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
                const result = await crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
                await screamTest;
                return result;
            }
        default:
            throw new Error("Unsupported KDF algorithm");
    }
}
exports.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
};
async function encrypt(plaintext, encryptionKey, config) {
    switch(config.algorithm){
        case exports.supportedAlgorithms.xchacha20poly1305Ietf:
            {
                const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
                // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api
                return new Uint8Array([
                    ...nonce,
                    ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
                ]);
            }
        default:
            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
    }
}
async function decrypt(ciphertext, encryptionKey, config) {
    switch(config.algorithm){
        case exports.supportedAlgorithms.xchacha20poly1305Ietf:
            {
                const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
                return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
            }
        default:
            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
    }
}

},{"f069ca4316f3d6f1":"kTd5b","652a1d07f7f8ab86":"enCPS","59c2e90fce49cef8":"3R4mb"}],"cfdjd":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DirectSecp256k1Wallet = void 0;
const amino_1 = require("3593fc7098011730");
const crypto_1 = require("9cf13ecf9fb9efa3");
const encoding_1 = require("eebba4bf1efb92ff");
const signing_1 = require("4b9dfbad0b369341");
/**
 * A wallet that holds a single secp256k1 keypair.
 *
 * If you want to work with BIP39 mnemonics and multiple accounts, use DirectSecp256k1HdWallet.
 */ class DirectSecp256k1Wallet {
    /**
     * Creates a DirectSecp256k1Wallet from the given private key
     *
     * @param privkey The private key.
     * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
     */ static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
    }
    pubkey;
    privkey;
    prefix;
    constructor(privkey, pubkey, prefix){
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
    }
    get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
    }
    async getAccounts() {
        return [
            {
                algo: "secp256k1",
                address: this.address,
                pubkey: this.pubkey
            }
        ];
    }
    async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) throw new Error(`Address ${address} not found in wallet`);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([
            ...signature.r(32),
            ...signature.s(32)
        ]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
            signed: signDoc,
            signature: stdSignature
        };
    }
}
exports.DirectSecp256k1Wallet = DirectSecp256k1Wallet;

},{"3593fc7098011730":"bh8mf","9cf13ecf9fb9efa3":"kTd5b","eebba4bf1efb92ff":"enCPS","4b9dfbad0b369341":"g8GJ3"}],"4CrS9":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeCosmoshubPath = makeCosmoshubPath;
const crypto_1 = require("8afbb579a44823cf");
/**
 * The Cosmos Hub derivation path in the form `m/44'/118'/0'/0/a`
 * with 0-based account index `a`.
 */ function makeCosmoshubPath(a) {
    return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
    ];
}

},{"8afbb579a44823cf":"kTd5b"}],"jKcfJ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodePubkey = encodePubkey;
exports.anyToSinglePubkey = anyToSinglePubkey;
exports.decodePubkey = decodePubkey;
exports.decodeOptionalPubkey = decodeOptionalPubkey;
const amino_1 = require("5b5a99ee64504c80");
const encoding_1 = require("174a694cc751726e");
const math_1 = require("5a2477a6262edd30");
const keys_1 = require("8f61d4cbc62ef4a7");
const keys_2 = require("b9cf45f80dcb9b64");
const keys_3 = require("ae7e531de7af9dad");
const any_1 = require("3ba9e9ce39014f19");
/**
 * Takes a pubkey in the Amino JSON object style (type/value wrapper)
 * and converts it into a protobuf `Any`.
 *
 * This is the reverse operation to `decodePubkey`.
 */ function encodePubkey(pubkey) {
    if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
            key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
            typeUrl: "/cosmos.crypto.secp256k1.PubKey",
            value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
    } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
            key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
            typeUrl: "/cosmos.crypto.ed25519.PubKey",
            value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
    } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
            threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
            publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
            typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
            value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
    } else throw new Error(`Pubkey type ${pubkey.type} not recognized`);
}
/**
 * Decodes a single pubkey (i.e. not a multisig pubkey) from `Any` into
 * `SinglePubkey`.
 *
 * In most cases you probably want to use `decodePubkey`.
 */ function anyToSinglePubkey(pubkey) {
    switch(pubkey.typeUrl){
        case "/cosmos.crypto.secp256k1.PubKey":
            {
                const { key } = keys_3.PubKey.decode(pubkey.value);
                return (0, amino_1.encodeSecp256k1Pubkey)(key);
            }
        case "/cosmos.crypto.ed25519.PubKey":
            {
                const { key } = keys_1.PubKey.decode(pubkey.value);
                return (0, amino_1.encodeEd25519Pubkey)(key);
            }
        default:
            throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
    }
}
/**
 * Decodes a pubkey from a protobuf `Any` into `Pubkey`.
 * This supports single pubkeys such as Cosmos ed25519 and secp256k1 keys
 * as well as multisig threshold pubkeys.
 */ function decodePubkey(pubkey) {
    switch(pubkey.typeUrl){
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey":
            return anyToSinglePubkey(pubkey);
        case "/cosmos.crypto.multisig.LegacyAminoPubKey":
            {
                const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
                const out = {
                    type: "tendermint/PubKeyMultisigThreshold",
                    value: {
                        threshold: threshold.toString(),
                        pubkeys: publicKeys.map(anyToSinglePubkey)
                    }
                };
                return out;
            }
        default:
            throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
    }
}
/**
 * Decodes an optional pubkey from a protobuf `Any` into `Pubkey | null`.
 * This supports single pubkeys such as Cosmos ed25519 and secp256k1 keys
 * as well as multisig threshold pubkeys.
 */ function decodeOptionalPubkey(pubkey) {
    if (!pubkey) return null;
    if (pubkey.typeUrl) {
        if (pubkey.value.length) // both set
        return decodePubkey(pubkey);
        else throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
    } else {
        if (pubkey.value.length) throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        else // both unset, assuming this empty instance means null
        return null;
    }
}

},{"5b5a99ee64504c80":"bh8mf","174a694cc751726e":"enCPS","5a2477a6262edd30":"e8aug","8f61d4cbc62ef4a7":"4JOA7","b9cf45f80dcb9b64":"a3hdB","ae7e531de7af9dad":"eEu9J","3ba9e9ce39014f19":"56aJC"}],"4JOA7":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("edcb8fb07c571bc");
const helpers_1 = require("769718489b2f5d62");
exports.protobufPackage = "cosmos.crypto.ed25519";
function createBasePubKey() {
    return {
        key: new Uint8Array()
    };
}
exports.PubKey = {
    typeUrl: "/cosmos.crypto.ed25519.PubKey",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
    }
};
function createBasePrivKey() {
    return {
        key: new Uint8Array()
    };
}
exports.PrivKey = {
    typeUrl: "/cosmos.crypto.ed25519.PrivKey",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
    }
};

},{"edcb8fb07c571bc":"bi36x","769718489b2f5d62":"eYjRL"}],"a3hdB":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LegacyAminoPubKey = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("22af68399d41deb0");
const binary_1 = require("60cc6ffbf60b898b");
const helpers_1 = require("7c8a3fcaeb30769");
exports.protobufPackage = "cosmos.crypto.multisig";
function createBaseLegacyAminoPubKey() {
    return {
        threshold: 0,
        publicKeys: []
    };
}
exports.LegacyAminoPubKey = {
    typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== 0) writer.uint32(8).uint32(message.threshold);
        for (const v of message.publicKeys)any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLegacyAminoPubKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.threshold = reader.uint32();
                    break;
                case 2:
                    message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseLegacyAminoPubKey();
        if ((0, helpers_1.isSet)(object.threshold)) obj.threshold = Number(object.threshold);
        if (Array.isArray(object?.publicKeys)) obj.publicKeys = object.publicKeys.map((e)=>any_1.Any.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.threshold !== undefined && (obj.threshold = Math.round(message.threshold));
        if (message.publicKeys) obj.publicKeys = message.publicKeys.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.publicKeys = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseLegacyAminoPubKey();
        message.threshold = object.threshold ?? 0;
        message.publicKeys = object.publicKeys?.map((e)=>any_1.Any.fromPartial(e)) || [];
        return message;
    }
};

},{"22af68399d41deb0":"56aJC","60cc6ffbf60b898b":"bi36x","7c8a3fcaeb30769":"eYjRL"}],"eEu9J":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("e3be93d7c19a45fe");
const helpers_1 = require("87013fc385bdcaad");
exports.protobufPackage = "cosmos.crypto.secp256k1";
function createBasePubKey() {
    return {
        key: new Uint8Array()
    };
}
exports.PubKey = {
    typeUrl: "/cosmos.crypto.secp256k1.PubKey",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
    }
};
function createBasePrivKey() {
    return {
        key: new Uint8Array()
    };
}
exports.PrivKey = {
    typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
    }
};

},{"e3be93d7c19a45fe":"bi36x","87013fc385bdcaad":"eYjRL"}],"29um8":[function(require,module,exports,__globalThis) {
var Buffer = require("a868a9ba74db4997").Buffer;
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Registry = void 0;
exports.isTelescopeGeneratedType = isTelescopeGeneratedType;
exports.isTsProtoGeneratedType = isTsProtoGeneratedType;
exports.isPbjsGeneratedType = isPbjsGeneratedType;
exports.isTxBodyEncodeObject = isTxBodyEncodeObject;
const tx_1 = require("ac26876b87d3db2a");
const coin_1 = require("18eb15c10e13917f");
const tx_2 = require("2cdbf08ac0978a77");
const any_1 = require("6fac9790719987e9");
function isTelescopeGeneratedType(type) {
    const casted = type;
    return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
}
function isTsProtoGeneratedType(type) {
    return typeof type.fromPartial === "function";
}
function isPbjsGeneratedType(type) {
    return !isTsProtoGeneratedType(type);
}
const defaultTypeUrls = {
    cosmosCoin: "/cosmos.base.v1beta1.Coin",
    cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
    cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
    googleAny: "/google.protobuf.Any"
};
function isTxBodyEncodeObject(encodeObject) {
    return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
}
class Registry {
    types;
    /**
     * Creates a new Registry for mapping protobuf type identifiers/type URLs to
     * actual implementations. Those implementations are typically generated with ts-proto
     * but we also support protobuf.js as a type generator.
     *
     * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
     * for historic reasons. Those can be overridden by customTypes.
     *
     * There are currently two methods for adding new types:
     * 1. Passing types to the constructor.
     * 2. Using the `register()` method
     */ constructor(customTypes){
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([
            ...customTypes
        ]) : new Map([
            [
                cosmosCoin,
                coin_1.Coin
            ],
            [
                cosmosMsgSend,
                tx_1.MsgSend
            ]
        ]);
    }
    register(typeUrl, type) {
        this.types.set(typeUrl, type);
    }
    /**
     * Looks up a type that was previously added to the registry.
     *
     * The generator information (ts-proto or pbjs) gets lost along the way.
     * If you need to work with the result type in TypeScript, you can use:
     *
     * ```
     * import { assert } from "@cosmjs/utils";
     *
     * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
     * assert(Coin); // Ensures not unset
     * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
     *
     * // Coin is typed TsProtoGeneratedType now.
     * ```
     */ lookupType(typeUrl) {
        return this.types.get(typeUrl);
    }
    lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) throw new Error(`Unregistered type url: ${typeUrl}`);
        return type;
    }
    /**
     * Takes a typeUrl/value pair and encodes the value to protobuf if
     * the given type was previously registered.
     *
     * If the value has to be wrapped in an Any, this needs to be done
     * manually after this call. Or use `encodeAsAny` instead.
     */ encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) return this.encodeTxBody(value);
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
    }
    /**
     * Takes a typeUrl/value pair and encodes the value to an Any if
     * the given type was previously registered.
     */ encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
            typeUrl: encodeObject.typeUrl,
            value: binaryValue
        });
    }
    encodeTxBody(txBodyFields) {
        const wrappedMessages = txBodyFields.messages.map((message)=>this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
            ...txBodyFields,
            timeoutHeight: BigInt(txBodyFields.timeoutHeight?.toString() ?? "0"),
            messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
    }
    decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) return this.decodeTxBody(value);
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val])=>{
            if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) decoded[key] = Uint8Array.from(val);
        });
        return decoded;
    }
    decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
            ...decodedTxBody,
            messages: decodedTxBody.messages.map(({ typeUrl: typeUrl, value })=>{
                if (!typeUrl) throw new Error("Missing type_url in Any");
                if (!value) throw new Error("Missing value in Any");
                return this.decode({
                    typeUrl,
                    value
                });
            })
        };
    }
}
exports.Registry = Registry;

},{"a868a9ba74db4997":"bCaf4","ac26876b87d3db2a":"59s2S","18eb15c10e13917f":"1ymyZ","2cdbf08ac0978a77":"dbom9","6fac9790719987e9":"56aJC"}],"59s2S":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgSetSendEnabledResponse = exports.MsgSetSendEnabled = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("dd624301291bc9d3");
const bank_1 = require("878f25ac7afe7c9d");
const binary_1 = require("d4e02df61ae6f1e1");
const helpers_1 = require("60fd4df11aa06f76");
exports.protobufPackage = "cosmos.bank.v1beta1";
function createBaseMsgSend() {
    return {
        fromAddress: "",
        toAddress: "",
        amount: []
    };
}
exports.MsgSend = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") writer.uint32(10).string(message.fromAddress);
        if (message.toAddress !== "") writer.uint32(18).string(message.toAddress);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fromAddress = reader.string();
                    break;
                case 2:
                    message.toAddress = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSend();
        if ((0, helpers_1.isSet)(object.fromAddress)) obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress)) obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSend();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgSendResponse() {
    return {};
}
exports.MsgSendResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgSendResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgSendResponse();
        return message;
    }
};
function createBaseMsgMultiSend() {
    return {
        inputs: [],
        outputs: []
    };
}
exports.MsgMultiSend = {
    typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.inputs)bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.outputs)bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgMultiSend();
        if (Array.isArray(object?.inputs)) obj.inputs = object.inputs.map((e)=>bank_1.Input.fromJSON(e));
        if (Array.isArray(object?.outputs)) obj.outputs = object.outputs.map((e)=>bank_1.Output.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.inputs) obj.inputs = message.inputs.map((e)=>e ? bank_1.Input.toJSON(e) : undefined);
        else obj.inputs = [];
        if (message.outputs) obj.outputs = message.outputs.map((e)=>e ? bank_1.Output.toJSON(e) : undefined);
        else obj.outputs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgMultiSend();
        message.inputs = object.inputs?.map((e)=>bank_1.Input.fromPartial(e)) || [];
        message.outputs = object.outputs?.map((e)=>bank_1.Output.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgMultiSendResponse() {
    return {};
}
exports.MsgMultiSendResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgMultiSendResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgMultiSendResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: bank_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        if (message.params !== undefined) bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = bank_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params)) obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== undefined && object.params !== null) message.params = bank_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
function createBaseMsgSetSendEnabled() {
    return {
        authority: "",
        sendEnabled: [],
        useDefaultFor: []
    };
}
exports.MsgSetSendEnabled = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        for (const v of message.sendEnabled)bank_1.SendEnabled.encode(v, writer.uint32(18).fork()).ldelim();
        for (const v of message.useDefaultFor)writer.uint32(26).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabled();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.useDefaultFor.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSetSendEnabled();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if (Array.isArray(object?.sendEnabled)) obj.sendEnabled = object.sendEnabled.map((e)=>bank_1.SendEnabled.fromJSON(e));
        if (Array.isArray(object?.useDefaultFor)) obj.useDefaultFor = object.useDefaultFor.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        if (message.sendEnabled) obj.sendEnabled = message.sendEnabled.map((e)=>e ? bank_1.SendEnabled.toJSON(e) : undefined);
        else obj.sendEnabled = [];
        if (message.useDefaultFor) obj.useDefaultFor = message.useDefaultFor.map((e)=>e);
        else obj.useDefaultFor = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSetSendEnabled();
        message.authority = object.authority ?? "";
        message.sendEnabled = object.sendEnabled?.map((e)=>bank_1.SendEnabled.fromPartial(e)) || [];
        message.useDefaultFor = object.useDefaultFor?.map((e)=>e) || [];
        return message;
    }
};
function createBaseMsgSetSendEnabledResponse() {
    return {};
}
exports.MsgSetSendEnabledResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabledResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgSetSendEnabledResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgSetSendEnabledResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.SetSendEnabled = this.SetSendEnabled.bind(this);
    }
    Send(request) {
        const data = exports.MsgSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data);
        return promise.then((data)=>exports.MsgSendResponse.decode(new binary_1.BinaryReader(data)));
    }
    MultiSend(request) {
        const data = exports.MsgMultiSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data);
        return promise.then((data)=>exports.MsgMultiSendResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    SetSendEnabled(request) {
        const data = exports.MsgSetSendEnabled.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", data);
        return promise.then((data)=>exports.MsgSetSendEnabledResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"dd624301291bc9d3":"1ymyZ","878f25ac7afe7c9d":"cn9CY","d4e02df61ae6f1e1":"bi36x","60fd4df11aa06f76":"eYjRL"}],"cn9CY":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("8b291798108ab285");
const binary_1 = require("c6f86dca5f87abe2");
const helpers_1 = require("74e2823b3d2a8d1f");
exports.protobufPackage = "cosmos.bank.v1beta1";
function createBaseParams() {
    return {
        sendEnabled: [],
        defaultSendEnabled: false
    };
}
exports.Params = {
    typeUrl: "/cosmos.bank.v1beta1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.sendEnabled)exports.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.defaultSendEnabled === true) writer.uint32(16).bool(message.defaultSendEnabled);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.defaultSendEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if (Array.isArray(object?.sendEnabled)) obj.sendEnabled = object.sendEnabled.map((e)=>exports.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.defaultSendEnabled)) obj.defaultSendEnabled = Boolean(object.defaultSendEnabled);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.sendEnabled) obj.sendEnabled = message.sendEnabled.map((e)=>e ? exports.SendEnabled.toJSON(e) : undefined);
        else obj.sendEnabled = [];
        message.defaultSendEnabled !== undefined && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.sendEnabled = object.sendEnabled?.map((e)=>exports.SendEnabled.fromPartial(e)) || [];
        message.defaultSendEnabled = object.defaultSendEnabled ?? false;
        return message;
    }
};
function createBaseSendEnabled() {
    return {
        denom: "",
        enabled: false
    };
}
exports.SendEnabled = {
    typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        if (message.enabled === true) writer.uint32(16).bool(message.enabled);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSendEnabled();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.enabled)) obj.enabled = Boolean(object.enabled);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.enabled !== undefined && (obj.enabled = message.enabled);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSendEnabled();
        message.denom = object.denom ?? "";
        message.enabled = object.enabled ?? false;
        return message;
    }
};
function createBaseInput() {
    return {
        address: "",
        coins: []
    };
}
exports.Input = {
    typeUrl: "/cosmos.bank.v1beta1.Input",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        for (const v of message.coins)coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseInput();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if (Array.isArray(object?.coins)) obj.coins = object.coins.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        if (message.coins) obj.coins = message.coins.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.coins = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseInput();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseOutput() {
    return {
        address: "",
        coins: []
    };
}
exports.Output = {
    typeUrl: "/cosmos.bank.v1beta1.Output",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        for (const v of message.coins)coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseOutput();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if (Array.isArray(object?.coins)) obj.coins = object.coins.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        if (message.coins) obj.coins = message.coins.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.coins = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseOutput();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseSupply() {
    return {
        total: []
    };
}
exports.Supply = {
    typeUrl: "/cosmos.bank.v1beta1.Supply",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.total)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSupply();
        if (Array.isArray(object?.total)) obj.total = object.total.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.total) obj.total = message.total.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.total = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSupply();
        message.total = object.total?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseDenomUnit() {
    return {
        denom: "",
        exponent: 0,
        aliases: []
    };
}
exports.DenomUnit = {
    typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        if (message.exponent !== 0) writer.uint32(16).uint32(message.exponent);
        for (const v of message.aliases)writer.uint32(26).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.exponent = reader.uint32();
                    break;
                case 3:
                    message.aliases.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDenomUnit();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.exponent)) obj.exponent = Number(object.exponent);
        if (Array.isArray(object?.aliases)) obj.aliases = object.aliases.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.exponent !== undefined && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) obj.aliases = message.aliases.map((e)=>e);
        else obj.aliases = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDenomUnit();
        message.denom = object.denom ?? "";
        message.exponent = object.exponent ?? 0;
        message.aliases = object.aliases?.map((e)=>e) || [];
        return message;
    }
};
function createBaseMetadata() {
    return {
        description: "",
        denomUnits: [],
        base: "",
        display: "",
        name: "",
        symbol: "",
        uri: "",
        uriHash: ""
    };
}
exports.Metadata = {
    typeUrl: "/cosmos.bank.v1beta1.Metadata",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== "") writer.uint32(10).string(message.description);
        for (const v of message.denomUnits)exports.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.base !== "") writer.uint32(26).string(message.base);
        if (message.display !== "") writer.uint32(34).string(message.display);
        if (message.name !== "") writer.uint32(42).string(message.name);
        if (message.symbol !== "") writer.uint32(50).string(message.symbol);
        if (message.uri !== "") writer.uint32(58).string(message.uri);
        if (message.uriHash !== "") writer.uint32(66).string(message.uriHash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.base = reader.string();
                    break;
                case 4:
                    message.display = reader.string();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                case 6:
                    message.symbol = reader.string();
                    break;
                case 7:
                    message.uri = reader.string();
                    break;
                case 8:
                    message.uriHash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMetadata();
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        if (Array.isArray(object?.denomUnits)) obj.denomUnits = object.denomUnits.map((e)=>exports.DenomUnit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.base)) obj.base = String(object.base);
        if ((0, helpers_1.isSet)(object.display)) obj.display = String(object.display);
        if ((0, helpers_1.isSet)(object.name)) obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.symbol)) obj.symbol = String(object.symbol);
        if ((0, helpers_1.isSet)(object.uri)) obj.uri = String(object.uri);
        if ((0, helpers_1.isSet)(object.uriHash)) obj.uriHash = String(object.uriHash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description);
        if (message.denomUnits) obj.denomUnits = message.denomUnits.map((e)=>e ? exports.DenomUnit.toJSON(e) : undefined);
        else obj.denomUnits = [];
        message.base !== undefined && (obj.base = message.base);
        message.display !== undefined && (obj.display = message.display);
        message.name !== undefined && (obj.name = message.name);
        message.symbol !== undefined && (obj.symbol = message.symbol);
        message.uri !== undefined && (obj.uri = message.uri);
        message.uriHash !== undefined && (obj.uriHash = message.uriHash);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMetadata();
        message.description = object.description ?? "";
        message.denomUnits = object.denomUnits?.map((e)=>exports.DenomUnit.fromPartial(e)) || [];
        message.base = object.base ?? "";
        message.display = object.display ?? "";
        message.name = object.name ?? "";
        message.symbol = object.symbol ?? "";
        message.uri = object.uri ?? "";
        message.uriHash = object.uriHash ?? "";
        return message;
    }
};

},{"8b291798108ab285":"1ymyZ","c6f86dca5f87abe2":"bi36x","74e2823b3d2a8d1f":"eYjRL"}],"aav1G":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isOfflineDirectSigner = isOfflineDirectSigner;
function isOfflineDirectSigner(signer) {
    return signer.signDirect !== undefined;
}

},{}],"1HQnV":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.ModuleCredential = exports.ModuleAccount = exports.BaseAccount = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("1aff38eea2619aa4");
const binary_1 = require("9fe7e718311bdb72");
const helpers_1 = require("2b39194ccb9ec691");
exports.protobufPackage = "cosmos.auth.v1beta1";
function createBaseBaseAccount() {
    return {
        address: "",
        pubKey: undefined,
        accountNumber: BigInt(0),
        sequence: BigInt(0)
    };
}
exports.BaseAccount = {
    typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.pubKey !== undefined) any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        if (message.accountNumber !== BigInt(0)) writer.uint32(24).uint64(message.accountNumber);
        if (message.sequence !== BigInt(0)) writer.uint32(32).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBaseAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.pubKey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.accountNumber = reader.uint64();
                    break;
                case 4:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBaseAccount();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pubKey)) obj.pubKey = any_1.Any.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.accountNumber)) obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : undefined);
        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBaseAccount();
        message.address = object.address ?? "";
        if (object.pubKey !== undefined && object.pubKey !== null) message.pubKey = any_1.Any.fromPartial(object.pubKey);
        if (object.accountNumber !== undefined && object.accountNumber !== null) message.accountNumber = BigInt(object.accountNumber.toString());
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseModuleAccount() {
    return {
        baseAccount: undefined,
        name: "",
        permissions: []
    };
}
exports.ModuleAccount = {
    typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== undefined) exports.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        if (message.name !== "") writer.uint32(18).string(message.name);
        for (const v of message.permissions)writer.uint32(26).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModuleAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.baseAccount = exports.BaseAccount.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.permissions.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseModuleAccount();
        if ((0, helpers_1.isSet)(object.baseAccount)) obj.baseAccount = exports.BaseAccount.fromJSON(object.baseAccount);
        if ((0, helpers_1.isSet)(object.name)) obj.name = String(object.name);
        if (Array.isArray(object?.permissions)) obj.permissions = object.permissions.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.baseAccount !== undefined && (obj.baseAccount = message.baseAccount ? exports.BaseAccount.toJSON(message.baseAccount) : undefined);
        message.name !== undefined && (obj.name = message.name);
        if (message.permissions) obj.permissions = message.permissions.map((e)=>e);
        else obj.permissions = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseModuleAccount();
        if (object.baseAccount !== undefined && object.baseAccount !== null) message.baseAccount = exports.BaseAccount.fromPartial(object.baseAccount);
        message.name = object.name ?? "";
        message.permissions = object.permissions?.map((e)=>e) || [];
        return message;
    }
};
function createBaseModuleCredential() {
    return {
        moduleName: "",
        derivationKeys: []
    };
}
exports.ModuleCredential = {
    typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.moduleName !== "") writer.uint32(10).string(message.moduleName);
        for (const v of message.derivationKeys)writer.uint32(18).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModuleCredential();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.moduleName = reader.string();
                    break;
                case 2:
                    message.derivationKeys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseModuleCredential();
        if ((0, helpers_1.isSet)(object.moduleName)) obj.moduleName = String(object.moduleName);
        if (Array.isArray(object?.derivationKeys)) obj.derivationKeys = object.derivationKeys.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.moduleName !== undefined && (obj.moduleName = message.moduleName);
        if (message.derivationKeys) obj.derivationKeys = message.derivationKeys.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.derivationKeys = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseModuleCredential();
        message.moduleName = object.moduleName ?? "";
        message.derivationKeys = object.derivationKeys?.map((e)=>e) || [];
        return message;
    }
};
function createBaseParams() {
    return {
        maxMemoCharacters: BigInt(0),
        txSigLimit: BigInt(0),
        txSizeCostPerByte: BigInt(0),
        sigVerifyCostEd25519: BigInt(0),
        sigVerifyCostSecp256k1: BigInt(0)
    };
}
exports.Params = {
    typeUrl: "/cosmos.auth.v1beta1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxMemoCharacters !== BigInt(0)) writer.uint32(8).uint64(message.maxMemoCharacters);
        if (message.txSigLimit !== BigInt(0)) writer.uint32(16).uint64(message.txSigLimit);
        if (message.txSizeCostPerByte !== BigInt(0)) writer.uint32(24).uint64(message.txSizeCostPerByte);
        if (message.sigVerifyCostEd25519 !== BigInt(0)) writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        if (message.sigVerifyCostSecp256k1 !== BigInt(0)) writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.maxMemoCharacters = reader.uint64();
                    break;
                case 2:
                    message.txSigLimit = reader.uint64();
                    break;
                case 3:
                    message.txSizeCostPerByte = reader.uint64();
                    break;
                case 4:
                    message.sigVerifyCostEd25519 = reader.uint64();
                    break;
                case 5:
                    message.sigVerifyCostSecp256k1 = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxMemoCharacters)) obj.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        if ((0, helpers_1.isSet)(object.txSigLimit)) obj.txSigLimit = BigInt(object.txSigLimit.toString());
        if ((0, helpers_1.isSet)(object.txSizeCostPerByte)) obj.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostEd25519)) obj.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostSecp256k1)) obj.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.maxMemoCharacters !== undefined && (obj.maxMemoCharacters = (message.maxMemoCharacters || BigInt(0)).toString());
        message.txSigLimit !== undefined && (obj.txSigLimit = (message.txSigLimit || BigInt(0)).toString());
        message.txSizeCostPerByte !== undefined && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || BigInt(0)).toString());
        message.sigVerifyCostEd25519 !== undefined && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || BigInt(0)).toString());
        message.sigVerifyCostSecp256k1 !== undefined && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        if (object.maxMemoCharacters !== undefined && object.maxMemoCharacters !== null) message.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        if (object.txSigLimit !== undefined && object.txSigLimit !== null) message.txSigLimit = BigInt(object.txSigLimit.toString());
        if (object.txSizeCostPerByte !== undefined && object.txSizeCostPerByte !== null) message.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        if (object.sigVerifyCostEd25519 !== undefined && object.sigVerifyCostEd25519 !== null) message.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        if (object.sigVerifyCostSecp256k1 !== undefined && object.sigVerifyCostSecp256k1 !== null) message.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        return message;
    }
};

},{"1aff38eea2619aa4":"56aJC","9fe7e718311bdb72":"bi36x","2b39194ccb9ec691":"eYjRL"}],"5O0Qj":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PermanentLockedAccount = exports.PeriodicVestingAccount = exports.Period = exports.DelayedVestingAccount = exports.ContinuousVestingAccount = exports.BaseVestingAccount = exports.protobufPackage = void 0;
/* eslint-disable */ const auth_1 = require("9179fc729b0dc6db");
const coin_1 = require("62f3b9007110a642");
const binary_1 = require("a00b8b12498cb18c");
const helpers_1 = require("eabff0212a247e3f");
exports.protobufPackage = "cosmos.vesting.v1beta1";
function createBaseBaseVestingAccount() {
    return {
        baseAccount: undefined,
        originalVesting: [],
        delegatedFree: [],
        delegatedVesting: [],
        endTime: BigInt(0)
    };
}
exports.BaseVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== undefined) auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        for (const v of message.originalVesting)coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        for (const v of message.delegatedFree)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        for (const v of message.delegatedVesting)coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        if (message.endTime !== BigInt(0)) writer.uint32(40).int64(message.endTime);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBaseVestingAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.endTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBaseVestingAccount();
        if ((0, helpers_1.isSet)(object.baseAccount)) obj.baseAccount = auth_1.BaseAccount.fromJSON(object.baseAccount);
        if (Array.isArray(object?.originalVesting)) obj.originalVesting = object.originalVesting.map((e)=>coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.delegatedFree)) obj.delegatedFree = object.delegatedFree.map((e)=>coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.delegatedVesting)) obj.delegatedVesting = object.delegatedVesting.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime)) obj.endTime = BigInt(object.endTime.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.baseAccount !== undefined && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : undefined);
        if (message.originalVesting) obj.originalVesting = message.originalVesting.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.originalVesting = [];
        if (message.delegatedFree) obj.delegatedFree = message.delegatedFree.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.delegatedFree = [];
        if (message.delegatedVesting) obj.delegatedVesting = message.delegatedVesting.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.delegatedVesting = [];
        message.endTime !== undefined && (obj.endTime = (message.endTime || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBaseVestingAccount();
        if (object.baseAccount !== undefined && object.baseAccount !== null) message.baseAccount = auth_1.BaseAccount.fromPartial(object.baseAccount);
        message.originalVesting = object.originalVesting?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.delegatedFree = object.delegatedFree?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.delegatedVesting = object.delegatedVesting?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.endTime !== undefined && object.endTime !== null) message.endTime = BigInt(object.endTime.toString());
        return message;
    }
};
function createBaseContinuousVestingAccount() {
    return {
        baseVestingAccount: undefined,
        startTime: BigInt(0)
    };
}
exports.ContinuousVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== undefined) exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        if (message.startTime !== BigInt(0)) writer.uint32(16).int64(message.startTime);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContinuousVestingAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.startTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseContinuousVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount)) obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime)) obj.startTime = BigInt(object.startTime.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.baseVestingAccount !== undefined && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : undefined);
        message.startTime !== undefined && (obj.startTime = (message.startTime || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseContinuousVestingAccount();
        if (object.baseVestingAccount !== undefined && object.baseVestingAccount !== null) message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        if (object.startTime !== undefined && object.startTime !== null) message.startTime = BigInt(object.startTime.toString());
        return message;
    }
};
function createBaseDelayedVestingAccount() {
    return {
        baseVestingAccount: undefined
    };
}
exports.DelayedVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== undefined) exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelayedVestingAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDelayedVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount)) obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.baseVestingAccount !== undefined && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDelayedVestingAccount();
        if (object.baseVestingAccount !== undefined && object.baseVestingAccount !== null) message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        return message;
    }
};
function createBasePeriod() {
    return {
        length: BigInt(0),
        amount: []
    };
}
exports.Period = {
    typeUrl: "/cosmos.vesting.v1beta1.Period",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.length !== BigInt(0)) writer.uint32(8).int64(message.length);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.length = reader.int64();
                    break;
                case 2:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePeriod();
        if ((0, helpers_1.isSet)(object.length)) obj.length = BigInt(object.length.toString());
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.length !== undefined && (obj.length = (message.length || BigInt(0)).toString());
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBasePeriod();
        if (object.length !== undefined && object.length !== null) message.length = BigInt(object.length.toString());
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBasePeriodicVestingAccount() {
    return {
        baseVestingAccount: undefined,
        startTime: BigInt(0),
        vestingPeriods: []
    };
}
exports.PeriodicVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== undefined) exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        if (message.startTime !== BigInt(0)) writer.uint32(16).int64(message.startTime);
        for (const v of message.vestingPeriods)exports.Period.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePeriodicVestingAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.startTime = reader.int64();
                    break;
                case 3:
                    message.vestingPeriods.push(exports.Period.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount)) obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime)) obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object?.vestingPeriods)) obj.vestingPeriods = object.vestingPeriods.map((e)=>exports.Period.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.baseVestingAccount !== undefined && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : undefined);
        message.startTime !== undefined && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) obj.vestingPeriods = message.vestingPeriods.map((e)=>e ? exports.Period.toJSON(e) : undefined);
        else obj.vestingPeriods = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBasePeriodicVestingAccount();
        if (object.baseVestingAccount !== undefined && object.baseVestingAccount !== null) message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        if (object.startTime !== undefined && object.startTime !== null) message.startTime = BigInt(object.startTime.toString());
        message.vestingPeriods = object.vestingPeriods?.map((e)=>exports.Period.fromPartial(e)) || [];
        return message;
    }
};
function createBasePermanentLockedAccount() {
    return {
        baseVestingAccount: undefined
    };
}
exports.PermanentLockedAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== undefined) exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePermanentLockedAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount)) obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.baseVestingAccount !== undefined && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePermanentLockedAccount();
        if (object.baseVestingAccount !== undefined && object.baseVestingAccount !== null) message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        return message;
    }
};

},{"9179fc729b0dc6db":"1HQnV","62f3b9007110a642":"1ymyZ","a00b8b12498cb18c":"bi36x","eabff0212a247e3f":"eYjRL"}],"7vdok":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AminoTypes = void 0;
/**
 * A map from Stargate message types as used in the messages's `Any` type
 * to Amino types.
 */ class AminoTypes {
    // The map type here ensures uniqueness of the protobuf type URL in the key.
    // There is no uniqueness guarantee of the Amino type identifier in the type
    // system or constructor. Instead it's the user's responsibility to ensure
    // there is no overlap when fromAmino is called.
    register;
    constructor(types){
        this.register = types;
    }
    toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. ` + "If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. " + "If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.");
        return {
            type: converter.aminoType,
            value: converter.toAmino(value)
        };
    }
    fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }])=>aminoType === type);
        switch(matches.length){
            case 0:
                throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. ` + "If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. " + "If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.");
            case 1:
                {
                    const [typeUrl, converter] = matches[0];
                    return {
                        typeUrl: typeUrl,
                        value: converter.fromAmino(value)
                    };
                }
            default:
                throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value])=>key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
    }
}
exports.AminoTypes = AminoTypes;

},{}],"UX70m":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromTendermintEvent = fromTendermintEvent;
const encoding_1 = require("ccee04bb3d88b0e9");
/**
 * Takes a Tendermint 0.34 or 0.37 event with binary encoded key and value
 * and converts it into an `Event` with string attributes.
 */ function fromTendermintEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes.map((attr)=>({
                key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
                value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
            }))
    };
}

},{"ccee04bb3d88b0e9":"enCPS"}],"3phn0":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GasPrice = void 0;
exports.calculateFee = calculateFee;
const math_1 = require("ed6e843c3950ad28");
const proto_signing_1 = require("124f5eae6ce8e649");
/**
 * Denom checker for the Cosmos SDK 0.53 denom pattern
 * (https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/types/coin.go#L846).
 *
 * This is like a regexp but with helpful error messages.
 */ function checkDenom(denom) {
    if (denom.length < 3 || denom.length > 128) throw new Error("Denom must be between 3 and 128 characters");
}
/**
 * A gas price, i.e. the price of a single unit of gas. This is typically a fraction of
 * the smallest fee token unit, such as 0.012utoken.
 */ class GasPrice {
    amount;
    denom;
    constructor(amount, denom){
        if (!denom) throw new Error("denom must not be empty");
        this.amount = amount;
        this.denom = denom;
    }
    /**
     * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
     *
     * The denom must match the Cosmos SDK 0.53 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/types/coin.go#L846).
     * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
     *
     * Separators are not yet supported.
     */ static fromString(gasPrice) {
        // Use Decimal.fromUserInput and checkDenom for detailed checks and helpful error messages
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) throw new Error("Invalid gas price string");
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new GasPrice(decimalAmount, denom);
    }
    /**
     * Returns a string representation of this gas price, e.g. "0.025uatom".
     * This can be used as an input to `GasPrice.fromString`.
     */ toString() {
        return this.amount.toString() + this.denom;
    }
}
exports.GasPrice = GasPrice;
function calculateFee(gasLimit, gasPrice) {
    const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
    const { denom, amount: gasPriceAmount } = processedGasPrice;
    // Note: Amount can exceed the safe integer range (https://github.com/cosmos/cosmjs/issues/1134),
    // which we handle by converting from Decimal to string without going through number.
    const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
    return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
    };
}

},{"ed6e843c3950ad28":"e8aug","124f5eae6ce8e649":"2gdyE"}],"988PF":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseAttribute = parseAttribute;
exports.parseEvent = parseEvent;
exports.parseLog = parseLog;
exports.parseLogs = parseLogs;
exports.parseRawLog = parseRawLog;
exports.findAttribute = findAttribute;
/* eslint-disable @typescript-eslint/naming-convention */ const utils_1 = require("fa6ca3f11156b159");
function parseAttribute(input) {
    if (!(0, utils_1.isNonNullObject)(input)) throw new Error("Attribute must be a non-null object");
    const { key, value } = input;
    if (typeof key !== "string" || !key) throw new Error("Attribute's key must be a non-empty string");
    if (typeof value !== "string" && typeof value !== "undefined") throw new Error("Attribute's value must be a string or unset");
    return {
        key: key,
        value: value || ""
    };
}
function parseEvent(input) {
    if (!(0, utils_1.isNonNullObject)(input)) throw new Error("Event must be a non-null object");
    const { type, attributes } = input;
    if (typeof type !== "string" || type === "") throw new Error(`Event type must be a non-empty string`);
    if (!Array.isArray(attributes)) throw new Error("Event's attributes must be an array");
    return {
        type: type,
        attributes: attributes.map(parseAttribute)
    };
}
function parseLog(input) {
    if (!(0, utils_1.isNonNullObject)(input)) throw new Error("Log must be a non-null object");
    const { msg_index, log, events } = input;
    if (typeof msg_index !== "number") throw new Error("Log's msg_index must be a number");
    if (typeof log !== "string") throw new Error("Log's log must be a string");
    if (!Array.isArray(events)) throw new Error("Log's events must be an array");
    return {
        msg_index: msg_index,
        log: log,
        events: events.map(parseEvent)
    };
}
function parseLogs(input) {
    if (!Array.isArray(input)) throw new Error("Logs must be an array");
    return input.map(parseLog);
}
function parseRawLog(input) {
    // Cosmos SDK >= 0.50 gives us an empty string here. This should be handled like undefined.
    if (!input) return [];
    const logsToParse = JSON.parse(input).map(({ events }, i)=>({
            msg_index: i,
            events,
            log: ""
        }));
    return parseLogs(logsToParse);
}
/**
 * Searches in logs for the first event of the given event type and in that event
 * for the first first attribute with the given attribute key.
 *
 * Throws if the attribute was not found.
 */ function findAttribute(logs, eventType, attrKey) {
    const firstLogs = logs.find(()=>true);
    const out = firstLogs?.events.find((event)=>event.type === eventType)?.attributes.find((attr)=>attr.key === attrKey);
    if (!out) throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
    return out;
}

},{"fa6ca3f11156b159":"3R4mb"}],"MIuAK":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createStakingAminoConverters = exports.setupSlashingExtension = exports.isAminoMsgUnjail = exports.createSlashingAminoConverters = exports.setupMintExtension = exports.setupIbcExtension = exports.isMsgTransferEncodeObject = exports.ibcTypes = exports.isAminoMsgTransfer = exports.createIbcAminoConverters = exports.groupTypes = exports.createGroupAminoConverters = exports.setupGovExtension = exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgDeposit = exports.createGovAminoConverters = exports.setupFeegrantExtension = exports.feegrantTypes = exports.createFeegrantAminoConverters = exports.isAminoMsgSubmitEvidence = exports.createEvidenceAminoConverters = exports.setupDistributionExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgFundCommunityPool = exports.createDistributionAminoConverters = exports.isAminoMsgVerifyInvariant = exports.createCrysisAminoConverters = exports.setupBankExtension = exports.isMsgSendEncodeObject = exports.bankTypes = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.createBankAminoConverters = exports.setupAuthzExtension = exports.authzTypes = exports.createAuthzAminoConverters = exports.setupAuthExtension = void 0;
exports.vestingTypes = exports.isAminoMsgCreateVestingAccount = exports.createVestingAminoConverters = exports.setupTxExtension = exports.setupStakingExtension = exports.stakingTypes = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgUndelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgDelegate = void 0;
var queries_1 = require("69ff90007cb8b512");
Object.defineProperty(exports, "setupAuthExtension", {
    enumerable: true,
    get: function() {
        return queries_1.setupAuthExtension;
    }
});
var aminomessages_1 = require("6eb16efd60ce8c5d");
Object.defineProperty(exports, "createAuthzAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_1.createAuthzAminoConverters;
    }
});
var messages_1 = require("201dbefdea503bc7");
Object.defineProperty(exports, "authzTypes", {
    enumerable: true,
    get: function() {
        return messages_1.authzTypes;
    }
});
var queries_2 = require("29a23958c4a01d42");
Object.defineProperty(exports, "setupAuthzExtension", {
    enumerable: true,
    get: function() {
        return queries_2.setupAuthzExtension;
    }
});
var aminomessages_2 = require("d466008381cb7aac");
Object.defineProperty(exports, "createBankAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_2.createBankAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgMultiSend", {
    enumerable: true,
    get: function() {
        return aminomessages_2.isAminoMsgMultiSend;
    }
});
Object.defineProperty(exports, "isAminoMsgSend", {
    enumerable: true,
    get: function() {
        return aminomessages_2.isAminoMsgSend;
    }
});
var messages_2 = require("4c97fea5560fe847");
Object.defineProperty(exports, "bankTypes", {
    enumerable: true,
    get: function() {
        return messages_2.bankTypes;
    }
});
Object.defineProperty(exports, "isMsgSendEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_2.isMsgSendEncodeObject;
    }
});
var queries_3 = require("fee63f757372f824");
Object.defineProperty(exports, "setupBankExtension", {
    enumerable: true,
    get: function() {
        return queries_3.setupBankExtension;
    }
});
var aminomessages_3 = require("1ff0b4a11287a60b");
Object.defineProperty(exports, "createCrysisAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_3.createCrysisAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgVerifyInvariant", {
    enumerable: true,
    get: function() {
        return aminomessages_3.isAminoMsgVerifyInvariant;
    }
});
var aminomessages_4 = require("6ddcb935a38daeec");
Object.defineProperty(exports, "createDistributionAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_4.createDistributionAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgFundCommunityPool", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgFundCommunityPool;
    }
});
Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgSetWithdrawAddress;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    }
});
var messages_3 = require("8e6dfceab73a88ad");
Object.defineProperty(exports, "distributionTypes", {
    enumerable: true,
    get: function() {
        return messages_3.distributionTypes;
    }
});
Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    }
});
var queries_4 = require("587ce4ff844f10b1");
Object.defineProperty(exports, "setupDistributionExtension", {
    enumerable: true,
    get: function() {
        return queries_4.setupDistributionExtension;
    }
});
var aminomessages_5 = require("6a1ea6f58459dfce");
Object.defineProperty(exports, "createEvidenceAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_5.createEvidenceAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitEvidence", {
    enumerable: true,
    get: function() {
        return aminomessages_5.isAminoMsgSubmitEvidence;
    }
});
var aminomessages_6 = require("c3722f9b48a8a44c");
Object.defineProperty(exports, "createFeegrantAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_6.createFeegrantAminoConverters;
    }
});
var messages_4 = require("2e7dfdc14b1119ca");
Object.defineProperty(exports, "feegrantTypes", {
    enumerable: true,
    get: function() {
        return messages_4.feegrantTypes;
    }
});
var queries_5 = require("c9037fb4bc1c884b");
Object.defineProperty(exports, "setupFeegrantExtension", {
    enumerable: true,
    get: function() {
        return queries_5.setupFeegrantExtension;
    }
});
var aminomessages_7 = require("d63134dbee2f8a3c");
Object.defineProperty(exports, "createGovAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_7.createGovAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgDeposit", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgDeposit;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitProposal", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgSubmitProposal;
    }
});
Object.defineProperty(exports, "isAminoMsgVote", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgVote;
    }
});
Object.defineProperty(exports, "isAminoMsgVoteWeighted", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgVoteWeighted;
    }
});
var messages_5 = require("f18add9adf396dbb");
Object.defineProperty(exports, "govTypes", {
    enumerable: true,
    get: function() {
        return messages_5.govTypes;
    }
});
Object.defineProperty(exports, "isMsgDepositEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgDepositEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgSubmitProposalEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgVoteEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgVoteWeightedEncodeObject;
    }
});
var queries_6 = require("22c9721c9e2accde");
Object.defineProperty(exports, "setupGovExtension", {
    enumerable: true,
    get: function() {
        return queries_6.setupGovExtension;
    }
});
var aminomessages_8 = require("f1bb39f02f708050");
Object.defineProperty(exports, "createGroupAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_8.createGroupAminoConverters;
    }
});
var messages_6 = require("440db074f405acae");
Object.defineProperty(exports, "groupTypes", {
    enumerable: true,
    get: function() {
        return messages_6.groupTypes;
    }
});
var aminomessages_9 = require("4364fb612ca209ea");
Object.defineProperty(exports, "createIbcAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_9.createIbcAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgTransfer", {
    enumerable: true,
    get: function() {
        return aminomessages_9.isAminoMsgTransfer;
    }
});
var messages_7 = require("28652bbdcbdb6ac1");
Object.defineProperty(exports, "ibcTypes", {
    enumerable: true,
    get: function() {
        return messages_7.ibcTypes;
    }
});
Object.defineProperty(exports, "isMsgTransferEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_7.isMsgTransferEncodeObject;
    }
});
var queries_7 = require("fe6b70b8a2434db0");
Object.defineProperty(exports, "setupIbcExtension", {
    enumerable: true,
    get: function() {
        return queries_7.setupIbcExtension;
    }
});
var queries_8 = require("2f5094a9e9b2ee30");
Object.defineProperty(exports, "setupMintExtension", {
    enumerable: true,
    get: function() {
        return queries_8.setupMintExtension;
    }
});
var aminomessages_10 = require("d61169fe98c31e2e");
Object.defineProperty(exports, "createSlashingAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_10.createSlashingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgUnjail", {
    enumerable: true,
    get: function() {
        return aminomessages_10.isAminoMsgUnjail;
    }
});
var queries_9 = require("be53661796943b57");
Object.defineProperty(exports, "setupSlashingExtension", {
    enumerable: true,
    get: function() {
        return queries_9.setupSlashingExtension;
    }
});
var aminomessages_11 = require("8c7eabcb1ca28151");
Object.defineProperty(exports, "createStakingAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_11.createStakingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgBeginRedelegate", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgBeginRedelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateValidator", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgCreateValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgDelegate", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgDelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgEditValidator", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgEditValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgUndelegate", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgUndelegate;
    }
});
var messages_8 = require("d3b36a38e51d889");
Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgBeginRedelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgCreateValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgDelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgDelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgEditValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgUndelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgUndelegateEncodeObject;
    }
});
Object.defineProperty(exports, "stakingTypes", {
    enumerable: true,
    get: function() {
        return messages_8.stakingTypes;
    }
});
var queries_10 = require("e19da93bb433a6b5");
Object.defineProperty(exports, "setupStakingExtension", {
    enumerable: true,
    get: function() {
        return queries_10.setupStakingExtension;
    }
});
var queries_11 = require("adfff358d3a73ef8");
Object.defineProperty(exports, "setupTxExtension", {
    enumerable: true,
    get: function() {
        return queries_11.setupTxExtension;
    }
});
var aminomessages_12 = require("5d682a3009e0b1e7");
Object.defineProperty(exports, "createVestingAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_12.createVestingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", {
    enumerable: true,
    get: function() {
        return aminomessages_12.isAminoMsgCreateVestingAccount;
    }
});
var messages_9 = require("5ec44310e9e0b2d6");
Object.defineProperty(exports, "vestingTypes", {
    enumerable: true,
    get: function() {
        return messages_9.vestingTypes;
    }
});

},{"69ff90007cb8b512":"6DpcE","6eb16efd60ce8c5d":"le055","201dbefdea503bc7":"jXwVM","29a23958c4a01d42":"cZJIU","d466008381cb7aac":"napGc","4c97fea5560fe847":"71lKg","fee63f757372f824":"4cGAo","1ff0b4a11287a60b":"5Y7ue","6ddcb935a38daeec":"9Ea2r","8e6dfceab73a88ad":"ltwu8","587ce4ff844f10b1":"b8MmK","6a1ea6f58459dfce":"2uQ4R","c3722f9b48a8a44c":"fPmDg","2e7dfdc14b1119ca":"5l019","c9037fb4bc1c884b":"cJRXC","d63134dbee2f8a3c":"2vEMh","f18add9adf396dbb":"cvYef","22c9721c9e2accde":"aKHGD","f1bb39f02f708050":"l037H","440db074f405acae":"ckWmw","4364fb612ca209ea":"goDLW","28652bbdcbdb6ac1":"5kmcn","fe6b70b8a2434db0":"6RmWV","2f5094a9e9b2ee30":"a3Cbf","d61169fe98c31e2e":"9djfx","be53661796943b57":"6sP0K","8c7eabcb1ca28151":"56AnK","d3b36a38e51d889":"ilSKu","e19da93bb433a6b5":"bGgqD","adfff358d3a73ef8":"ie6s1","5d682a3009e0b1e7":"68SrM","5ec44310e9e0b2d6":"gnu9X"}],"6DpcE":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupAuthExtension = setupAuthExtension;
const query_1 = require("4b78ee817bc4f5d1");
const queryclient_1 = require("dddb49851ece4f2d");
function setupAuthExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        auth: {
            account: async (address)=>{
                const { account } = await queryService.Account({
                    address: address
                });
                return account ?? null;
            }
        }
    };
}

},{"4b78ee817bc4f5d1":"bYQpN","dddb49851ece4f2d":"cM4fi"}],"bYQpN":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryAccountInfoResponse = exports.QueryAccountInfoRequest = exports.QueryAccountAddressByIDResponse = exports.QueryAccountAddressByIDRequest = exports.AddressStringToBytesResponse = exports.AddressStringToBytesRequest = exports.AddressBytesToStringResponse = exports.AddressBytesToStringRequest = exports.Bech32PrefixResponse = exports.Bech32PrefixRequest = exports.QueryModuleAccountByNameResponse = exports.QueryModuleAccountByNameRequest = exports.QueryModuleAccountsResponse = exports.QueryModuleAccountsRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAccountResponse = exports.QueryAccountRequest = exports.QueryAccountsResponse = exports.QueryAccountsRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("38ae1bd8c7926a20");
const any_1 = require("43378b0dd8c20428");
const auth_1 = require("a15acfbbf08af2d3");
const binary_1 = require("fc3d81c39a61db3e");
const helpers_1 = require("36ce3981bd7c25fc");
exports.protobufPackage = "cosmos.auth.v1beta1";
function createBaseQueryAccountsRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryAccountsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountsRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountsRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryAccountsResponse() {
    return {
        accounts: [],
        pagination: undefined
    };
}
exports.QueryAccountsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts)any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountsResponse();
        if (Array.isArray(object?.accounts)) obj.accounts = object.accounts.map((e)=>any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.accounts) obj.accounts = message.accounts.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.accounts = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountsResponse();
        message.accounts = object.accounts?.map((e)=>any_1.Any.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryAccountRequest() {
    return {
        address: ""
    };
}
exports.QueryAccountRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountRequest();
        message.address = object.address ?? "";
        return message;
    }
};
function createBaseQueryAccountResponse() {
    return {
        account: undefined
    };
}
exports.QueryAccountResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== undefined) any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.account = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountResponse();
        if ((0, helpers_1.isSet)(object.account)) obj.account = any_1.Any.fromJSON(object.account);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.account !== undefined && (obj.account = message.account ? any_1.Any.toJSON(message.account) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountResponse();
        if (object.account !== undefined && object.account !== null) message.account = any_1.Any.fromPartial(object.account);
        return message;
    }
};
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: auth_1.Params.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = auth_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = auth_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = auth_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQueryModuleAccountsRequest() {
    return {};
}
exports.QueryModuleAccountsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryModuleAccountsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryModuleAccountsRequest();
        return message;
    }
};
function createBaseQueryModuleAccountsResponse() {
    return {
        accounts: []
    };
}
exports.QueryModuleAccountsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts)any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryModuleAccountsResponse();
        if (Array.isArray(object?.accounts)) obj.accounts = object.accounts.map((e)=>any_1.Any.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.accounts) obj.accounts = message.accounts.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.accounts = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryModuleAccountsResponse();
        message.accounts = object.accounts?.map((e)=>any_1.Any.fromPartial(e)) || [];
        return message;
    }
};
function createBaseQueryModuleAccountByNameRequest() {
    return {
        name: ""
    };
}
exports.QueryModuleAccountByNameRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") writer.uint32(10).string(message.name);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryModuleAccountByNameRequest();
        if ((0, helpers_1.isSet)(object.name)) obj.name = String(object.name);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryModuleAccountByNameRequest();
        message.name = object.name ?? "";
        return message;
    }
};
function createBaseQueryModuleAccountByNameResponse() {
    return {
        account: undefined
    };
}
exports.QueryModuleAccountByNameResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== undefined) any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.account = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryModuleAccountByNameResponse();
        if ((0, helpers_1.isSet)(object.account)) obj.account = any_1.Any.fromJSON(object.account);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.account !== undefined && (obj.account = message.account ? any_1.Any.toJSON(message.account) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryModuleAccountByNameResponse();
        if (object.account !== undefined && object.account !== null) message.account = any_1.Any.fromPartial(object.account);
        return message;
    }
};
function createBaseBech32PrefixRequest() {
    return {};
}
exports.Bech32PrefixRequest = {
    typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseBech32PrefixRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseBech32PrefixRequest();
        return message;
    }
};
function createBaseBech32PrefixResponse() {
    return {
        bech32Prefix: ""
    };
}
exports.Bech32PrefixResponse = {
    typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.bech32Prefix !== "") writer.uint32(10).string(message.bech32Prefix);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bech32Prefix = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBech32PrefixResponse();
        if ((0, helpers_1.isSet)(object.bech32Prefix)) obj.bech32Prefix = String(object.bech32Prefix);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.bech32Prefix !== undefined && (obj.bech32Prefix = message.bech32Prefix);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBech32PrefixResponse();
        message.bech32Prefix = object.bech32Prefix ?? "";
        return message;
    }
};
function createBaseAddressBytesToStringRequest() {
    return {
        addressBytes: new Uint8Array()
    };
}
exports.AddressBytesToStringRequest = {
    typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) writer.uint32(10).bytes(message.addressBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addressBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAddressBytesToStringRequest();
        if ((0, helpers_1.isSet)(object.addressBytes)) obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.addressBytes !== undefined && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== undefined ? message.addressBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddressBytesToStringRequest();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
    }
};
function createBaseAddressBytesToStringResponse() {
    return {
        addressString: ""
    };
}
exports.AddressBytesToStringResponse = {
    typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") writer.uint32(10).string(message.addressString);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addressString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAddressBytesToStringResponse();
        if ((0, helpers_1.isSet)(object.addressString)) obj.addressString = String(object.addressString);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.addressString !== undefined && (obj.addressString = message.addressString);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddressBytesToStringResponse();
        message.addressString = object.addressString ?? "";
        return message;
    }
};
function createBaseAddressStringToBytesRequest() {
    return {
        addressString: ""
    };
}
exports.AddressStringToBytesRequest = {
    typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") writer.uint32(10).string(message.addressString);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addressString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAddressStringToBytesRequest();
        if ((0, helpers_1.isSet)(object.addressString)) obj.addressString = String(object.addressString);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.addressString !== undefined && (obj.addressString = message.addressString);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddressStringToBytesRequest();
        message.addressString = object.addressString ?? "";
        return message;
    }
};
function createBaseAddressStringToBytesResponse() {
    return {
        addressBytes: new Uint8Array()
    };
}
exports.AddressStringToBytesResponse = {
    typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) writer.uint32(10).bytes(message.addressBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addressBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAddressStringToBytesResponse();
        if ((0, helpers_1.isSet)(object.addressBytes)) obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.addressBytes !== undefined && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== undefined ? message.addressBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddressStringToBytesResponse();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
    }
};
function createBaseQueryAccountAddressByIDRequest() {
    return {
        id: BigInt(0),
        accountId: BigInt(0)
    };
}
exports.QueryAccountAddressByIDRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) writer.uint32(8).int64(message.id);
        if (message.accountId !== BigInt(0)) writer.uint32(16).uint64(message.accountId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.accountId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountAddressByIDRequest();
        if ((0, helpers_1.isSet)(object.id)) obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.accountId)) obj.accountId = BigInt(object.accountId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || BigInt(0)).toString());
        message.accountId !== undefined && (obj.accountId = (message.accountId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountAddressByIDRequest();
        if (object.id !== undefined && object.id !== null) message.id = BigInt(object.id.toString());
        if (object.accountId !== undefined && object.accountId !== null) message.accountId = BigInt(object.accountId.toString());
        return message;
    }
};
function createBaseQueryAccountAddressByIDResponse() {
    return {
        accountAddress: ""
    };
}
exports.QueryAccountAddressByIDResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.accountAddress !== "") writer.uint32(10).string(message.accountAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accountAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountAddressByIDResponse();
        if ((0, helpers_1.isSet)(object.accountAddress)) obj.accountAddress = String(object.accountAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountAddressByIDResponse();
        message.accountAddress = object.accountAddress ?? "";
        return message;
    }
};
function createBaseQueryAccountInfoRequest() {
    return {
        address: ""
    };
}
exports.QueryAccountInfoRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountInfoRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountInfoRequest();
        message.address = object.address ?? "";
        return message;
    }
};
function createBaseQueryAccountInfoResponse() {
    return {
        info: undefined
    };
}
exports.QueryAccountInfoResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.info !== undefined) auth_1.BaseAccount.encode(message.info, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.info = auth_1.BaseAccount.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAccountInfoResponse();
        if ((0, helpers_1.isSet)(object.info)) obj.info = auth_1.BaseAccount.fromJSON(object.info);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.info !== undefined && (obj.info = message.info ? auth_1.BaseAccount.toJSON(message.info) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAccountInfoResponse();
        if (object.info !== undefined && object.info !== null) message.info = auth_1.BaseAccount.fromPartial(object.info);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.AccountAddressByID = this.AccountAddressByID.bind(this);
        this.Params = this.Params.bind(this);
        this.ModuleAccounts = this.ModuleAccounts.bind(this);
        this.ModuleAccountByName = this.ModuleAccountByName.bind(this);
        this.Bech32Prefix = this.Bech32Prefix.bind(this);
        this.AddressBytesToString = this.AddressBytesToString.bind(this);
        this.AddressStringToBytes = this.AddressStringToBytes.bind(this);
        this.AccountInfo = this.AccountInfo.bind(this);
    }
    Accounts(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
        return promise.then((data)=>exports.QueryAccountsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Account(request) {
        const data = exports.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data);
        return promise.then((data)=>exports.QueryAccountResponse.decode(new binary_1.BinaryReader(data)));
    }
    AccountAddressByID(request) {
        const data = exports.QueryAccountAddressByIDRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", data);
        return promise.then((data)=>exports.QueryAccountAddressByIDResponse.decode(new binary_1.BinaryReader(data)));
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ModuleAccounts(request = {}) {
        const data = exports.QueryModuleAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", data);
        return promise.then((data)=>exports.QueryModuleAccountsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ModuleAccountByName(request) {
        const data = exports.QueryModuleAccountByNameRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", data);
        return promise.then((data)=>exports.QueryModuleAccountByNameResponse.decode(new binary_1.BinaryReader(data)));
    }
    Bech32Prefix(request = {}) {
        const data = exports.Bech32PrefixRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", data);
        return promise.then((data)=>exports.Bech32PrefixResponse.decode(new binary_1.BinaryReader(data)));
    }
    AddressBytesToString(request) {
        const data = exports.AddressBytesToStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", data);
        return promise.then((data)=>exports.AddressBytesToStringResponse.decode(new binary_1.BinaryReader(data)));
    }
    AddressStringToBytes(request) {
        const data = exports.AddressStringToBytesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", data);
        return promise.then((data)=>exports.AddressStringToBytesResponse.decode(new binary_1.BinaryReader(data)));
    }
    AccountInfo(request) {
        const data = exports.QueryAccountInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", data);
        return promise.then((data)=>exports.QueryAccountInfoResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"38ae1bd8c7926a20":"43d5n","43378b0dd8c20428":"56aJC","a15acfbbf08af2d3":"1HQnV","fc3d81c39a61db3e":"bi36x","36ce3981bd7c25fc":"eYjRL"}],"43d5n":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PageResponse = exports.PageRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("aca095bb0feb2523");
const helpers_1 = require("6a3f85472f99bb28");
exports.protobufPackage = "cosmos.base.query.v1beta1";
function createBasePageRequest() {
    return {
        key: new Uint8Array(),
        offset: BigInt(0),
        limit: BigInt(0),
        countTotal: false,
        reverse: false
    };
}
exports.PageRequest = {
    typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        if (message.offset !== BigInt(0)) writer.uint32(16).uint64(message.offset);
        if (message.limit !== BigInt(0)) writer.uint32(24).uint64(message.limit);
        if (message.countTotal === true) writer.uint32(32).bool(message.countTotal);
        if (message.reverse === true) writer.uint32(40).bool(message.reverse);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.offset = reader.uint64();
                    break;
                case 3:
                    message.limit = reader.uint64();
                    break;
                case 4:
                    message.countTotal = reader.bool();
                    break;
                case 5:
                    message.reverse = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePageRequest();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.offset)) obj.offset = BigInt(object.offset.toString());
        if ((0, helpers_1.isSet)(object.limit)) obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.countTotal)) obj.countTotal = Boolean(object.countTotal);
        if ((0, helpers_1.isSet)(object.reverse)) obj.reverse = Boolean(object.reverse);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.offset !== undefined && (obj.offset = (message.offset || BigInt(0)).toString());
        message.limit !== undefined && (obj.limit = (message.limit || BigInt(0)).toString());
        message.countTotal !== undefined && (obj.countTotal = message.countTotal);
        message.reverse !== undefined && (obj.reverse = message.reverse);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePageRequest();
        message.key = object.key ?? new Uint8Array();
        if (object.offset !== undefined && object.offset !== null) message.offset = BigInt(object.offset.toString());
        if (object.limit !== undefined && object.limit !== null) message.limit = BigInt(object.limit.toString());
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
    }
};
function createBasePageResponse() {
    return {
        nextKey: new Uint8Array(),
        total: BigInt(0)
    };
}
exports.PageResponse = {
    typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextKey.length !== 0) writer.uint32(10).bytes(message.nextKey);
        if (message.total !== BigInt(0)) writer.uint32(16).uint64(message.total);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.nextKey = reader.bytes();
                    break;
                case 2:
                    message.total = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePageResponse();
        if ((0, helpers_1.isSet)(object.nextKey)) obj.nextKey = (0, helpers_1.bytesFromBase64)(object.nextKey);
        if ((0, helpers_1.isSet)(object.total)) obj.total = BigInt(object.total.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.nextKey !== undefined && (obj.nextKey = (0, helpers_1.base64FromBytes)(message.nextKey !== undefined ? message.nextKey : new Uint8Array()));
        message.total !== undefined && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBasePageResponse();
        message.nextKey = object.nextKey ?? new Uint8Array();
        if (object.total !== undefined && object.total !== null) message.total = BigInt(object.total.toString());
        return message;
    }
};

},{"aca095bb0feb2523":"bi36x","6a3f85472f99bb28":"eYjRL"}],"cM4fi":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.longify = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.QueryClient = void 0;
var queryclient_1 = require("5e14415ba79a596e");
Object.defineProperty(exports, "QueryClient", {
    enumerable: true,
    get: function() {
        return queryclient_1.QueryClient;
    }
});
var utils_1 = require("377540737a72fc07");
Object.defineProperty(exports, "createPagination", {
    enumerable: true,
    get: function() {
        return utils_1.createPagination;
    }
});
Object.defineProperty(exports, "createProtobufRpcClient", {
    enumerable: true,
    get: function() {
        return utils_1.createProtobufRpcClient;
    }
});
Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", {
    enumerable: true,
    get: function() {
        return utils_1.decodeCosmosSdkDecFromProto;
    }
});
Object.defineProperty(exports, "longify", {
    enumerable: true,
    get: function() {
        return utils_1.longify;
    }
});

},{"5e14415ba79a596e":"jaj0M","377540737a72fc07":"bCimK"}],"jaj0M":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClient = void 0;
const utils_1 = require("bc266ff24ff40f9c");
class QueryClient {
    static withExtensions(cometClient, ...extensionSetups) {
        const client = new QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension)=>setupExtension(client));
        for (const extension of extensions){
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
            for (const [moduleKey, moduleValue] of Object.entries(extension)){
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
                const current = client[moduleKey] || {};
                client[moduleKey] = {
                    ...current,
                    ...moduleValue
                };
            }
        }
        return client;
    }
    cometClient;
    constructor(cometClient){
        this.cometClient = cometClient;
    }
    /**
     * Performs an ABCI query to Tendermint without requesting a proof.
     *
     * If the `desiredHeight` is set, a particular height is requested. Otherwise
     * the latest height is requested. The response contains the actual height of
     * the query.
     */ async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
            path: path,
            data: request,
            prove: false,
            height: desiredHeight
        });
        if (response.code) throw new Error(`Query failed with (${response.code}): ${response.log}`);
        if (!response.height) throw new Error("No query height returned");
        return {
            value: response.value,
            height: response.height
        };
    }
}
exports.QueryClient = QueryClient;

},{"bc266ff24ff40f9c":"3R4mb"}],"bCimK":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toAccAddress = toAccAddress;
exports.createPagination = createPagination;
exports.createProtobufRpcClient = createProtobufRpcClient;
exports.longify = longify;
exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
const encoding_1 = require("d1680ff2c51a95e6");
const math_1 = require("93073346980819ed");
const pagination_1 = require("3f45468afdb55506");
/**
 * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.
 * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.
 * The result is typically 20 bytes long but not restricted to that.
 */ function toAccAddress(address) {
    return (0, encoding_1.fromBech32)(address).data;
}
/**
 * If paginationKey is set, return a `PageRequest` with the given key.
 * If paginationKey is unset, return `undefined`.
 *
 * Use this with a query response's pagination next key to
 * request the next page.
 */ function createPagination(paginationKey) {
    return paginationKey ? pagination_1.PageRequest.fromPartial({
        key: paginationKey
    }) : pagination_1.PageRequest.fromPartial({});
}
function createProtobufRpcClient(base) {
    return {
        request: async (service, method, data)=>{
            const path = `/${service}/${method}`;
            const response = await base.queryAbci(path, data, undefined);
            return response.value;
        }
    };
}
/**
 * Takes a uint64 value as string, number, BigInt or Uint64 and returns a BigInt
 * of it.
 */ function longify(value) {
    const checkedValue = math_1.Uint64.fromString(value.toString());
    return BigInt(checkedValue.toString());
}
/**
 * Takes a string or binary encoded `github.com/cosmos/cosmos-sdk/types.Dec` from the
 * protobuf API and converts it into a `Decimal` with 18 fractional digits.
 *
 * See https://github.com/cosmos/cosmos-sdk/issues/10863 for more context why this is needed.
 */ function decodeCosmosSdkDecFromProto(input) {
    const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
    return math_1.Decimal.fromAtomics(asString, 18);
}

},{"d1680ff2c51a95e6":"enCPS","93073346980819ed":"e8aug","3f45468afdb55506":"43d5n"}],"le055":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAuthzAminoConverters = createAuthzAminoConverters;
function createAuthzAminoConverters() {
    return {
    };
}

},{}],"jXwVM":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.authzTypes = void 0;
const tx_1 = require("10f7b76017385223");
exports.authzTypes = [
    [
        "/cosmos.authz.v1beta1.MsgExec",
        tx_1.MsgExec
    ],
    [
        "/cosmos.authz.v1beta1.MsgGrant",
        tx_1.MsgGrant
    ],
    [
        "/cosmos.authz.v1beta1.MsgRevoke",
        tx_1.MsgRevoke
    ]
];

},{"10f7b76017385223":"j0hAV"}],"j0hAV":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgRevokeResponse = exports.MsgRevoke = exports.MsgExecResponse = exports.MsgExec = exports.MsgGrantResponse = exports.MsgGrant = exports.protobufPackage = void 0;
/* eslint-disable */ const authz_1 = require("71706b11b1d57ff4");
const any_1 = require("1fc46034b5a6df5");
const binary_1 = require("c3d792daeec9b601");
const helpers_1 = require("75438d8aded41899");
exports.protobufPackage = "cosmos.authz.v1beta1";
function createBaseMsgGrant() {
    return {
        granter: "",
        grantee: "",
        grant: authz_1.Grant.fromPartial({})
    };
}
exports.MsgGrant = {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        if (message.grant !== undefined) authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                case 3:
                    message.grant = authz_1.Grant.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgGrant();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.grant)) obj.grant = authz_1.Grant.fromJSON(object.grant);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.grant !== undefined && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.grant !== undefined && object.grant !== null) message.grant = authz_1.Grant.fromPartial(object.grant);
        return message;
    }
};
function createBaseMsgGrantResponse() {
    return {};
}
exports.MsgGrantResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgGrantResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgGrantResponse();
        return message;
    }
};
function createBaseMsgExec() {
    return {
        grantee: "",
        msgs: []
    };
}
exports.MsgExec = {
    typeUrl: "/cosmos.authz.v1beta1.MsgExec",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") writer.uint32(10).string(message.grantee);
        for (const v of message.msgs)any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.grantee = reader.string();
                    break;
                case 2:
                    message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if (Array.isArray(object?.msgs)) obj.msgs = object.msgs.map((e)=>any_1.Any.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.grantee !== undefined && (obj.grantee = message.grantee);
        if (message.msgs) obj.msgs = message.msgs.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.msgs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgExec();
        message.grantee = object.grantee ?? "";
        message.msgs = object.msgs?.map((e)=>any_1.Any.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgExecResponse() {
    return {
        results: []
    };
}
exports.MsgExecResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.results)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.results.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgExecResponse();
        if (Array.isArray(object?.results)) obj.results = object.results.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.results) obj.results = message.results.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.results = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgExecResponse();
        message.results = object.results?.map((e)=>e) || [];
        return message;
    }
};
function createBaseMsgRevoke() {
    return {
        granter: "",
        grantee: "",
        msgTypeUrl: ""
    };
}
exports.MsgRevoke = {
    typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        if (message.msgTypeUrl !== "") writer.uint32(26).string(message.msgTypeUrl);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                case 3:
                    message.msgTypeUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgRevoke();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl)) obj.msgTypeUrl = String(object.msgTypeUrl);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.msgTypeUrl !== undefined && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgRevoke();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        return message;
    }
};
function createBaseMsgRevokeResponse() {
    return {};
}
exports.MsgRevokeResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgRevokeResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgRevokeResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Grant = this.Grant.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Revoke = this.Revoke.bind(this);
    }
    Grant(request) {
        const data = exports.MsgGrant.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", data);
        return promise.then((data)=>exports.MsgGrantResponse.decode(new binary_1.BinaryReader(data)));
    }
    Exec(request) {
        const data = exports.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", data);
        return promise.then((data)=>exports.MsgExecResponse.decode(new binary_1.BinaryReader(data)));
    }
    Revoke(request) {
        const data = exports.MsgRevoke.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", data);
        return promise.then((data)=>exports.MsgRevokeResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"71706b11b1d57ff4":"aF9Qx","1fc46034b5a6df5":"56aJC","c3d792daeec9b601":"bi36x","75438d8aded41899":"eYjRL"}],"aF9Qx":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GrantQueueItem = exports.GrantAuthorization = exports.Grant = exports.GenericAuthorization = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("51f161c8948c17e4");
const timestamp_1 = require("bf4f417e6b4a99be");
const binary_1 = require("51cbc2118fe5d676");
const helpers_1 = require("938c1ba660af4b6e");
exports.protobufPackage = "cosmos.authz.v1beta1";
function createBaseGenericAuthorization() {
    return {
        msg: ""
    };
}
exports.GenericAuthorization = {
    typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.msg !== "") writer.uint32(10).string(message.msg);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGenericAuthorization();
        if ((0, helpers_1.isSet)(object.msg)) obj.msg = String(object.msg);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.msg !== undefined && (obj.msg = message.msg);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGenericAuthorization();
        message.msg = object.msg ?? "";
        return message;
    }
};
function createBaseGrant() {
    return {
        authorization: undefined,
        expiration: undefined
    };
}
exports.Grant = {
    typeUrl: "/cosmos.authz.v1beta1.Grant",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authorization !== undefined) any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        if (message.expiration !== undefined) timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authorization = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.authorization)) obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration)) obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authorization !== undefined && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : undefined);
        message.expiration !== undefined && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGrant();
        if (object.authorization !== undefined && object.authorization !== null) message.authorization = any_1.Any.fromPartial(object.authorization);
        if (object.expiration !== undefined && object.expiration !== null) message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        return message;
    }
};
function createBaseGrantAuthorization() {
    return {
        granter: "",
        grantee: "",
        authorization: undefined,
        expiration: undefined
    };
}
exports.GrantAuthorization = {
    typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        if (message.authorization !== undefined) any_1.Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();
        if (message.expiration !== undefined) timestamp_1.Timestamp.encode(message.expiration, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorization();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                case 3:
                    message.authorization = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGrantAuthorization();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.authorization)) obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration)) obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.authorization !== undefined && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : undefined);
        message.expiration !== undefined && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGrantAuthorization();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.authorization !== undefined && object.authorization !== null) message.authorization = any_1.Any.fromPartial(object.authorization);
        if (object.expiration !== undefined && object.expiration !== null) message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        return message;
    }
};
function createBaseGrantQueueItem() {
    return {
        msgTypeUrls: []
    };
}
exports.GrantQueueItem = {
    typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.msgTypeUrls)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrantQueueItem();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.msgTypeUrls.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGrantQueueItem();
        if (Array.isArray(object?.msgTypeUrls)) obj.msgTypeUrls = object.msgTypeUrls.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.msgTypeUrls) obj.msgTypeUrls = message.msgTypeUrls.map((e)=>e);
        else obj.msgTypeUrls = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGrantQueueItem();
        message.msgTypeUrls = object.msgTypeUrls?.map((e)=>e) || [];
        return message;
    }
};

},{"51f161c8948c17e4":"56aJC","bf4f417e6b4a99be":"6J6bq","51cbc2118fe5d676":"bi36x","938c1ba660af4b6e":"eYjRL"}],"6J6bq":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Timestamp = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("c713d810d9194743");
const helpers_1 = require("b54f15f03f384fb1");
exports.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
    return {
        seconds: BigInt(0),
        nanos: 0
    };
}
exports.Timestamp = {
    typeUrl: "/google.protobuf.Timestamp",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) writer.uint32(8).int64(message.seconds);
        if (message.nanos !== 0) writer.uint32(16).int32(message.nanos);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTimestamp();
        if ((0, helpers_1.isSet)(object.seconds)) obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos)) obj.nanos = Number(object.nanos);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.seconds !== undefined && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTimestamp();
        if (object.seconds !== undefined && object.seconds !== null) message.seconds = BigInt(object.seconds.toString());
        message.nanos = object.nanos ?? 0;
        return message;
    }
};

},{"c713d810d9194743":"bi36x","b54f15f03f384fb1":"eYjRL"}],"cZJIU":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupAuthzExtension = setupAuthzExtension;
const query_1 = require("eff7d23d31d59cce");
const queryclient_1 = require("843f09db1f2402ec");
function setupAuthzExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        authz: {
            grants: async (granter, grantee, msgTypeUrl, paginationKey)=>{
                return await queryService.Grants({
                    granter: granter,
                    grantee: grantee,
                    msgTypeUrl: msgTypeUrl,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
            },
            granteeGrants: async (grantee, paginationKey)=>{
                return await queryService.GranteeGrants({
                    grantee: grantee,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
            },
            granterGrants: async (granter, paginationKey)=>{
                return await queryService.GranterGrants({
                    granter: granter,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
            }
        }
    };
}

},{"eff7d23d31d59cce":"FNZ8o","843f09db1f2402ec":"cM4fi"}],"FNZ8o":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryGranteeGrantsResponse = exports.QueryGranteeGrantsRequest = exports.QueryGranterGrantsResponse = exports.QueryGranterGrantsRequest = exports.QueryGrantsResponse = exports.QueryGrantsRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("c40f8758d52ea549");
const authz_1 = require("c5aca646f664c49");
const binary_1 = require("e13326caefd997a4");
const helpers_1 = require("c381f89ac6d57b79");
exports.protobufPackage = "cosmos.authz.v1beta1";
function createBaseQueryGrantsRequest() {
    return {
        granter: "",
        grantee: "",
        msgTypeUrl: "",
        pagination: undefined
    };
}
exports.QueryGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        if (message.msgTypeUrl !== "") writer.uint32(26).string(message.msgTypeUrl);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                case 3:
                    message.msgTypeUrl = reader.string();
                    break;
                case 4:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl)) obj.msgTypeUrl = String(object.msgTypeUrl);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.msgTypeUrl !== undefined && (obj.msgTypeUrl = message.msgTypeUrl);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryGrantsRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryGrantsResponse() {
    return {
        grants: [],
        pagination: undefined
    };
}
exports.QueryGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants)authz_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.grants.push(authz_1.Grant.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryGrantsResponse();
        if (Array.isArray(object?.grants)) obj.grants = object.grants.map((e)=>authz_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.grants) obj.grants = message.grants.map((e)=>e ? authz_1.Grant.toJSON(e) : undefined);
        else obj.grants = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryGrantsResponse();
        message.grants = object.grants?.map((e)=>authz_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryGranterGrantsRequest() {
    return {
        granter: "",
        pagination: undefined
    };
}
exports.QueryGranterGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryGranterGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryGranterGrantsRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryGranterGrantsResponse() {
    return {
        grants: [],
        pagination: undefined
    };
}
exports.QueryGranterGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants)authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryGranterGrantsResponse();
        if (Array.isArray(object?.grants)) obj.grants = object.grants.map((e)=>authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.grants) obj.grants = message.grants.map((e)=>e ? authz_1.GrantAuthorization.toJSON(e) : undefined);
        else obj.grants = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryGranterGrantsResponse();
        message.grants = object.grants?.map((e)=>authz_1.GrantAuthorization.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryGranteeGrantsRequest() {
    return {
        grantee: "",
        pagination: undefined
    };
}
exports.QueryGranteeGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") writer.uint32(10).string(message.grantee);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.grantee = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryGranteeGrantsRequest();
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryGranteeGrantsRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryGranteeGrantsResponse() {
    return {
        grants: [],
        pagination: undefined
    };
}
exports.QueryGranteeGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants)authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryGranteeGrantsResponse();
        if (Array.isArray(object?.grants)) obj.grants = object.grants.map((e)=>authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.grants) obj.grants = message.grants.map((e)=>e ? authz_1.GrantAuthorization.toJSON(e) : undefined);
        else obj.grants = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryGranteeGrantsResponse();
        message.grants = object.grants?.map((e)=>authz_1.GrantAuthorization.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Grants = this.Grants.bind(this);
        this.GranterGrants = this.GranterGrants.bind(this);
        this.GranteeGrants = this.GranteeGrants.bind(this);
    }
    Grants(request) {
        const data = exports.QueryGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", data);
        return promise.then((data)=>exports.QueryGrantsResponse.decode(new binary_1.BinaryReader(data)));
    }
    GranterGrants(request) {
        const data = exports.QueryGranterGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", data);
        return promise.then((data)=>exports.QueryGranterGrantsResponse.decode(new binary_1.BinaryReader(data)));
    }
    GranteeGrants(request) {
        const data = exports.QueryGranteeGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", data);
        return promise.then((data)=>exports.QueryGranteeGrantsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"c40f8758d52ea549":"43d5n","c5aca646f664c49":"aF9Qx","e13326caefd997a4":"bi36x","c381f89ac6d57b79":"eYjRL"}],"napGc":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgSend = isAminoMsgSend;
exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
exports.createBankAminoConverters = createBankAminoConverters;
function isAminoMsgSend(msg) {
    return msg.type === "cosmos-sdk/MsgSend";
}
function isAminoMsgMultiSend(msg) {
    return msg.type === "cosmos-sdk/MsgMultiSend";
}
function createBankAminoConverters() {
    return {
        "/cosmos.bank.v1beta1.MsgSend": {
            aminoType: "cosmos-sdk/MsgSend",
            toAmino: ({ fromAddress, toAddress, amount })=>({
                    from_address: fromAddress,
                    to_address: toAddress,
                    amount: [
                        ...amount
                    ]
                }),
            fromAmino: ({ from_address, to_address, amount })=>({
                    fromAddress: from_address,
                    toAddress: to_address,
                    amount: [
                        ...amount
                    ]
                })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
            aminoType: "cosmos-sdk/MsgMultiSend",
            toAmino: ({ inputs, outputs })=>({
                    inputs: inputs.map((input)=>({
                            address: input.address,
                            coins: [
                                ...input.coins
                            ]
                        })),
                    outputs: outputs.map((output)=>({
                            address: output.address,
                            coins: [
                                ...output.coins
                            ]
                        }))
                }),
            fromAmino: ({ inputs, outputs })=>({
                    inputs: inputs.map((input)=>({
                            address: input.address,
                            coins: [
                                ...input.coins
                            ]
                        })),
                    outputs: outputs.map((output)=>({
                            address: output.address,
                            coins: [
                                ...output.coins
                            ]
                        }))
                })
        }
    };
}

},{}],"71lKg":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bankTypes = void 0;
exports.isMsgSendEncodeObject = isMsgSendEncodeObject;
const tx_1 = require("9ddd51454f6e676");
exports.bankTypes = [
    [
        "/cosmos.bank.v1beta1.MsgMultiSend",
        tx_1.MsgMultiSend
    ],
    [
        "/cosmos.bank.v1beta1.MsgSend",
        tx_1.MsgSend
    ]
];
function isMsgSendEncodeObject(encodeObject) {
    return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
}

},{"9ddd51454f6e676":"59s2S"}],"4cGAo":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupBankExtension = setupBankExtension;
const utils_1 = require("ef303d7f2887bcef");
const query_1 = require("3b63a8c62ebef52");
const queryclient_1 = require("d0bda5033861aa56");
function setupBankExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        bank: {
            balance: async (address, denom)=>{
                const { balance } = await queryService.Balance({
                    address: address,
                    denom: denom
                });
                (0, utils_1.assert)(balance);
                return balance;
            },
            allBalances: async (address)=>{
                const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({
                    address: address
                }));
                return balances;
            },
            totalSupply: async (paginationKey)=>{
                const response = await queryService.TotalSupply({
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            supplyOf: async (denom)=>{
                const { amount } = await queryService.SupplyOf({
                    denom: denom
                });
                (0, utils_1.assert)(amount);
                return amount;
            },
            denomMetadata: async (denom)=>{
                const { metadata } = await queryService.DenomMetadata({
                    denom
                });
                (0, utils_1.assert)(metadata);
                return metadata;
            },
            denomsMetadata: async ()=>{
                const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
                    pagination: undefined
                }));
                return metadatas;
            }
        }
    };
}

},{"ef303d7f2887bcef":"3R4mb","3b63a8c62ebef52":"8Vw0g","d0bda5033861aa56":"cM4fi"}],"8Vw0g":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QuerySendEnabledResponse = exports.QuerySendEnabledRequest = exports.QueryDenomOwnersByQueryResponse = exports.QueryDenomOwnersByQueryRequest = exports.QueryDenomOwnersResponse = exports.DenomOwner = exports.QueryDenomOwnersRequest = exports.QueryDenomMetadataByQueryStringResponse = exports.QueryDenomMetadataByQueryStringRequest = exports.QueryDenomMetadataResponse = exports.QueryDenomMetadataRequest = exports.QueryDenomsMetadataResponse = exports.QueryDenomsMetadataRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QuerySupplyOfResponse = exports.QuerySupplyOfRequest = exports.QueryTotalSupplyResponse = exports.QueryTotalSupplyRequest = exports.QuerySpendableBalanceByDenomResponse = exports.QuerySpendableBalanceByDenomRequest = exports.QuerySpendableBalancesResponse = exports.QuerySpendableBalancesRequest = exports.QueryAllBalancesResponse = exports.QueryAllBalancesRequest = exports.QueryBalanceResponse = exports.QueryBalanceRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("89f2a798a079243f");
const coin_1 = require("2f1d25c32ed5e35d");
const bank_1 = require("d29a211e1a01bc5b");
const binary_1 = require("431e4b914615de88");
const helpers_1 = require("d48b577d3ba7aa48");
exports.protobufPackage = "cosmos.bank.v1beta1";
function createBaseQueryBalanceRequest() {
    return {
        address: "",
        denom: ""
    };
}
exports.QueryBalanceRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.denom !== "") writer.uint32(18).string(message.denom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryBalanceRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryBalanceRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
    }
};
function createBaseQueryBalanceResponse() {
    return {
        balance: undefined
    };
}
exports.QueryBalanceResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== undefined) coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryBalanceResponse();
        if ((0, helpers_1.isSet)(object.balance)) obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryBalanceResponse();
        if (object.balance !== undefined && object.balance !== null) message.balance = coin_1.Coin.fromPartial(object.balance);
        return message;
    }
};
function createBaseQueryAllBalancesRequest() {
    return {
        address: "",
        pagination: undefined,
        resolveDenom: false
    };
}
exports.QueryAllBalancesRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.resolveDenom === true) writer.uint32(24).bool(message.resolveDenom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.resolveDenom = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllBalancesRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.resolveDenom)) obj.resolveDenom = Boolean(object.resolveDenom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        message.resolveDenom !== undefined && (obj.resolveDenom = message.resolveDenom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllBalancesRequest();
        message.address = object.address ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        message.resolveDenom = object.resolveDenom ?? false;
        return message;
    }
};
function createBaseQueryAllBalancesResponse() {
    return {
        balances: [],
        pagination: undefined
    };
}
exports.QueryAllBalancesResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.balances)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllBalancesResponse();
        if (Array.isArray(object?.balances)) obj.balances = object.balances.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.balances) obj.balances = message.balances.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.balances = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllBalancesResponse();
        message.balances = object.balances?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySpendableBalancesRequest() {
    return {
        address: "",
        pagination: undefined
    };
}
exports.QuerySpendableBalancesRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySpendableBalancesRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySpendableBalancesRequest();
        message.address = object.address ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySpendableBalancesResponse() {
    return {
        balances: [],
        pagination: undefined
    };
}
exports.QuerySpendableBalancesResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.balances)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySpendableBalancesResponse();
        if (Array.isArray(object?.balances)) obj.balances = object.balances.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.balances) obj.balances = message.balances.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.balances = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySpendableBalancesResponse();
        message.balances = object.balances?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySpendableBalanceByDenomRequest() {
    return {
        address: "",
        denom: ""
    };
}
exports.QuerySpendableBalanceByDenomRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.denom !== "") writer.uint32(18).string(message.denom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySpendableBalanceByDenomRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySpendableBalanceByDenomRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
    }
};
function createBaseQuerySpendableBalanceByDenomResponse() {
    return {
        balance: undefined
    };
}
exports.QuerySpendableBalanceByDenomResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== undefined) coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySpendableBalanceByDenomResponse();
        if ((0, helpers_1.isSet)(object.balance)) obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySpendableBalanceByDenomResponse();
        if (object.balance !== undefined && object.balance !== null) message.balance = coin_1.Coin.fromPartial(object.balance);
        return message;
    }
};
function createBaseQueryTotalSupplyRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryTotalSupplyRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryTotalSupplyRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryTotalSupplyRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryTotalSupplyResponse() {
    return {
        supply: [],
        pagination: undefined
    };
}
exports.QueryTotalSupplyResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.supply)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryTotalSupplyResponse();
        if (Array.isArray(object?.supply)) obj.supply = object.supply.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.supply) obj.supply = message.supply.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.supply = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryTotalSupplyResponse();
        message.supply = object.supply?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySupplyOfRequest() {
    return {
        denom: ""
    };
}
exports.QuerySupplyOfRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySupplyOfRequest();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySupplyOfRequest();
        message.denom = object.denom ?? "";
        return message;
    }
};
function createBaseQuerySupplyOfResponse() {
    return {
        amount: coin_1.Coin.fromPartial({})
    };
}
exports.QuerySupplyOfResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySupplyOfResponse();
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySupplyOfResponse();
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        return message;
    }
};
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: bank_1.Params.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = bank_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = bank_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQueryDenomsMetadataRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryDenomsMetadataRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomsMetadataRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomsMetadataRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDenomsMetadataResponse() {
    return {
        metadatas: [],
        pagination: undefined
    };
}
exports.QueryDenomsMetadataResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.metadatas)bank_1.Metadata.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomsMetadataResponse();
        if (Array.isArray(object?.metadatas)) obj.metadatas = object.metadatas.map((e)=>bank_1.Metadata.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.metadatas) obj.metadatas = message.metadatas.map((e)=>e ? bank_1.Metadata.toJSON(e) : undefined);
        else obj.metadatas = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomsMetadataResponse();
        message.metadatas = object.metadatas?.map((e)=>bank_1.Metadata.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDenomMetadataRequest() {
    return {
        denom: ""
    };
}
exports.QueryDenomMetadataRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomMetadataRequest();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomMetadataRequest();
        message.denom = object.denom ?? "";
        return message;
    }
};
function createBaseQueryDenomMetadataResponse() {
    return {
        metadata: bank_1.Metadata.fromPartial({})
    };
}
exports.QueryDenomMetadataResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== undefined) bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomMetadataResponse();
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.metadata !== undefined && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomMetadataResponse();
        if (object.metadata !== undefined && object.metadata !== null) message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        return message;
    }
};
function createBaseQueryDenomMetadataByQueryStringRequest() {
    return {
        denom: ""
    };
}
exports.QueryDenomMetadataByQueryStringRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomMetadataByQueryStringRequest();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomMetadataByQueryStringRequest();
        message.denom = object.denom ?? "";
        return message;
    }
};
function createBaseQueryDenomMetadataByQueryStringResponse() {
    return {
        metadata: bank_1.Metadata.fromPartial({})
    };
}
exports.QueryDenomMetadataByQueryStringResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== undefined) bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomMetadataByQueryStringResponse();
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.metadata !== undefined && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomMetadataByQueryStringResponse();
        if (object.metadata !== undefined && object.metadata !== null) message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        return message;
    }
};
function createBaseQueryDenomOwnersRequest() {
    return {
        denom: "",
        pagination: undefined
    };
}
exports.QueryDenomOwnersRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomOwnersRequest();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomOwnersRequest();
        message.denom = object.denom ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseDenomOwner() {
    return {
        address: "",
        balance: coin_1.Coin.fromPartial({})
    };
}
exports.DenomOwner = {
    typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.balance !== undefined) coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDenomOwner();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDenomOwner();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.balance)) obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDenomOwner();
        message.address = object.address ?? "";
        if (object.balance !== undefined && object.balance !== null) message.balance = coin_1.Coin.fromPartial(object.balance);
        return message;
    }
};
function createBaseQueryDenomOwnersResponse() {
    return {
        denomOwners: [],
        pagination: undefined
    };
}
exports.QueryDenomOwnersResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomOwners)exports.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomOwnersResponse();
        if (Array.isArray(object?.denomOwners)) obj.denomOwners = object.denomOwners.map((e)=>exports.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.denomOwners) obj.denomOwners = message.denomOwners.map((e)=>e ? exports.DenomOwner.toJSON(e) : undefined);
        else obj.denomOwners = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomOwnersResponse();
        message.denomOwners = object.denomOwners?.map((e)=>exports.DenomOwner.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDenomOwnersByQueryRequest() {
    return {
        denom: "",
        pagination: undefined
    };
}
exports.QueryDenomOwnersByQueryRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomOwnersByQueryRequest();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomOwnersByQueryRequest();
        message.denom = object.denom ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDenomOwnersByQueryResponse() {
    return {
        denomOwners: [],
        pagination: undefined
    };
}
exports.QueryDenomOwnersByQueryResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomOwners)exports.DenomOwner.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomOwnersByQueryResponse();
        if (Array.isArray(object?.denomOwners)) obj.denomOwners = object.denomOwners.map((e)=>exports.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.denomOwners) obj.denomOwners = message.denomOwners.map((e)=>e ? exports.DenomOwner.toJSON(e) : undefined);
        else obj.denomOwners = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomOwnersByQueryResponse();
        message.denomOwners = object.denomOwners?.map((e)=>exports.DenomOwner.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySendEnabledRequest() {
    return {
        denoms: [],
        pagination: undefined
    };
}
exports.QuerySendEnabledRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denoms)writer.uint32(10).string(v);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denoms.push(reader.string());
                    break;
                case 99:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySendEnabledRequest();
        if (Array.isArray(object?.denoms)) obj.denoms = object.denoms.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.denoms) obj.denoms = message.denoms.map((e)=>e);
        else obj.denoms = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySendEnabledRequest();
        message.denoms = object.denoms?.map((e)=>e) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySendEnabledResponse() {
    return {
        sendEnabled: [],
        pagination: undefined
    };
}
exports.QuerySendEnabledResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.sendEnabled)bank_1.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
                    break;
                case 99:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySendEnabledResponse();
        if (Array.isArray(object?.sendEnabled)) obj.sendEnabled = object.sendEnabled.map((e)=>bank_1.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.sendEnabled) obj.sendEnabled = message.sendEnabled.map((e)=>e ? bank_1.SendEnabled.toJSON(e) : undefined);
        else obj.sendEnabled = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySendEnabledResponse();
        message.sendEnabled = object.sendEnabled?.map((e)=>bank_1.SendEnabled.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.SpendableBalances = this.SpendableBalances.bind(this);
        this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomMetadataByQueryString = this.DenomMetadataByQueryString.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
        this.DenomOwners = this.DenomOwners.bind(this);
        this.DenomOwnersByQuery = this.DenomOwnersByQuery.bind(this);
        this.SendEnabled = this.SendEnabled.bind(this);
    }
    Balance(request) {
        const data = exports.QueryBalanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data);
        return promise.then((data)=>exports.QueryBalanceResponse.decode(new binary_1.BinaryReader(data)));
    }
    AllBalances(request) {
        const data = exports.QueryAllBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data);
        return promise.then((data)=>exports.QueryAllBalancesResponse.decode(new binary_1.BinaryReader(data)));
    }
    SpendableBalances(request) {
        const data = exports.QuerySpendableBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", data);
        return promise.then((data)=>exports.QuerySpendableBalancesResponse.decode(new binary_1.BinaryReader(data)));
    }
    SpendableBalanceByDenom(request) {
        const data = exports.QuerySpendableBalanceByDenomRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", data);
        return promise.then((data)=>exports.QuerySpendableBalanceByDenomResponse.decode(new binary_1.BinaryReader(data)));
    }
    TotalSupply(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryTotalSupplyRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data);
        return promise.then((data)=>exports.QueryTotalSupplyResponse.decode(new binary_1.BinaryReader(data)));
    }
    SupplyOf(request) {
        const data = exports.QuerySupplyOfRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data);
        return promise.then((data)=>exports.QuerySupplyOfResponse.decode(new binary_1.BinaryReader(data)));
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomMetadata(request) {
        const data = exports.QueryDenomMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data);
        return promise.then((data)=>exports.QueryDenomMetadataResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomMetadataByQueryString(request) {
        const data = exports.QueryDenomMetadataByQueryStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadataByQueryString", data);
        return promise.then((data)=>exports.QueryDenomMetadataByQueryStringResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomsMetadata(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryDenomsMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data);
        return promise.then((data)=>exports.QueryDenomsMetadataResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomOwners(request) {
        const data = exports.QueryDenomOwnersRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", data);
        return promise.then((data)=>exports.QueryDenomOwnersResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomOwnersByQuery(request) {
        const data = exports.QueryDenomOwnersByQueryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwnersByQuery", data);
        return promise.then((data)=>exports.QueryDenomOwnersByQueryResponse.decode(new binary_1.BinaryReader(data)));
    }
    SendEnabled(request) {
        const data = exports.QuerySendEnabledRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", data);
        return promise.then((data)=>exports.QuerySendEnabledResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"89f2a798a079243f":"43d5n","2f1d25c32ed5e35d":"1ymyZ","d29a211e1a01bc5b":"cn9CY","431e4b914615de88":"bi36x","d48b577d3ba7aa48":"eYjRL"}],"5Y7ue":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
exports.createCrysisAminoConverters = createCrysisAminoConverters;
function isAminoMsgVerifyInvariant(msg) {
    return msg.type === "cosmos-sdk/MsgVerifyInvariant";
}
function createCrysisAminoConverters() {
    throw new Error("Not implemented");
}

},{}],"9Ea2r":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
exports.createDistributionAminoConverters = createDistributionAminoConverters;
function isAminoMsgSetWithdrawAddress(msg) {
    // NOTE: Type string and names diverge here!
    return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
}
function isAminoMsgWithdrawDelegatorReward(msg) {
    // NOTE: Type string and names diverge here!
    return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
}
function isAminoMsgWithdrawValidatorCommission(msg) {
    return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
}
function isAminoMsgFundCommunityPool(msg) {
    return msg.type === "cosmos-sdk/MsgFundCommunityPool";
}
function createDistributionAminoConverters() {
    return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
            aminoType: "cosmos-sdk/MsgFundCommunityPool",
            toAmino: ({ amount, depositor })=>({
                    amount: [
                        ...amount
                    ],
                    depositor: depositor
                }),
            fromAmino: ({ amount, depositor })=>({
                    amount: [
                        ...amount
                    ],
                    depositor: depositor
                })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
            aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
            toAmino: ({ delegatorAddress, withdrawAddress })=>({
                    delegator_address: delegatorAddress,
                    withdraw_address: withdrawAddress
                }),
            fromAmino: ({ delegator_address, withdraw_address })=>({
                    delegatorAddress: delegator_address,
                    withdrawAddress: withdraw_address
                })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
            aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
            toAmino: ({ delegatorAddress, validatorAddress })=>({
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress
                }),
            fromAmino: ({ delegator_address, validator_address })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address
                })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
            aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
            toAmino: ({ validatorAddress })=>({
                    validator_address: validatorAddress
                }),
            fromAmino: ({ validator_address })=>({
                    validatorAddress: validator_address
                })
        }
    };
}

},{}],"ltwu8":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.distributionTypes = void 0;
exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
const tx_1 = require("e68cdbc95249e104");
exports.distributionTypes = [
    [
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        tx_1.MsgFundCommunityPool
    ],
    [
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        tx_1.MsgSetWithdrawAddress
    ],
    [
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        tx_1.MsgWithdrawDelegatorReward
    ],
    [
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        tx_1.MsgWithdrawValidatorCommission
    ]
];
function isMsgWithdrawDelegatorRewardEncodeObject(object) {
    return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}

},{"e68cdbc95249e104":"1bSSP"}],"1bSSP":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgDepositValidatorRewardsPoolResponse = exports.MsgDepositValidatorRewardsPool = exports.MsgCommunityPoolSpendResponse = exports.MsgCommunityPoolSpend = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("2c7176c27ce5df22");
const distribution_1 = require("90baa27f0d4896de");
const binary_1 = require("f8e83bff2f0cd292");
const helpers_1 = require("92afea03f42c2a69");
exports.protobufPackage = "cosmos.distribution.v1beta1";
function createBaseMsgSetWithdrawAddress() {
    return {
        delegatorAddress: "",
        withdrawAddress: ""
    };
}
exports.MsgSetWithdrawAddress = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.withdrawAddress !== "") writer.uint32(18).string(message.withdrawAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.withdrawAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSetWithdrawAddress();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.withdrawAddress)) obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== undefined && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
    }
};
function createBaseMsgSetWithdrawAddressResponse() {
    return {};
}
exports.MsgSetWithdrawAddressResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgSetWithdrawAddressResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
    }
};
function createBaseMsgWithdrawDelegatorReward() {
    return {
        delegatorAddress: "",
        validatorAddress: ""
    };
}
exports.MsgWithdrawDelegatorReward = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgWithdrawDelegatorReward();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseMsgWithdrawDelegatorRewardResponse() {
    return {
        amount: []
    };
}
exports.MsgWithdrawDelegatorRewardResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgWithdrawDelegatorRewardResponse();
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgWithdrawValidatorCommission() {
    return {
        validatorAddress: ""
    };
}
exports.MsgWithdrawValidatorCommission = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") writer.uint32(10).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgWithdrawValidatorCommission();
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseMsgWithdrawValidatorCommissionResponse() {
    return {
        amount: []
    };
}
exports.MsgWithdrawValidatorCommissionResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgWithdrawValidatorCommissionResponse();
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgFundCommunityPool() {
    return {
        amount: [],
        depositor: ""
    };
}
exports.MsgFundCommunityPool = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.depositor !== "") writer.uint32(18).string(message.depositor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.depositor = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgFundCommunityPool();
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        message.depositor !== undefined && (obj.depositor = message.depositor);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgFundCommunityPool();
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.depositor = object.depositor ?? "";
        return message;
    }
};
function createBaseMsgFundCommunityPoolResponse() {
    return {};
}
exports.MsgFundCommunityPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgFundCommunityPoolResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: distribution_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        if (message.params !== undefined) distribution_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = distribution_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params)) obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== undefined && object.params !== null) message.params = distribution_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
function createBaseMsgCommunityPoolSpend() {
    return {
        authority: "",
        recipient: "",
        amount: []
    };
}
exports.MsgCommunityPoolSpend = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        if (message.recipient !== "") writer.uint32(18).string(message.recipient);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpend();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.recipient = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCommunityPoolSpend();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.recipient)) obj.recipient = String(object.recipient);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.recipient !== undefined && (obj.recipient = message.recipient);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCommunityPoolSpend();
        message.authority = object.authority ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgCommunityPoolSpendResponse() {
    return {};
}
exports.MsgCommunityPoolSpendResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpendResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCommunityPoolSpendResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCommunityPoolSpendResponse();
        return message;
    }
};
function createBaseMsgDepositValidatorRewardsPool() {
    return {
        depositor: "",
        validatorAddress: "",
        amount: []
    };
}
exports.MsgDepositValidatorRewardsPool = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.depositor !== "") writer.uint32(10).string(message.depositor);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPool();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.depositor = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgDepositValidatorRewardsPool();
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.depositor !== undefined && (obj.depositor = message.depositor);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgDepositValidatorRewardsPool();
        message.depositor = object.depositor ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgDepositValidatorRewardsPoolResponse() {
    return {};
}
exports.MsgDepositValidatorRewardsPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPoolResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgDepositValidatorRewardsPoolResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgDepositValidatorRewardsPoolResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
        this.DepositValidatorRewardsPool = this.DepositValidatorRewardsPool.bind(this);
    }
    SetWithdrawAddress(request) {
        const data = exports.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data);
        return promise.then((data)=>exports.MsgSetWithdrawAddressResponse.decode(new binary_1.BinaryReader(data)));
    }
    WithdrawDelegatorReward(request) {
        const data = exports.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data);
        return promise.then((data)=>exports.MsgWithdrawDelegatorRewardResponse.decode(new binary_1.BinaryReader(data)));
    }
    WithdrawValidatorCommission(request) {
        const data = exports.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data);
        return promise.then((data)=>exports.MsgWithdrawValidatorCommissionResponse.decode(new binary_1.BinaryReader(data)));
    }
    FundCommunityPool(request) {
        const data = exports.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data);
        return promise.then((data)=>exports.MsgFundCommunityPoolResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    CommunityPoolSpend(request) {
        const data = exports.MsgCommunityPoolSpend.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", data);
        return promise.then((data)=>exports.MsgCommunityPoolSpendResponse.decode(new binary_1.BinaryReader(data)));
    }
    DepositValidatorRewardsPool(request) {
        const data = exports.MsgDepositValidatorRewardsPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "DepositValidatorRewardsPool", data);
        return promise.then((data)=>exports.MsgDepositValidatorRewardsPoolResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"2c7176c27ce5df22":"1ymyZ","90baa27f0d4896de":"2DwXO","f8e83bff2f0cd292":"bi36x","92afea03f42c2a69":"eYjRL"}],"2DwXO":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CommunityPoolSpendProposalWithDeposit = exports.DelegationDelegatorReward = exports.DelegatorStartingInfo = exports.CommunityPoolSpendProposal = exports.FeePool = exports.ValidatorSlashEvents = exports.ValidatorSlashEvent = exports.ValidatorOutstandingRewards = exports.ValidatorAccumulatedCommission = exports.ValidatorCurrentRewards = exports.ValidatorHistoricalRewards = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("4f7e59cfa6e08093");
const binary_1 = require("cf6db3f9e75b010");
const helpers_1 = require("2abf4ed45559bed6");
exports.protobufPackage = "cosmos.distribution.v1beta1";
function createBaseParams() {
    return {
        communityTax: "",
        baseProposerReward: "",
        bonusProposerReward: "",
        withdrawAddrEnabled: false
    };
}
exports.Params = {
    typeUrl: "/cosmos.distribution.v1beta1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.communityTax !== "") writer.uint32(10).string(message.communityTax);
        if (message.baseProposerReward !== "") writer.uint32(18).string(message.baseProposerReward);
        if (message.bonusProposerReward !== "") writer.uint32(26).string(message.bonusProposerReward);
        if (message.withdrawAddrEnabled === true) writer.uint32(32).bool(message.withdrawAddrEnabled);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.communityTax = reader.string();
                    break;
                case 2:
                    message.baseProposerReward = reader.string();
                    break;
                case 3:
                    message.bonusProposerReward = reader.string();
                    break;
                case 4:
                    message.withdrawAddrEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.communityTax)) obj.communityTax = String(object.communityTax);
        if ((0, helpers_1.isSet)(object.baseProposerReward)) obj.baseProposerReward = String(object.baseProposerReward);
        if ((0, helpers_1.isSet)(object.bonusProposerReward)) obj.bonusProposerReward = String(object.bonusProposerReward);
        if ((0, helpers_1.isSet)(object.withdrawAddrEnabled)) obj.withdrawAddrEnabled = Boolean(object.withdrawAddrEnabled);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.communityTax !== undefined && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== undefined && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== undefined && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== undefined && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.communityTax = object.communityTax ?? "";
        message.baseProposerReward = object.baseProposerReward ?? "";
        message.bonusProposerReward = object.bonusProposerReward ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        return message;
    }
};
function createBaseValidatorHistoricalRewards() {
    return {
        cumulativeRewardRatio: [],
        referenceCount: 0
    };
}
exports.ValidatorHistoricalRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.cumulativeRewardRatio)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.referenceCount !== 0) writer.uint32(16).uint32(message.referenceCount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.referenceCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorHistoricalRewards();
        if (Array.isArray(object?.cumulativeRewardRatio)) obj.cumulativeRewardRatio = object.cumulativeRewardRatio.map((e)=>coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.referenceCount)) obj.referenceCount = Number(object.referenceCount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.cumulativeRewardRatio) obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.cumulativeRewardRatio = [];
        message.referenceCount !== undefined && (obj.referenceCount = Math.round(message.referenceCount));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = object.cumulativeRewardRatio?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
    }
};
function createBaseValidatorCurrentRewards() {
    return {
        rewards: [],
        period: BigInt(0)
    };
}
exports.ValidatorCurrentRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.period !== BigInt(0)) writer.uint32(16).uint64(message.period);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.period = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorCurrentRewards();
        if (Array.isArray(object?.rewards)) obj.rewards = object.rewards.map((e)=>coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.period)) obj.period = BigInt(object.period.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.rewards) obj.rewards = message.rewards.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.rewards = [];
        message.period !== undefined && (obj.period = (message.period || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorCurrentRewards();
        message.rewards = object.rewards?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        if (object.period !== undefined && object.period !== null) message.period = BigInt(object.period.toString());
        return message;
    }
};
function createBaseValidatorAccumulatedCommission() {
    return {
        commission: []
    };
}
exports.ValidatorAccumulatedCommission = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commission)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorAccumulatedCommission();
        if (Array.isArray(object?.commission)) obj.commission = object.commission.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.commission) obj.commission = message.commission.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.commission = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorAccumulatedCommission();
        message.commission = object.commission?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseValidatorOutstandingRewards() {
    return {
        rewards: []
    };
}
exports.ValidatorOutstandingRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorOutstandingRewards();
        if (Array.isArray(object?.rewards)) obj.rewards = object.rewards.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.rewards) obj.rewards = message.rewards.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.rewards = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = object.rewards?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseValidatorSlashEvent() {
    return {
        validatorPeriod: BigInt(0),
        fraction: ""
    };
}
exports.ValidatorSlashEvent = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorPeriod !== BigInt(0)) writer.uint32(8).uint64(message.validatorPeriod);
        if (message.fraction !== "") writer.uint32(18).string(message.fraction);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorPeriod = reader.uint64();
                    break;
                case 2:
                    message.fraction = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorSlashEvent();
        if ((0, helpers_1.isSet)(object.validatorPeriod)) obj.validatorPeriod = BigInt(object.validatorPeriod.toString());
        if ((0, helpers_1.isSet)(object.fraction)) obj.fraction = String(object.fraction);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorPeriod !== undefined && (obj.validatorPeriod = (message.validatorPeriod || BigInt(0)).toString());
        message.fraction !== undefined && (obj.fraction = message.fraction);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorSlashEvent();
        if (object.validatorPeriod !== undefined && object.validatorPeriod !== null) message.validatorPeriod = BigInt(object.validatorPeriod.toString());
        message.fraction = object.fraction ?? "";
        return message;
    }
};
function createBaseValidatorSlashEvents() {
    return {
        validatorSlashEvents: []
    };
}
exports.ValidatorSlashEvents = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validatorSlashEvents)exports.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorSlashEvents.push(exports.ValidatorSlashEvent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorSlashEvents();
        if (Array.isArray(object?.validatorSlashEvents)) obj.validatorSlashEvents = object.validatorSlashEvents.map((e)=>exports.ValidatorSlashEvent.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.validatorSlashEvents) obj.validatorSlashEvents = message.validatorSlashEvents.map((e)=>e ? exports.ValidatorSlashEvent.toJSON(e) : undefined);
        else obj.validatorSlashEvents = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = object.validatorSlashEvents?.map((e)=>exports.ValidatorSlashEvent.fromPartial(e)) || [];
        return message;
    }
};
function createBaseFeePool() {
    return {
        communityPool: []
    };
}
exports.FeePool = {
    typeUrl: "/cosmos.distribution.v1beta1.FeePool",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.communityPool)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseFeePool();
        if (Array.isArray(object?.communityPool)) obj.communityPool = object.communityPool.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.communityPool) obj.communityPool = message.communityPool.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.communityPool = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseFeePool();
        message.communityPool = object.communityPool?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseCommunityPoolSpendProposal() {
    return {
        title: "",
        description: "",
        recipient: "",
        amount: []
    };
}
exports.CommunityPoolSpendProposal = {
    typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        if (message.recipient !== "") writer.uint32(26).string(message.recipient);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.recipient = reader.string();
                    break;
                case 4:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommunityPoolSpendProposal();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient)) obj.recipient = String(object.recipient);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.recipient !== undefined && (obj.recipient = message.recipient);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommunityPoolSpendProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseDelegatorStartingInfo() {
    return {
        previousPeriod: BigInt(0),
        stake: "",
        height: BigInt(0)
    };
}
exports.DelegatorStartingInfo = {
    typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.previousPeriod !== BigInt(0)) writer.uint32(8).uint64(message.previousPeriod);
        if (message.stake !== "") writer.uint32(18).string(message.stake);
        if (message.height !== BigInt(0)) writer.uint32(24).uint64(message.height);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.previousPeriod = reader.uint64();
                    break;
                case 2:
                    message.stake = reader.string();
                    break;
                case 3:
                    message.height = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDelegatorStartingInfo();
        if ((0, helpers_1.isSet)(object.previousPeriod)) obj.previousPeriod = BigInt(object.previousPeriod.toString());
        if ((0, helpers_1.isSet)(object.stake)) obj.stake = String(object.stake);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.previousPeriod !== undefined && (obj.previousPeriod = (message.previousPeriod || BigInt(0)).toString());
        message.stake !== undefined && (obj.stake = message.stake);
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDelegatorStartingInfo();
        if (object.previousPeriod !== undefined && object.previousPeriod !== null) message.previousPeriod = BigInt(object.previousPeriod.toString());
        message.stake = object.stake ?? "";
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        return message;
    }
};
function createBaseDelegationDelegatorReward() {
    return {
        validatorAddress: "",
        reward: []
    };
}
exports.DelegationDelegatorReward = {
    typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") writer.uint32(10).string(message.validatorAddress);
        for (const v of message.reward)coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                case 2:
                    message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDelegationDelegatorReward();
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.reward)) obj.reward = object.reward.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) obj.reward = message.reward.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.reward = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = object.reward?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseCommunityPoolSpendProposalWithDeposit() {
    return {
        title: "",
        description: "",
        recipient: "",
        amount: "",
        deposit: ""
    };
}
exports.CommunityPoolSpendProposalWithDeposit = {
    typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        if (message.recipient !== "") writer.uint32(26).string(message.recipient);
        if (message.amount !== "") writer.uint32(34).string(message.amount);
        if (message.deposit !== "") writer.uint32(42).string(message.deposit);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.recipient = reader.string();
                    break;
                case 4:
                    message.amount = reader.string();
                    break;
                case 5:
                    message.deposit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommunityPoolSpendProposalWithDeposit();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient)) obj.recipient = String(object.recipient);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = String(object.amount);
        if ((0, helpers_1.isSet)(object.deposit)) obj.deposit = String(object.deposit);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.recipient !== undefined && (obj.recipient = message.recipient);
        message.amount !== undefined && (obj.amount = message.amount);
        message.deposit !== undefined && (obj.deposit = message.deposit);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount ?? "";
        message.deposit = object.deposit ?? "";
        return message;
    }
};

},{"4f7e59cfa6e08093":"1ymyZ","cf6db3f9e75b010":"bi36x","2abf4ed45559bed6":"eYjRL"}],"b8MmK":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupDistributionExtension = setupDistributionExtension;
const query_1 = require("f9c33f4a09f8a730");
const queryclient_1 = require("9e63fe88cd990c15");
function setupDistributionExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        distribution: {
            communityPool: async ()=>{
                const response = await queryService.CommunityPool({});
                return response;
            },
            delegationRewards: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.DelegationRewards({
                    delegatorAddress: delegatorAddress,
                    validatorAddress: validatorAddress
                });
                return response;
            },
            delegationTotalRewards: async (delegatorAddress)=>{
                const response = await queryService.DelegationTotalRewards({
                    delegatorAddress: delegatorAddress
                });
                return response;
            },
            delegatorValidators: async (delegatorAddress)=>{
                const response = await queryService.DelegatorValidators({
                    delegatorAddress: delegatorAddress
                });
                return response;
            },
            delegatorWithdrawAddress: async (delegatorAddress)=>{
                const response = await queryService.DelegatorWithdrawAddress({
                    delegatorAddress: delegatorAddress
                });
                return response;
            },
            params: async ()=>{
                const response = await queryService.Params({});
                return response;
            },
            validatorCommission: async (validatorAddress)=>{
                const response = await queryService.ValidatorCommission({
                    validatorAddress: validatorAddress
                });
                return response;
            },
            validatorOutstandingRewards: async (validatorAddress)=>{
                const response = await queryService.ValidatorOutstandingRewards({
                    validatorAddress: validatorAddress
                });
                return response;
            },
            validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey)=>{
                const response = await queryService.ValidatorSlashes({
                    validatorAddress: validatorAddress,
                    startingHeight: BigInt(startingHeight),
                    endingHeight: BigInt(endingHeight),
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            }
        }
    };
}

},{"f9c33f4a09f8a730":"1jwa2","9e63fe88cd990c15":"cM4fi"}],"1jwa2":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryCommunityPoolResponse = exports.QueryCommunityPoolRequest = exports.QueryDelegatorWithdrawAddressResponse = exports.QueryDelegatorWithdrawAddressRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryDelegationTotalRewardsResponse = exports.QueryDelegationTotalRewardsRequest = exports.QueryDelegationRewardsResponse = exports.QueryDelegationRewardsRequest = exports.QueryValidatorSlashesResponse = exports.QueryValidatorSlashesRequest = exports.QueryValidatorCommissionResponse = exports.QueryValidatorCommissionRequest = exports.QueryValidatorOutstandingRewardsResponse = exports.QueryValidatorOutstandingRewardsRequest = exports.QueryValidatorDistributionInfoResponse = exports.QueryValidatorDistributionInfoRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("d450dc27da6c27a9");
const distribution_1 = require("9902456dde73e70");
const coin_1 = require("b1a2f2d3dfcb6dcf");
const binary_1 = require("6bb9fb850b326775");
const helpers_1 = require("d24ba469854a2e7b");
exports.protobufPackage = "cosmos.distribution.v1beta1";
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: distribution_1.Params.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = distribution_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = distribution_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQueryValidatorDistributionInfoRequest() {
    return {
        validatorAddress: ""
    };
}
exports.QueryValidatorDistributionInfoRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") writer.uint32(10).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorDistributionInfoRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorDistributionInfoRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseQueryValidatorDistributionInfoResponse() {
    return {
        operatorAddress: "",
        selfBondRewards: [],
        commission: []
    };
}
exports.QueryValidatorDistributionInfoResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") writer.uint32(10).string(message.operatorAddress);
        for (const v of message.selfBondRewards)coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        for (const v of message.commission)coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.operatorAddress = reader.string();
                    break;
                case 2:
                    message.selfBondRewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorDistributionInfoResponse();
        if ((0, helpers_1.isSet)(object.operatorAddress)) obj.operatorAddress = String(object.operatorAddress);
        if (Array.isArray(object?.selfBondRewards)) obj.selfBondRewards = object.selfBondRewards.map((e)=>coin_1.DecCoin.fromJSON(e));
        if (Array.isArray(object?.commission)) obj.commission = object.commission.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
        if (message.selfBondRewards) obj.selfBondRewards = message.selfBondRewards.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.selfBondRewards = [];
        if (message.commission) obj.commission = message.commission.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.commission = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorDistributionInfoResponse();
        message.operatorAddress = object.operatorAddress ?? "";
        message.selfBondRewards = object.selfBondRewards?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        message.commission = object.commission?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseQueryValidatorOutstandingRewardsRequest() {
    return {
        validatorAddress: ""
    };
}
exports.QueryValidatorOutstandingRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") writer.uint32(10).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorOutstandingRewardsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseQueryValidatorOutstandingRewardsResponse() {
    return {
        rewards: distribution_1.ValidatorOutstandingRewards.fromPartial({})
    };
}
exports.QueryValidatorOutstandingRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.rewards !== undefined) distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorOutstandingRewardsResponse();
        if ((0, helpers_1.isSet)(object.rewards)) obj.rewards = distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.rewards !== undefined && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        if (object.rewards !== undefined && object.rewards !== null) message.rewards = distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards);
        return message;
    }
};
function createBaseQueryValidatorCommissionRequest() {
    return {
        validatorAddress: ""
    };
}
exports.QueryValidatorCommissionRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") writer.uint32(10).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorCommissionRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorCommissionRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseQueryValidatorCommissionResponse() {
    return {
        commission: distribution_1.ValidatorAccumulatedCommission.fromPartial({})
    };
}
exports.QueryValidatorCommissionResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.commission !== undefined) distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorCommissionResponse();
        if ((0, helpers_1.isSet)(object.commission)) obj.commission = distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.commission !== undefined && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorCommissionResponse();
        if (object.commission !== undefined && object.commission !== null) message.commission = distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission);
        return message;
    }
};
function createBaseQueryValidatorSlashesRequest() {
    return {
        validatorAddress: "",
        startingHeight: BigInt(0),
        endingHeight: BigInt(0),
        pagination: undefined
    };
}
exports.QueryValidatorSlashesRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") writer.uint32(10).string(message.validatorAddress);
        if (message.startingHeight !== BigInt(0)) writer.uint32(16).uint64(message.startingHeight);
        if (message.endingHeight !== BigInt(0)) writer.uint32(24).uint64(message.endingHeight);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                case 2:
                    message.startingHeight = reader.uint64();
                    break;
                case 3:
                    message.endingHeight = reader.uint64();
                    break;
                case 4:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorSlashesRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.startingHeight)) obj.startingHeight = BigInt(object.startingHeight.toString());
        if ((0, helpers_1.isSet)(object.endingHeight)) obj.endingHeight = BigInt(object.endingHeight.toString());
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== undefined && (obj.startingHeight = (message.startingHeight || BigInt(0)).toString());
        message.endingHeight !== undefined && (obj.endingHeight = (message.endingHeight || BigInt(0)).toString());
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorSlashesRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.startingHeight !== undefined && object.startingHeight !== null) message.startingHeight = BigInt(object.startingHeight.toString());
        if (object.endingHeight !== undefined && object.endingHeight !== null) message.endingHeight = BigInt(object.endingHeight.toString());
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryValidatorSlashesResponse() {
    return {
        slashes: [],
        pagination: undefined
    };
}
exports.QueryValidatorSlashesResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.slashes)distribution_1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorSlashesResponse();
        if (Array.isArray(object?.slashes)) obj.slashes = object.slashes.map((e)=>distribution_1.ValidatorSlashEvent.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.slashes) obj.slashes = message.slashes.map((e)=>e ? distribution_1.ValidatorSlashEvent.toJSON(e) : undefined);
        else obj.slashes = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorSlashesResponse();
        message.slashes = object.slashes?.map((e)=>distribution_1.ValidatorSlashEvent.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegationRewardsRequest() {
    return {
        delegatorAddress: "",
        validatorAddress: ""
    };
}
exports.QueryDelegationRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegationRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegationRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseQueryDelegationRewardsResponse() {
    return {
        rewards: []
    };
}
exports.QueryDelegationRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegationRewardsResponse();
        if (Array.isArray(object?.rewards)) obj.rewards = object.rewards.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.rewards) obj.rewards = message.rewards.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.rewards = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegationRewardsResponse();
        message.rewards = object.rewards?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseQueryDelegationTotalRewardsRequest() {
    return {
        delegatorAddress: ""
    };
}
exports.QueryDelegationTotalRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegationTotalRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegationTotalRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
    }
};
function createBaseQueryDelegationTotalRewardsResponse() {
    return {
        rewards: [],
        total: []
    };
}
exports.QueryDelegationTotalRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards)distribution_1.DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.total)coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegationTotalRewardsResponse();
        if (Array.isArray(object?.rewards)) obj.rewards = object.rewards.map((e)=>distribution_1.DelegationDelegatorReward.fromJSON(e));
        if (Array.isArray(object?.total)) obj.total = object.total.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.rewards) obj.rewards = message.rewards.map((e)=>e ? distribution_1.DelegationDelegatorReward.toJSON(e) : undefined);
        else obj.rewards = [];
        if (message.total) obj.total = message.total.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.total = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegationTotalRewardsResponse();
        message.rewards = object.rewards?.map((e)=>distribution_1.DelegationDelegatorReward.fromPartial(e)) || [];
        message.total = object.total?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseQueryDelegatorValidatorsRequest() {
    return {
        delegatorAddress: ""
    };
}
exports.QueryDelegatorValidatorsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
    }
};
function createBaseQueryDelegatorValidatorsResponse() {
    return {
        validators: []
    };
}
exports.QueryDelegatorValidatorsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validators.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object?.validators)) obj.validators = object.validators.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.validators) obj.validators = message.validators.map((e)=>e);
        else obj.validators = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = object.validators?.map((e)=>e) || [];
        return message;
    }
};
function createBaseQueryDelegatorWithdrawAddressRequest() {
    return {
        delegatorAddress: ""
    };
}
exports.QueryDelegatorWithdrawAddressRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorWithdrawAddressRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
    }
};
function createBaseQueryDelegatorWithdrawAddressResponse() {
    return {
        withdrawAddress: ""
    };
}
exports.QueryDelegatorWithdrawAddressResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.withdrawAddress !== "") writer.uint32(10).string(message.withdrawAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.withdrawAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorWithdrawAddressResponse();
        if ((0, helpers_1.isSet)(object.withdrawAddress)) obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.withdrawAddress !== undefined && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
    }
};
function createBaseQueryCommunityPoolRequest() {
    return {};
}
exports.QueryCommunityPoolRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryCommunityPoolRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryCommunityPoolRequest();
        return message;
    }
};
function createBaseQueryCommunityPoolResponse() {
    return {
        pool: []
    };
}
exports.QueryCommunityPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pool)coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryCommunityPoolResponse();
        if (Array.isArray(object?.pool)) obj.pool = object.pool.map((e)=>coin_1.DecCoin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.pool) obj.pool = message.pool.map((e)=>e ? coin_1.DecCoin.toJSON(e) : undefined);
        else obj.pool = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryCommunityPoolResponse();
        message.pool = object.pool?.map((e)=>coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ValidatorDistributionInfo(request) {
        const data = exports.QueryValidatorDistributionInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", data);
        return promise.then((data)=>exports.QueryValidatorDistributionInfoResponse.decode(new binary_1.BinaryReader(data)));
    }
    ValidatorOutstandingRewards(request) {
        const data = exports.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data);
        return promise.then((data)=>exports.QueryValidatorOutstandingRewardsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ValidatorCommission(request) {
        const data = exports.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data);
        return promise.then((data)=>exports.QueryValidatorCommissionResponse.decode(new binary_1.BinaryReader(data)));
    }
    ValidatorSlashes(request) {
        const data = exports.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data);
        return promise.then((data)=>exports.QueryValidatorSlashesResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegationRewards(request) {
        const data = exports.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data);
        return promise.then((data)=>exports.QueryDelegationRewardsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegationTotalRewards(request) {
        const data = exports.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data);
        return promise.then((data)=>exports.QueryDelegationTotalRewardsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegatorValidators(request) {
        const data = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data)=>exports.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegatorWithdrawAddress(request) {
        const data = exports.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data);
        return promise.then((data)=>exports.QueryDelegatorWithdrawAddressResponse.decode(new binary_1.BinaryReader(data)));
    }
    CommunityPool(request = {}) {
        const data = exports.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data);
        return promise.then((data)=>exports.QueryCommunityPoolResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"d450dc27da6c27a9":"43d5n","9902456dde73e70":"2DwXO","b1a2f2d3dfcb6dcf":"1ymyZ","6bb9fb850b326775":"bi36x","d24ba469854a2e7b":"eYjRL"}],"2uQ4R":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
exports.createEvidenceAminoConverters = createEvidenceAminoConverters;
function isAminoMsgSubmitEvidence(msg) {
    return msg.type === "cosmos-sdk/MsgSubmitEvidence";
}
function createEvidenceAminoConverters() {
    throw new Error("Not implemented");
}

},{}],"fPmDg":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createFeegrantAminoConverters = createFeegrantAminoConverters;
function createFeegrantAminoConverters() {
    return {
    };
}

},{}],"5l019":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.feegrantTypes = void 0;
const tx_1 = require("dab578cfee0d6cfd");
exports.feegrantTypes = [
    [
        "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        tx_1.MsgGrantAllowance
    ],
    [
        "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        tx_1.MsgRevokeAllowance
    ]
];

},{"dab578cfee0d6cfd":"kMGgg"}],"kMGgg":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgPruneAllowancesResponse = exports.MsgPruneAllowances = exports.MsgRevokeAllowanceResponse = exports.MsgRevokeAllowance = exports.MsgGrantAllowanceResponse = exports.MsgGrantAllowance = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("d29fdcbf778968d9");
const binary_1 = require("95966701e6f66ffb");
const helpers_1 = require("fa4760b40b50bd0b");
exports.protobufPackage = "cosmos.feegrant.v1beta1";
function createBaseMsgGrantAllowance() {
    return {
        granter: "",
        grantee: "",
        allowance: undefined
    };
}
exports.MsgGrantAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        if (message.allowance !== undefined) any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowance();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                case 3:
                    message.allowance = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgGrantAllowance();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance)) obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.allowance !== undefined && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgGrantAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== undefined && object.allowance !== null) message.allowance = any_1.Any.fromPartial(object.allowance);
        return message;
    }
};
function createBaseMsgGrantAllowanceResponse() {
    return {};
}
exports.MsgGrantAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowanceResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgGrantAllowanceResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgGrantAllowanceResponse();
        return message;
    }
};
function createBaseMsgRevokeAllowance() {
    return {
        granter: "",
        grantee: ""
    };
}
exports.MsgRevokeAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowance();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgRevokeAllowance();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgRevokeAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
    }
};
function createBaseMsgRevokeAllowanceResponse() {
    return {};
}
exports.MsgRevokeAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowanceResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgRevokeAllowanceResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgRevokeAllowanceResponse();
        return message;
    }
};
function createBaseMsgPruneAllowances() {
    return {
        pruner: ""
    };
}
exports.MsgPruneAllowances = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowances",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pruner !== "") writer.uint32(10).string(message.pruner);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowances();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pruner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgPruneAllowances();
        if ((0, helpers_1.isSet)(object.pruner)) obj.pruner = String(object.pruner);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pruner !== undefined && (obj.pruner = message.pruner);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgPruneAllowances();
        message.pruner = object.pruner ?? "";
        return message;
    }
};
function createBaseMsgPruneAllowancesResponse() {
    return {};
}
exports.MsgPruneAllowancesResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowancesResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowancesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgPruneAllowancesResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgPruneAllowancesResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.GrantAllowance = this.GrantAllowance.bind(this);
        this.RevokeAllowance = this.RevokeAllowance.bind(this);
        this.PruneAllowances = this.PruneAllowances.bind(this);
    }
    GrantAllowance(request) {
        const data = exports.MsgGrantAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", data);
        return promise.then((data)=>exports.MsgGrantAllowanceResponse.decode(new binary_1.BinaryReader(data)));
    }
    RevokeAllowance(request) {
        const data = exports.MsgRevokeAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", data);
        return promise.then((data)=>exports.MsgRevokeAllowanceResponse.decode(new binary_1.BinaryReader(data)));
    }
    PruneAllowances(request) {
        const data = exports.MsgPruneAllowances.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "PruneAllowances", data);
        return promise.then((data)=>exports.MsgPruneAllowancesResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"d29fdcbf778968d9":"56aJC","95966701e6f66ffb":"bi36x","fa4760b40b50bd0b":"eYjRL"}],"cJRXC":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupFeegrantExtension = setupFeegrantExtension;
const query_1 = require("5164bd2a00746275");
const queryclient_1 = require("f72e7eb5345d9d82");
function setupFeegrantExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        feegrant: {
            allowance: async (granter, grantee)=>{
                const response = await queryService.Allowance({
                    granter: granter,
                    grantee: grantee
                });
                return response;
            },
            allowances: async (grantee, paginationKey)=>{
                const response = await queryService.Allowances({
                    grantee: grantee,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            }
        }
    };
}

},{"5164bd2a00746275":"cThHU","f72e7eb5345d9d82":"cM4fi"}],"cThHU":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryAllowancesByGranterResponse = exports.QueryAllowancesByGranterRequest = exports.QueryAllowancesResponse = exports.QueryAllowancesRequest = exports.QueryAllowanceResponse = exports.QueryAllowanceRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("b59d29ad4c99b358");
const feegrant_1 = require("b0839f79ed11184c");
const binary_1 = require("2f6ed053210aff60");
const helpers_1 = require("2ded3645e2ddccc3");
exports.protobufPackage = "cosmos.feegrant.v1beta1";
function createBaseQueryAllowanceRequest() {
    return {
        granter: "",
        grantee: ""
    };
}
exports.QueryAllowanceRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllowanceRequest();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllowanceRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
    }
};
function createBaseQueryAllowanceResponse() {
    return {
        allowance: undefined
    };
}
exports.QueryAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== undefined) feegrant_1.Grant.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.allowance = feegrant_1.Grant.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllowanceResponse();
        if ((0, helpers_1.isSet)(object.allowance)) obj.allowance = feegrant_1.Grant.fromJSON(object.allowance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.allowance !== undefined && (obj.allowance = message.allowance ? feegrant_1.Grant.toJSON(message.allowance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllowanceResponse();
        if (object.allowance !== undefined && object.allowance !== null) message.allowance = feegrant_1.Grant.fromPartial(object.allowance);
        return message;
    }
};
function createBaseQueryAllowancesRequest() {
    return {
        grantee: "",
        pagination: undefined
    };
}
exports.QueryAllowancesRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") writer.uint32(10).string(message.grantee);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.grantee = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllowancesRequest();
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllowancesRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryAllowancesResponse() {
    return {
        allowances: [],
        pagination: undefined
    };
}
exports.QueryAllowancesResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances)feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllowancesResponse();
        if (Array.isArray(object?.allowances)) obj.allowances = object.allowances.map((e)=>feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.allowances) obj.allowances = message.allowances.map((e)=>e ? feegrant_1.Grant.toJSON(e) : undefined);
        else obj.allowances = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllowancesResponse();
        message.allowances = object.allowances?.map((e)=>feegrant_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryAllowancesByGranterRequest() {
    return {
        granter: "",
        pagination: undefined
    };
}
exports.QueryAllowancesByGranterRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllowancesByGranterRequest();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllowancesByGranterRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryAllowancesByGranterResponse() {
    return {
        allowances: [],
        pagination: undefined
    };
}
exports.QueryAllowancesByGranterResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances)feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAllowancesByGranterResponse();
        if (Array.isArray(object?.allowances)) obj.allowances = object.allowances.map((e)=>feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.allowances) obj.allowances = message.allowances.map((e)=>e ? feegrant_1.Grant.toJSON(e) : undefined);
        else obj.allowances = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAllowancesByGranterResponse();
        message.allowances = object.allowances?.map((e)=>feegrant_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Allowance = this.Allowance.bind(this);
        this.Allowances = this.Allowances.bind(this);
        this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
    }
    Allowance(request) {
        const data = exports.QueryAllowanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", data);
        return promise.then((data)=>exports.QueryAllowanceResponse.decode(new binary_1.BinaryReader(data)));
    }
    Allowances(request) {
        const data = exports.QueryAllowancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", data);
        return promise.then((data)=>exports.QueryAllowancesResponse.decode(new binary_1.BinaryReader(data)));
    }
    AllowancesByGranter(request) {
        const data = exports.QueryAllowancesByGranterRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", data);
        return promise.then((data)=>exports.QueryAllowancesByGranterResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"b59d29ad4c99b358":"43d5n","b0839f79ed11184c":"8MSfR","2f6ed053210aff60":"bi36x","2ded3645e2ddccc3":"eYjRL"}],"8MSfR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Grant = exports.AllowedMsgAllowance = exports.PeriodicAllowance = exports.BasicAllowance = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("ec416251e4dd23a5");
const timestamp_1 = require("809f77db6169675d");
const duration_1 = require("32c9d178c81e6301");
const any_1 = require("95cd271be5ea5e9f");
const binary_1 = require("bcbd754b2e47a8ef");
const helpers_1 = require("f4d05afddf4779cf");
exports.protobufPackage = "cosmos.feegrant.v1beta1";
function createBaseBasicAllowance() {
    return {
        spendLimit: [],
        expiration: undefined
    };
}
exports.BasicAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.spendLimit)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.expiration !== undefined) timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicAllowance();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBasicAllowance();
        if (Array.isArray(object?.spendLimit)) obj.spendLimit = object.spendLimit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.expiration)) obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.spendLimit) obj.spendLimit = message.spendLimit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.spendLimit = [];
        message.expiration !== undefined && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBasicAllowance();
        message.spendLimit = object.spendLimit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.expiration !== undefined && object.expiration !== null) message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        return message;
    }
};
function createBasePeriodicAllowance() {
    return {
        basic: exports.BasicAllowance.fromPartial({}),
        period: duration_1.Duration.fromPartial({}),
        periodSpendLimit: [],
        periodCanSpend: [],
        periodReset: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.PeriodicAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.basic !== undefined) exports.BasicAllowance.encode(message.basic, writer.uint32(10).fork()).ldelim();
        if (message.period !== undefined) duration_1.Duration.encode(message.period, writer.uint32(18).fork()).ldelim();
        for (const v of message.periodSpendLimit)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        for (const v of message.periodCanSpend)coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        if (message.periodReset !== undefined) timestamp_1.Timestamp.encode(message.periodReset, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePeriodicAllowance();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.basic = exports.BasicAllowance.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.period = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.periodSpendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.periodCanSpend.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.periodReset = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePeriodicAllowance();
        if ((0, helpers_1.isSet)(object.basic)) obj.basic = exports.BasicAllowance.fromJSON(object.basic);
        if ((0, helpers_1.isSet)(object.period)) obj.period = duration_1.Duration.fromJSON(object.period);
        if (Array.isArray(object?.periodSpendLimit)) obj.periodSpendLimit = object.periodSpendLimit.map((e)=>coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.periodCanSpend)) obj.periodCanSpend = object.periodCanSpend.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.periodReset)) obj.periodReset = (0, helpers_1.fromJsonTimestamp)(object.periodReset);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.basic !== undefined && (obj.basic = message.basic ? exports.BasicAllowance.toJSON(message.basic) : undefined);
        message.period !== undefined && (obj.period = message.period ? duration_1.Duration.toJSON(message.period) : undefined);
        if (message.periodSpendLimit) obj.periodSpendLimit = message.periodSpendLimit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.periodSpendLimit = [];
        if (message.periodCanSpend) obj.periodCanSpend = message.periodCanSpend.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.periodCanSpend = [];
        message.periodReset !== undefined && (obj.periodReset = (0, helpers_1.fromTimestamp)(message.periodReset).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBasePeriodicAllowance();
        if (object.basic !== undefined && object.basic !== null) message.basic = exports.BasicAllowance.fromPartial(object.basic);
        if (object.period !== undefined && object.period !== null) message.period = duration_1.Duration.fromPartial(object.period);
        message.periodSpendLimit = object.periodSpendLimit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.periodCanSpend = object.periodCanSpend?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.periodReset !== undefined && object.periodReset !== null) message.periodReset = timestamp_1.Timestamp.fromPartial(object.periodReset);
        return message;
    }
};
function createBaseAllowedMsgAllowance() {
    return {
        allowance: undefined,
        allowedMessages: []
    };
}
exports.AllowedMsgAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== undefined) any_1.Any.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        for (const v of message.allowedMessages)writer.uint32(18).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAllowedMsgAllowance();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.allowance = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.allowedMessages.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAllowedMsgAllowance();
        if ((0, helpers_1.isSet)(object.allowance)) obj.allowance = any_1.Any.fromJSON(object.allowance);
        if (Array.isArray(object?.allowedMessages)) obj.allowedMessages = object.allowedMessages.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.allowance !== undefined && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : undefined);
        if (message.allowedMessages) obj.allowedMessages = message.allowedMessages.map((e)=>e);
        else obj.allowedMessages = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAllowedMsgAllowance();
        if (object.allowance !== undefined && object.allowance !== null) message.allowance = any_1.Any.fromPartial(object.allowance);
        message.allowedMessages = object.allowedMessages?.map((e)=>e) || [];
        return message;
    }
};
function createBaseGrant() {
    return {
        granter: "",
        grantee: "",
        allowance: undefined
    };
}
exports.Grant = {
    typeUrl: "/cosmos.feegrant.v1beta1.Grant",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") writer.uint32(10).string(message.granter);
        if (message.grantee !== "") writer.uint32(18).string(message.grantee);
        if (message.allowance !== undefined) any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.granter = reader.string();
                    break;
                case 2:
                    message.grantee = reader.string();
                    break;
                case 3:
                    message.allowance = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.granter)) obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee)) obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance)) obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.granter !== undefined && (obj.granter = message.granter);
        message.grantee !== undefined && (obj.grantee = message.grantee);
        message.allowance !== undefined && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== undefined && object.allowance !== null) message.allowance = any_1.Any.fromPartial(object.allowance);
        return message;
    }
};

},{"ec416251e4dd23a5":"1ymyZ","809f77db6169675d":"6J6bq","32c9d178c81e6301":"clU50","95cd271be5ea5e9f":"56aJC","bcbd754b2e47a8ef":"bi36x","f4d05afddf4779cf":"eYjRL"}],"clU50":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Duration = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("6c7c97488f6bfb99");
const helpers_1 = require("3a6eae617d51d1fa");
exports.protobufPackage = "google.protobuf";
function createBaseDuration() {
    return {
        seconds: BigInt(0),
        nanos: 0
    };
}
exports.Duration = {
    typeUrl: "/google.protobuf.Duration",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) writer.uint32(8).int64(message.seconds);
        if (message.nanos !== 0) writer.uint32(16).int32(message.nanos);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDuration();
        if ((0, helpers_1.isSet)(object.seconds)) obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos)) obj.nanos = Number(object.nanos);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.seconds !== undefined && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDuration();
        if (object.seconds !== undefined && object.seconds !== null) message.seconds = BigInt(object.seconds.toString());
        message.nanos = object.nanos ?? 0;
        return message;
    }
};

},{"6c7c97488f6bfb99":"bi36x","3a6eae617d51d1fa":"eYjRL"}],"2vEMh":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
exports.isAminoMsgVote = isAminoMsgVote;
exports.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
exports.isAminoMsgDeposit = isAminoMsgDeposit;
exports.createGovAminoConverters = createGovAminoConverters;
const math_1 = require("f13a6997e27832ff");
const utils_1 = require("cabb0d14a4cce396");
const gov_1 = require("5314b96924182703");
const any_1 = require("687f0d0b25c4fd53");
const queryclient_1 = require("7c33c88910a6f866");
function isAminoMsgSubmitProposal(msg) {
    return msg.type === "cosmos-sdk/MsgSubmitProposal";
}
function isAminoMsgVote(msg) {
    return msg.type === "cosmos-sdk/MsgVote";
}
function isAminoMsgVoteWeighted(msg) {
    return msg.type === "cosmos-sdk/MsgVoteWeighted";
}
function isAminoMsgDeposit(msg) {
    return msg.type === "cosmos-sdk/MsgDeposit";
}
function createGovAminoConverters() {
    // Gov v1 types missing, see
    // https://github.com/cosmos/cosmjs/issues/1442
    return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
            aminoType: "cosmos-sdk/MsgDeposit",
            toAmino: ({ amount, depositor, proposalId })=>{
                return {
                    amount,
                    depositor,
                    proposal_id: proposalId.toString()
                };
            },
            fromAmino: ({ amount, depositor, proposal_id })=>{
                return {
                    amount: Array.from(amount),
                    depositor,
                    proposalId: BigInt(proposal_id)
                };
            }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
            aminoType: "cosmos-sdk/MsgVote",
            toAmino: ({ option, proposalId, voter })=>{
                return {
                    option: option,
                    proposal_id: proposalId.toString(),
                    voter: voter
                };
            },
            fromAmino: ({ option, proposal_id, voter })=>{
                return {
                    option: (0, gov_1.voteOptionFromJSON)(option),
                    proposalId: BigInt(proposal_id),
                    voter: voter
                };
            }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
            aminoType: "cosmos-sdk/MsgVoteWeighted",
            toAmino: ({ options, proposalId, voter })=>{
                return {
                    options: options.map((o)=>({
                            option: o.option,
                            // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                            // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                            weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
                        })),
                    proposal_id: proposalId.toString(),
                    voter: voter
                };
            },
            fromAmino: ({ options, proposal_id, voter })=>{
                return {
                    proposalId: BigInt(proposal_id),
                    voter: voter,
                    options: options.map((o)=>({
                            option: (0, gov_1.voteOptionFromJSON)(o.option),
                            weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
                        }))
                };
            }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
            aminoType: "cosmos-sdk/MsgSubmitProposal",
            toAmino: ({ initialDeposit, proposer, content })=>{
                (0, utils_1.assertDefinedAndNotNull)(content);
                let proposal;
                switch(content.typeUrl){
                    case "/cosmos.gov.v1beta1.TextProposal":
                        {
                            const textProposal = gov_1.TextProposal.decode(content.value);
                            proposal = {
                                type: "cosmos-sdk/TextProposal",
                                value: {
                                    description: textProposal.description,
                                    title: textProposal.title
                                }
                            };
                            break;
                        }
                    default:
                        throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
                }
                return {
                    initial_deposit: initialDeposit,
                    proposer: proposer,
                    content: proposal
                };
            },
            fromAmino: ({ initial_deposit, proposer, content })=>{
                let any_content;
                switch(content.type){
                    case "cosmos-sdk/TextProposal":
                        {
                            const { value } = content;
                            (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                            const { title, description } = value;
                            (0, utils_1.assert)(typeof title === "string");
                            (0, utils_1.assert)(typeof description === "string");
                            any_content = any_1.Any.fromPartial({
                                typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                                value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                                    title: title,
                                    description: description
                                })).finish()
                            });
                            break;
                        }
                    default:
                        throw new Error(`Unsupported proposal type: '${content.type}'`);
                }
                return {
                    initialDeposit: Array.from(initial_deposit),
                    proposer: proposer,
                    content: any_content
                };
            }
        }
    };
}

},{"f13a6997e27832ff":"e8aug","cabb0d14a4cce396":"3R4mb","5314b96924182703":"fjQm7","687f0d0b25c4fd53":"56aJC","7c33c88910a6f866":"cM4fi"}],"fjQm7":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.TextProposal = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("9790a8126b7c41dd");
const any_1 = require("e4167954601dd152");
const timestamp_1 = require("883a924b8167ebfa");
const duration_1 = require("58038a03637b925a");
const binary_1 = require("918c4bffec62f27a");
const helpers_1 = require("c7787bd45ab4bf26");
exports.protobufPackage = "cosmos.gov.v1beta1";
/** VoteOption enumerates the valid vote options for a given governance proposal. */ var VoteOption;
(function(VoteOption) {
    /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */ VoteOption[VoteOption["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
    /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */ VoteOption[VoteOption["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
    /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */ VoteOption[VoteOption["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
    /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */ VoteOption[VoteOption["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
    /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */ VoteOption[VoteOption["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
    VoteOption[VoteOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VoteOption || (exports.VoteOption = VoteOption = {}));
function voteOptionFromJSON(object) {
    switch(object){
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
            return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
            return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
            return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
            return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
            return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VoteOption.UNRECOGNIZED;
    }
}
exports.voteOptionFromJSON = voteOptionFromJSON;
function voteOptionToJSON(object) {
    switch(object){
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
            return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
            return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
            return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
            return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
            return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.voteOptionToJSON = voteOptionToJSON;
/** ProposalStatus enumerates the valid statuses of a proposal. */ var ProposalStatus;
(function(ProposalStatus) {
    /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status. */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
    /**
     * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
     * period.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
    /**
     * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
     * period.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
    /**
     * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
     * passed.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
    /**
     * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
     * been rejected.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
    /**
     * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
     * failed.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
    ProposalStatus[ProposalStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
function proposalStatusFromJSON(object) {
    switch(object){
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
            return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
            return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
            return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
            return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
            return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
            return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProposalStatus.UNRECOGNIZED;
    }
}
exports.proposalStatusFromJSON = proposalStatusFromJSON;
function proposalStatusToJSON(object) {
    switch(object){
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
            return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
            return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
            return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
            return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
            return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
            return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.proposalStatusToJSON = proposalStatusToJSON;
function createBaseWeightedVoteOption() {
    return {
        option: 0,
        weight: ""
    };
}
exports.WeightedVoteOption = {
    typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) writer.uint32(8).int32(message.option);
        if (message.weight !== "") writer.uint32(18).string(message.weight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.option = reader.int32();
                    break;
                case 2:
                    message.weight = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option)) obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight)) obj.weight = String(object.weight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.option !== undefined && (obj.option = voteOptionToJSON(message.option));
        message.weight !== undefined && (obj.weight = message.weight);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
    }
};
function createBaseTextProposal() {
    return {
        title: "",
        description: ""
    };
}
exports.TextProposal = {
    typeUrl: "/cosmos.gov.v1beta1.TextProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTextProposal();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTextProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
    }
};
function createBaseDeposit() {
    return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
    };
}
exports.Deposit = {
    typeUrl: "/cosmos.gov.v1beta1.Deposit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.depositor !== "") writer.uint32(18).string(message.depositor);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.depositor = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== undefined && (obj.depositor = message.depositor);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDeposit();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseProposal() {
    return {
        proposalId: BigInt(0),
        content: undefined,
        status: 0,
        finalTallyResult: exports.TallyResult.fromPartial({}),
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        depositEndTime: timestamp_1.Timestamp.fromPartial({}),
        totalDeposit: [],
        votingStartTime: timestamp_1.Timestamp.fromPartial({}),
        votingEndTime: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.Proposal = {
    typeUrl: "/cosmos.gov.v1beta1.Proposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.content !== undefined) any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        if (message.status !== 0) writer.uint32(24).int32(message.status);
        if (message.finalTallyResult !== undefined) exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        if (message.submitTime !== undefined) timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        if (message.depositEndTime !== undefined) timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        for (const v of message.totalDeposit)coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        if (message.votingStartTime !== undefined) timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        if (message.votingEndTime !== undefined) timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.content = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.content)) obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.status)) obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult)) obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime)) obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime)) obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object?.totalDeposit)) obj.totalDeposit = object.totalDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime)) obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime)) obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.content !== undefined && (obj.content = message.content ? any_1.Any.toJSON(message.content) : undefined);
        message.status !== undefined && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== undefined && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : undefined);
        message.submitTime !== undefined && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== undefined && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) obj.totalDeposit = message.totalDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.totalDeposit = [];
        message.votingStartTime !== undefined && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== undefined && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProposal();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        if (object.content !== undefined && object.content !== null) message.content = any_1.Any.fromPartial(object.content);
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== undefined && object.finalTallyResult !== null) message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        if (object.submitTime !== undefined && object.submitTime !== null) message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        if (object.depositEndTime !== undefined && object.depositEndTime !== null) message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        message.totalDeposit = object.totalDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.votingStartTime !== undefined && object.votingStartTime !== null) message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        if (object.votingEndTime !== undefined && object.votingEndTime !== null) message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        return message;
    }
};
function createBaseTallyResult() {
    return {
        yes: "",
        abstain: "",
        no: "",
        noWithVeto: ""
    };
}
exports.TallyResult = {
    typeUrl: "/cosmos.gov.v1beta1.TallyResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.yes !== "") writer.uint32(10).string(message.yes);
        if (message.abstain !== "") writer.uint32(18).string(message.abstain);
        if (message.no !== "") writer.uint32(26).string(message.no);
        if (message.noWithVeto !== "") writer.uint32(34).string(message.noWithVeto);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.yes = reader.string();
                    break;
                case 2:
                    message.abstain = reader.string();
                    break;
                case 3:
                    message.no = reader.string();
                    break;
                case 4:
                    message.noWithVeto = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yes)) obj.yes = String(object.yes);
        if ((0, helpers_1.isSet)(object.abstain)) obj.abstain = String(object.abstain);
        if ((0, helpers_1.isSet)(object.no)) obj.no = String(object.no);
        if ((0, helpers_1.isSet)(object.noWithVeto)) obj.noWithVeto = String(object.noWithVeto);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.yes !== undefined && (obj.yes = message.yes);
        message.abstain !== undefined && (obj.abstain = message.abstain);
        message.no !== undefined && (obj.no = message.no);
        message.noWithVeto !== undefined && (obj.noWithVeto = message.noWithVeto);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTallyResult();
        message.yes = object.yes ?? "";
        message.abstain = object.abstain ?? "";
        message.no = object.no ?? "";
        message.noWithVeto = object.noWithVeto ?? "";
        return message;
    }
};
function createBaseVote() {
    return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        options: []
    };
}
exports.Vote = {
    typeUrl: "/cosmos.gov.v1beta1.Vote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        if (message.option !== 0) writer.uint32(24).int32(message.option);
        for (const v of message.options)exports.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.option = reader.int32();
                    break;
                case 4:
                    message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option)) obj.option = voteOptionFromJSON(object.option);
        if (Array.isArray(object?.options)) obj.options = object.options.map((e)=>exports.WeightedVoteOption.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        message.option !== undefined && (obj.option = voteOptionToJSON(message.option));
        if (message.options) obj.options = message.options.map((e)=>e ? exports.WeightedVoteOption.toJSON(e) : undefined);
        else obj.options = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVote();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.options = object.options?.map((e)=>exports.WeightedVoteOption.fromPartial(e)) || [];
        return message;
    }
};
function createBaseDepositParams() {
    return {
        minDeposit: [],
        maxDepositPeriod: duration_1.Duration.fromPartial({})
    };
}
exports.DepositParams = {
    typeUrl: "/cosmos.gov.v1beta1.DepositParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.maxDepositPeriod !== undefined) duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object?.minDeposit)) obj.minDeposit = object.minDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod)) obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.minDeposit) obj.minDeposit = message.minDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.minDeposit = [];
        message.maxDepositPeriod !== undefined && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDepositParams();
        message.minDeposit = object.minDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null) message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        return message;
    }
};
function createBaseVotingParams() {
    return {
        votingPeriod: duration_1.Duration.fromPartial({})
    };
}
exports.VotingParams = {
    typeUrl: "/cosmos.gov.v1beta1.VotingParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== undefined) duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod)) obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.votingPeriod !== undefined && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== undefined && object.votingPeriod !== null) message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        return message;
    }
};
function createBaseTallyParams() {
    return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
    };
}
exports.TallyParams = {
    typeUrl: "/cosmos.gov.v1beta1.TallyParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum.length !== 0) writer.uint32(10).bytes(message.quorum);
        if (message.threshold.length !== 0) writer.uint32(18).bytes(message.threshold);
        if (message.vetoThreshold.length !== 0) writer.uint32(26).bytes(message.vetoThreshold);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.quorum = reader.bytes();
                    break;
                case 2:
                    message.threshold = reader.bytes();
                    break;
                case 3:
                    message.vetoThreshold = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum)) obj.quorum = (0, helpers_1.bytesFromBase64)(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold)) obj.threshold = (0, helpers_1.bytesFromBase64)(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold)) obj.vetoThreshold = (0, helpers_1.bytesFromBase64)(object.vetoThreshold);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.quorum !== undefined && (obj.quorum = (0, helpers_1.base64FromBytes)(message.quorum !== undefined ? message.quorum : new Uint8Array()));
        message.threshold !== undefined && (obj.threshold = (0, helpers_1.base64FromBytes)(message.threshold !== undefined ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== undefined && (obj.vetoThreshold = (0, helpers_1.base64FromBytes)(message.vetoThreshold !== undefined ? message.vetoThreshold : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? new Uint8Array();
        message.threshold = object.threshold ?? new Uint8Array();
        message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();
        return message;
    }
};

},{"9790a8126b7c41dd":"1ymyZ","e4167954601dd152":"56aJC","883a924b8167ebfa":"6J6bq","58038a03637b925a":"clU50","918c4bffec62f27a":"bi36x","c7787bd45ab4bf26":"eYjRL"}],"cvYef":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.govTypes = void 0;
exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
exports.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
const tx_1 = require("96876caf02dd7c8b");
const tx_2 = require("bbc61b5974b7bbbd");
exports.govTypes = [
    [
        "/cosmos.gov.v1.MsgDeposit",
        tx_1.MsgDeposit
    ],
    [
        "/cosmos.gov.v1.MsgSubmitProposal",
        tx_1.MsgSubmitProposal
    ],
    [
        "/cosmos.gov.v1.MsgUpdateParams",
        tx_1.MsgUpdateParams
    ],
    [
        "/cosmos.gov.v1.MsgVote",
        tx_1.MsgVote
    ],
    [
        "/cosmos.gov.v1.MsgVoteWeighted",
        tx_1.MsgVoteWeighted
    ],
    [
        "/cosmos.gov.v1beta1.MsgDeposit",
        tx_2.MsgDeposit
    ],
    [
        "/cosmos.gov.v1beta1.MsgSubmitProposal",
        tx_2.MsgSubmitProposal
    ],
    [
        "/cosmos.gov.v1beta1.MsgVote",
        tx_2.MsgVote
    ],
    [
        "/cosmos.gov.v1beta1.MsgVoteWeighted",
        tx_2.MsgVoteWeighted
    ]
];
function isMsgDepositEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
}
function isMsgSubmitProposalEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
}
function isMsgVoteEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
}
function isMsgVoteWeightedEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
}

},{"96876caf02dd7c8b":"gXGad","bbc61b5974b7bbbd":"jUy9K"}],"gXGad":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgCancelProposalResponse = exports.MsgCancelProposal = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgExecLegacyContentResponse = exports.MsgExecLegacyContent = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("2f7d722138cd3dae");
const coin_1 = require("c599182b6bb94ecd");
const gov_1 = require("7cad09bc73922cde");
const timestamp_1 = require("d85727e57c969ea0");
const binary_1 = require("277a5e74c19d3ae2");
const helpers_1 = require("4361d5419b826d70");
exports.protobufPackage = "cosmos.gov.v1";
function createBaseMsgSubmitProposal() {
    return {
        messages: [],
        initialDeposit: [],
        proposer: "",
        metadata: "",
        title: "",
        summary: "",
        expedited: false
    };
}
exports.MsgSubmitProposal = {
    typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages)any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.initialDeposit)coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.proposer !== "") writer.uint32(26).string(message.proposer);
        if (message.metadata !== "") writer.uint32(34).string(message.metadata);
        if (message.title !== "") writer.uint32(42).string(message.title);
        if (message.summary !== "") writer.uint32(50).string(message.summary);
        if (message.expedited === true) writer.uint32(56).bool(message.expedited);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.proposer = reader.string();
                    break;
                case 4:
                    message.metadata = reader.string();
                    break;
                case 5:
                    message.title = reader.string();
                    break;
                case 6:
                    message.summary = reader.string();
                    break;
                case 7:
                    message.expedited = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitProposal();
        if (Array.isArray(object?.messages)) obj.messages = object.messages.map((e)=>any_1.Any.fromJSON(e));
        if (Array.isArray(object?.initialDeposit)) obj.initialDeposit = object.initialDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer)) obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary)) obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.expedited)) obj.expedited = Boolean(object.expedited);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.messages) obj.messages = message.messages.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.messages = [];
        if (message.initialDeposit) obj.initialDeposit = message.initialDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.initialDeposit = [];
        message.proposer !== undefined && (obj.proposer = message.proposer);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.title !== undefined && (obj.title = message.title);
        message.summary !== undefined && (obj.summary = message.summary);
        message.expedited !== undefined && (obj.expedited = message.expedited);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitProposal();
        message.messages = object.messages?.map((e)=>any_1.Any.fromPartial(e)) || [];
        message.initialDeposit = object.initialDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.expedited = object.expedited ?? false;
        return message;
    }
};
function createBaseMsgSubmitProposalResponse() {
    return {
        proposalId: BigInt(0)
    };
}
exports.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        return message;
    }
};
function createBaseMsgExecLegacyContent() {
    return {
        content: undefined,
        authority: ""
    };
}
exports.MsgExecLegacyContent = {
    typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== undefined) any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        if (message.authority !== "") writer.uint32(18).string(message.authority);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.content = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.authority = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgExecLegacyContent();
        if ((0, helpers_1.isSet)(object.content)) obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.content !== undefined && (obj.content = message.content ? any_1.Any.toJSON(message.content) : undefined);
        message.authority !== undefined && (obj.authority = message.authority);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgExecLegacyContent();
        if (object.content !== undefined && object.content !== null) message.content = any_1.Any.fromPartial(object.content);
        message.authority = object.authority ?? "";
        return message;
    }
};
function createBaseMsgExecLegacyContentResponse() {
    return {};
}
exports.MsgExecLegacyContentResponse = {
    typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContentResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgExecLegacyContentResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgExecLegacyContentResponse();
        return message;
    }
};
function createBaseMsgVote() {
    return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: ""
    };
}
exports.MsgVote = {
    typeUrl: "/cosmos.gov.v1.MsgVote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        if (message.option !== 0) writer.uint32(24).int32(message.option);
        if (message.metadata !== "") writer.uint32(34).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.option = reader.int32();
                    break;
                case 4:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option)) obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        message.option !== undefined && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseMsgVoteResponse() {
    return {};
}
exports.MsgVoteResponse = {
    typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgVoteResponse();
        return message;
    }
};
function createBaseMsgVoteWeighted() {
    return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
    };
}
exports.MsgVoteWeighted = {
    typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        for (const v of message.options)gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.metadata !== "") writer.uint32(34).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if (Array.isArray(object?.options)) obj.options = object.options.map((e)=>gov_1.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        if (message.options) obj.options = message.options.map((e)=>e ? gov_1.WeightedVoteOption.toJSON(e) : undefined);
        else obj.options = [];
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e)=>gov_1.WeightedVoteOption.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseMsgVoteWeightedResponse() {
    return {};
}
exports.MsgVoteWeightedResponse = {
    typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
    }
};
function createBaseMsgDeposit() {
    return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
    };
}
exports.MsgDeposit = {
    typeUrl: "/cosmos.gov.v1.MsgDeposit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.depositor !== "") writer.uint32(18).string(message.depositor);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.depositor = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== undefined && (obj.depositor = message.depositor);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgDeposit();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgDepositResponse() {
    return {};
}
exports.MsgDepositResponse = {
    typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgDepositResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgDepositResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: gov_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        if (message.params !== undefined) gov_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = gov_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params)) obj.params = gov_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined && (obj.params = message.params ? gov_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== undefined && object.params !== null) message.params = gov_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
function createBaseMsgCancelProposal() {
    return {
        proposalId: BigInt(0),
        proposer: ""
    };
}
exports.MsgCancelProposal = {
    typeUrl: "/cosmos.gov.v1.MsgCancelProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.proposer !== "") writer.uint32(18).string(message.proposer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.proposer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCancelProposal();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.proposer)) obj.proposer = String(object.proposer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.proposer !== undefined && (obj.proposer = message.proposer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCancelProposal();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.proposer = object.proposer ?? "";
        return message;
    }
};
function createBaseMsgCancelProposalResponse() {
    return {
        proposalId: BigInt(0),
        canceledTime: timestamp_1.Timestamp.fromPartial({}),
        canceledHeight: BigInt(0)
    };
}
exports.MsgCancelProposalResponse = {
    typeUrl: "/cosmos.gov.v1.MsgCancelProposalResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.canceledTime !== undefined) timestamp_1.Timestamp.encode(message.canceledTime, writer.uint32(18).fork()).ldelim();
        if (message.canceledHeight !== BigInt(0)) writer.uint32(24).uint64(message.canceledHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposalResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.canceledTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.canceledHeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCancelProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.canceledTime)) obj.canceledTime = (0, helpers_1.fromJsonTimestamp)(object.canceledTime);
        if ((0, helpers_1.isSet)(object.canceledHeight)) obj.canceledHeight = BigInt(object.canceledHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.canceledTime !== undefined && (obj.canceledTime = (0, helpers_1.fromTimestamp)(message.canceledTime).toISOString());
        message.canceledHeight !== undefined && (obj.canceledHeight = (message.canceledHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCancelProposalResponse();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        if (object.canceledTime !== undefined && object.canceledTime !== null) message.canceledTime = timestamp_1.Timestamp.fromPartial(object.canceledTime);
        if (object.canceledHeight !== undefined && object.canceledHeight !== null) message.canceledHeight = BigInt(object.canceledHeight.toString());
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.ExecLegacyContent = this.ExecLegacyContent.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CancelProposal = this.CancelProposal.bind(this);
    }
    SubmitProposal(request) {
        const data = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", data);
        return promise.then((data)=>exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data)));
    }
    ExecLegacyContent(request) {
        const data = exports.MsgExecLegacyContent.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", data);
        return promise.then((data)=>exports.MsgExecLegacyContentResponse.decode(new binary_1.BinaryReader(data)));
    }
    Vote(request) {
        const data = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Vote", data);
        return promise.then((data)=>exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data)));
    }
    VoteWeighted(request) {
        const data = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", data);
        return promise.then((data)=>exports.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data)));
    }
    Deposit(request) {
        const data = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Deposit", data);
        return promise.then((data)=>exports.MsgDepositResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    CancelProposal(request) {
        const data = exports.MsgCancelProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "CancelProposal", data);
        return promise.then((data)=>exports.MsgCancelProposalResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"2f7d722138cd3dae":"56aJC","c599182b6bb94ecd":"1ymyZ","7cad09bc73922cde":"758RO","d85727e57c969ea0":"6J6bq","277a5e74c19d3ae2":"bi36x","4361d5419b826d70":"eYjRL"}],"758RO":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("eb37139fdfab40b5");
const any_1 = require("8d2974a27160c820");
const timestamp_1 = require("82bef03f04881240");
const duration_1 = require("9fb7e70b9b4473f6");
const binary_1 = require("3ddb24e76c5dad1e");
const helpers_1 = require("decc70e97c66250f");
exports.protobufPackage = "cosmos.gov.v1";
/** VoteOption enumerates the valid vote options for a given governance proposal. */ var VoteOption;
(function(VoteOption) {
    /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */ VoteOption[VoteOption["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
    /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */ VoteOption[VoteOption["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
    /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */ VoteOption[VoteOption["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
    /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */ VoteOption[VoteOption["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
    /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */ VoteOption[VoteOption["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
    VoteOption[VoteOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VoteOption || (exports.VoteOption = VoteOption = {}));
function voteOptionFromJSON(object) {
    switch(object){
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
            return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
            return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
            return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
            return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
            return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VoteOption.UNRECOGNIZED;
    }
}
exports.voteOptionFromJSON = voteOptionFromJSON;
function voteOptionToJSON(object) {
    switch(object){
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
            return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
            return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
            return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
            return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
            return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.voteOptionToJSON = voteOptionToJSON;
/** ProposalStatus enumerates the valid statuses of a proposal. */ var ProposalStatus;
(function(ProposalStatus) {
    /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status. */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
    /**
     * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
     * period.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
    /**
     * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
     * period.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
    /**
     * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
     * passed.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
    /**
     * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
     * been rejected.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
    /**
     * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
     * failed.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
    ProposalStatus[ProposalStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
function proposalStatusFromJSON(object) {
    switch(object){
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
            return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
            return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
            return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
            return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
            return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
            return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProposalStatus.UNRECOGNIZED;
    }
}
exports.proposalStatusFromJSON = proposalStatusFromJSON;
function proposalStatusToJSON(object) {
    switch(object){
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
            return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
            return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
            return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
            return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
            return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
            return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.proposalStatusToJSON = proposalStatusToJSON;
function createBaseWeightedVoteOption() {
    return {
        option: 0,
        weight: ""
    };
}
exports.WeightedVoteOption = {
    typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) writer.uint32(8).int32(message.option);
        if (message.weight !== "") writer.uint32(18).string(message.weight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.option = reader.int32();
                    break;
                case 2:
                    message.weight = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option)) obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight)) obj.weight = String(object.weight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.option !== undefined && (obj.option = voteOptionToJSON(message.option));
        message.weight !== undefined && (obj.weight = message.weight);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
    }
};
function createBaseDeposit() {
    return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
    };
}
exports.Deposit = {
    typeUrl: "/cosmos.gov.v1.Deposit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.depositor !== "") writer.uint32(18).string(message.depositor);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.depositor = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== undefined && (obj.depositor = message.depositor);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDeposit();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseProposal() {
    return {
        id: BigInt(0),
        messages: [],
        status: 0,
        finalTallyResult: undefined,
        submitTime: undefined,
        depositEndTime: undefined,
        totalDeposit: [],
        votingStartTime: undefined,
        votingEndTime: undefined,
        metadata: "",
        title: "",
        summary: "",
        proposer: "",
        expedited: false,
        failedReason: ""
    };
}
exports.Proposal = {
    typeUrl: "/cosmos.gov.v1.Proposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) writer.uint32(8).uint64(message.id);
        for (const v of message.messages)any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.status !== 0) writer.uint32(24).int32(message.status);
        if (message.finalTallyResult !== undefined) exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        if (message.submitTime !== undefined) timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        if (message.depositEndTime !== undefined) timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        for (const v of message.totalDeposit)coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        if (message.votingStartTime !== undefined) timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        if (message.votingEndTime !== undefined) timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        if (message.metadata !== "") writer.uint32(82).string(message.metadata);
        if (message.title !== "") writer.uint32(90).string(message.title);
        if (message.summary !== "") writer.uint32(98).string(message.summary);
        if (message.proposer !== "") writer.uint32(106).string(message.proposer);
        if (message.expedited === true) writer.uint32(112).bool(message.expedited);
        if (message.failedReason !== "") writer.uint32(122).string(message.failedReason);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.metadata = reader.string();
                    break;
                case 11:
                    message.title = reader.string();
                    break;
                case 12:
                    message.summary = reader.string();
                    break;
                case 13:
                    message.proposer = reader.string();
                    break;
                case 14:
                    message.expedited = reader.bool();
                    break;
                case 15:
                    message.failedReason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id)) obj.id = BigInt(object.id.toString());
        if (Array.isArray(object?.messages)) obj.messages = object.messages.map((e)=>any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.status)) obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult)) obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime)) obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime)) obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object?.totalDeposit)) obj.totalDeposit = object.totalDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime)) obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime)) obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary)) obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.proposer)) obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.expedited)) obj.expedited = Boolean(object.expedited);
        if ((0, helpers_1.isSet)(object.failedReason)) obj.failedReason = String(object.failedReason);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || BigInt(0)).toString());
        if (message.messages) obj.messages = message.messages.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.messages = [];
        message.status !== undefined && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== undefined && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : undefined);
        message.submitTime !== undefined && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== undefined && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) obj.totalDeposit = message.totalDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.totalDeposit = [];
        message.votingStartTime !== undefined && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== undefined && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.title !== undefined && (obj.title = message.title);
        message.summary !== undefined && (obj.summary = message.summary);
        message.proposer !== undefined && (obj.proposer = message.proposer);
        message.expedited !== undefined && (obj.expedited = message.expedited);
        message.failedReason !== undefined && (obj.failedReason = message.failedReason);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProposal();
        if (object.id !== undefined && object.id !== null) message.id = BigInt(object.id.toString());
        message.messages = object.messages?.map((e)=>any_1.Any.fromPartial(e)) || [];
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== undefined && object.finalTallyResult !== null) message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        if (object.submitTime !== undefined && object.submitTime !== null) message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        if (object.depositEndTime !== undefined && object.depositEndTime !== null) message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        message.totalDeposit = object.totalDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.votingStartTime !== undefined && object.votingStartTime !== null) message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        if (object.votingEndTime !== undefined && object.votingEndTime !== null) message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.proposer = object.proposer ?? "";
        message.expedited = object.expedited ?? false;
        message.failedReason = object.failedReason ?? "";
        return message;
    }
};
function createBaseTallyResult() {
    return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
    };
}
exports.TallyResult = {
    typeUrl: "/cosmos.gov.v1.TallyResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") writer.uint32(10).string(message.yesCount);
        if (message.abstainCount !== "") writer.uint32(18).string(message.abstainCount);
        if (message.noCount !== "") writer.uint32(26).string(message.noCount);
        if (message.noWithVetoCount !== "") writer.uint32(34).string(message.noWithVetoCount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.yesCount = reader.string();
                    break;
                case 2:
                    message.abstainCount = reader.string();
                    break;
                case 3:
                    message.noCount = reader.string();
                    break;
                case 4:
                    message.noWithVetoCount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount)) obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount)) obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount)) obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount)) obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.yesCount !== undefined && (obj.yesCount = message.yesCount);
        message.abstainCount !== undefined && (obj.abstainCount = message.abstainCount);
        message.noCount !== undefined && (obj.noCount = message.noCount);
        message.noWithVetoCount !== undefined && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
    }
};
function createBaseVote() {
    return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
    };
}
exports.Vote = {
    typeUrl: "/cosmos.gov.v1.Vote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        for (const v of message.options)exports.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        if (message.metadata !== "") writer.uint32(42).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 4:
                    message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if (Array.isArray(object?.options)) obj.options = object.options.map((e)=>exports.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        if (message.options) obj.options = message.options.map((e)=>e ? exports.WeightedVoteOption.toJSON(e) : undefined);
        else obj.options = [];
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVote();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e)=>exports.WeightedVoteOption.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseDepositParams() {
    return {
        minDeposit: [],
        maxDepositPeriod: undefined
    };
}
exports.DepositParams = {
    typeUrl: "/cosmos.gov.v1.DepositParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.maxDepositPeriod !== undefined) duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object?.minDeposit)) obj.minDeposit = object.minDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod)) obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.minDeposit) obj.minDeposit = message.minDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.minDeposit = [];
        message.maxDepositPeriod !== undefined && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDepositParams();
        message.minDeposit = object.minDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null) message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        return message;
    }
};
function createBaseVotingParams() {
    return {
        votingPeriod: undefined
    };
}
exports.VotingParams = {
    typeUrl: "/cosmos.gov.v1.VotingParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== undefined) duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod)) obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.votingPeriod !== undefined && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== undefined && object.votingPeriod !== null) message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        return message;
    }
};
function createBaseTallyParams() {
    return {
        quorum: "",
        threshold: "",
        vetoThreshold: ""
    };
}
exports.TallyParams = {
    typeUrl: "/cosmos.gov.v1.TallyParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum !== "") writer.uint32(10).string(message.quorum);
        if (message.threshold !== "") writer.uint32(18).string(message.threshold);
        if (message.vetoThreshold !== "") writer.uint32(26).string(message.vetoThreshold);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.quorum = reader.string();
                    break;
                case 2:
                    message.threshold = reader.string();
                    break;
                case 3:
                    message.vetoThreshold = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum)) obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold)) obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold)) obj.vetoThreshold = String(object.vetoThreshold);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.quorum !== undefined && (obj.quorum = message.quorum);
        message.threshold !== undefined && (obj.threshold = message.threshold);
        message.vetoThreshold !== undefined && (obj.vetoThreshold = message.vetoThreshold);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        return message;
    }
};
function createBaseParams() {
    return {
        minDeposit: [],
        maxDepositPeriod: undefined,
        votingPeriod: undefined,
        quorum: "",
        threshold: "",
        vetoThreshold: "",
        minInitialDepositRatio: "",
        proposalCancelRatio: "",
        proposalCancelDest: "",
        expeditedVotingPeriod: undefined,
        expeditedThreshold: "",
        expeditedMinDeposit: [],
        burnVoteQuorum: false,
        burnProposalDepositPrevote: false,
        burnVoteVeto: false,
        minDepositRatio: ""
    };
}
exports.Params = {
    typeUrl: "/cosmos.gov.v1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit)coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.maxDepositPeriod !== undefined) duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        if (message.votingPeriod !== undefined) duration_1.Duration.encode(message.votingPeriod, writer.uint32(26).fork()).ldelim();
        if (message.quorum !== "") writer.uint32(34).string(message.quorum);
        if (message.threshold !== "") writer.uint32(42).string(message.threshold);
        if (message.vetoThreshold !== "") writer.uint32(50).string(message.vetoThreshold);
        if (message.minInitialDepositRatio !== "") writer.uint32(58).string(message.minInitialDepositRatio);
        if (message.proposalCancelRatio !== "") writer.uint32(66).string(message.proposalCancelRatio);
        if (message.proposalCancelDest !== "") writer.uint32(74).string(message.proposalCancelDest);
        if (message.expeditedVotingPeriod !== undefined) duration_1.Duration.encode(message.expeditedVotingPeriod, writer.uint32(82).fork()).ldelim();
        if (message.expeditedThreshold !== "") writer.uint32(90).string(message.expeditedThreshold);
        for (const v of message.expeditedMinDeposit)coin_1.Coin.encode(v, writer.uint32(98).fork()).ldelim();
        if (message.burnVoteQuorum === true) writer.uint32(104).bool(message.burnVoteQuorum);
        if (message.burnProposalDepositPrevote === true) writer.uint32(112).bool(message.burnProposalDepositPrevote);
        if (message.burnVoteVeto === true) writer.uint32(120).bool(message.burnVoteVeto);
        if (message.minDepositRatio !== "") writer.uint32(130).string(message.minDepositRatio);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.quorum = reader.string();
                    break;
                case 5:
                    message.threshold = reader.string();
                    break;
                case 6:
                    message.vetoThreshold = reader.string();
                    break;
                case 7:
                    message.minInitialDepositRatio = reader.string();
                    break;
                case 8:
                    message.proposalCancelRatio = reader.string();
                    break;
                case 9:
                    message.proposalCancelDest = reader.string();
                    break;
                case 10:
                    message.expeditedVotingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.expeditedThreshold = reader.string();
                    break;
                case 12:
                    message.expeditedMinDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.burnVoteQuorum = reader.bool();
                    break;
                case 14:
                    message.burnProposalDepositPrevote = reader.bool();
                    break;
                case 15:
                    message.burnVoteVeto = reader.bool();
                    break;
                case 16:
                    message.minDepositRatio = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if (Array.isArray(object?.minDeposit)) obj.minDeposit = object.minDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod)) obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        if ((0, helpers_1.isSet)(object.votingPeriod)) obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.quorum)) obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold)) obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold)) obj.vetoThreshold = String(object.vetoThreshold);
        if ((0, helpers_1.isSet)(object.minInitialDepositRatio)) obj.minInitialDepositRatio = String(object.minInitialDepositRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelRatio)) obj.proposalCancelRatio = String(object.proposalCancelRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelDest)) obj.proposalCancelDest = String(object.proposalCancelDest);
        if ((0, helpers_1.isSet)(object.expeditedVotingPeriod)) obj.expeditedVotingPeriod = duration_1.Duration.fromJSON(object.expeditedVotingPeriod);
        if ((0, helpers_1.isSet)(object.expeditedThreshold)) obj.expeditedThreshold = String(object.expeditedThreshold);
        if (Array.isArray(object?.expeditedMinDeposit)) obj.expeditedMinDeposit = object.expeditedMinDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.burnVoteQuorum)) obj.burnVoteQuorum = Boolean(object.burnVoteQuorum);
        if ((0, helpers_1.isSet)(object.burnProposalDepositPrevote)) obj.burnProposalDepositPrevote = Boolean(object.burnProposalDepositPrevote);
        if ((0, helpers_1.isSet)(object.burnVoteVeto)) obj.burnVoteVeto = Boolean(object.burnVoteVeto);
        if ((0, helpers_1.isSet)(object.minDepositRatio)) obj.minDepositRatio = String(object.minDepositRatio);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.minDeposit) obj.minDeposit = message.minDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.minDeposit = [];
        message.maxDepositPeriod !== undefined && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : undefined);
        message.votingPeriod !== undefined && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : undefined);
        message.quorum !== undefined && (obj.quorum = message.quorum);
        message.threshold !== undefined && (obj.threshold = message.threshold);
        message.vetoThreshold !== undefined && (obj.vetoThreshold = message.vetoThreshold);
        message.minInitialDepositRatio !== undefined && (obj.minInitialDepositRatio = message.minInitialDepositRatio);
        message.proposalCancelRatio !== undefined && (obj.proposalCancelRatio = message.proposalCancelRatio);
        message.proposalCancelDest !== undefined && (obj.proposalCancelDest = message.proposalCancelDest);
        message.expeditedVotingPeriod !== undefined && (obj.expeditedVotingPeriod = message.expeditedVotingPeriod ? duration_1.Duration.toJSON(message.expeditedVotingPeriod) : undefined);
        message.expeditedThreshold !== undefined && (obj.expeditedThreshold = message.expeditedThreshold);
        if (message.expeditedMinDeposit) obj.expeditedMinDeposit = message.expeditedMinDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.expeditedMinDeposit = [];
        message.burnVoteQuorum !== undefined && (obj.burnVoteQuorum = message.burnVoteQuorum);
        message.burnProposalDepositPrevote !== undefined && (obj.burnProposalDepositPrevote = message.burnProposalDepositPrevote);
        message.burnVoteVeto !== undefined && (obj.burnVoteVeto = message.burnVoteVeto);
        message.minDepositRatio !== undefined && (obj.minDepositRatio = message.minDepositRatio);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.minDeposit = object.minDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null) message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        if (object.votingPeriod !== undefined && object.votingPeriod !== null) message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        message.minInitialDepositRatio = object.minInitialDepositRatio ?? "";
        message.proposalCancelRatio = object.proposalCancelRatio ?? "";
        message.proposalCancelDest = object.proposalCancelDest ?? "";
        if (object.expeditedVotingPeriod !== undefined && object.expeditedVotingPeriod !== null) message.expeditedVotingPeriod = duration_1.Duration.fromPartial(object.expeditedVotingPeriod);
        message.expeditedThreshold = object.expeditedThreshold ?? "";
        message.expeditedMinDeposit = object.expeditedMinDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.burnVoteQuorum = object.burnVoteQuorum ?? false;
        message.burnProposalDepositPrevote = object.burnProposalDepositPrevote ?? false;
        message.burnVoteVeto = object.burnVoteVeto ?? false;
        message.minDepositRatio = object.minDepositRatio ?? "";
        return message;
    }
};

},{"eb37139fdfab40b5":"1ymyZ","8d2974a27160c820":"56aJC","82bef03f04881240":"6J6bq","9fb7e70b9b4473f6":"clU50","3ddb24e76c5dad1e":"bi36x","decc70e97c66250f":"eYjRL"}],"jUy9K":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("daf3f4769d78f41");
const coin_1 = require("468b118a32a80a3b");
const gov_1 = require("3c7c77174ae25025");
const binary_1 = require("65bac1c8ba05a1a9");
const helpers_1 = require("40e3e6f050cf2ba7");
exports.protobufPackage = "cosmos.gov.v1beta1";
function createBaseMsgSubmitProposal() {
    return {
        content: undefined,
        initialDeposit: [],
        proposer: ""
    };
}
exports.MsgSubmitProposal = {
    typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== undefined) any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        for (const v of message.initialDeposit)coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.proposer !== "") writer.uint32(26).string(message.proposer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.content = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.proposer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.content)) obj.content = any_1.Any.fromJSON(object.content);
        if (Array.isArray(object?.initialDeposit)) obj.initialDeposit = object.initialDeposit.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer)) obj.proposer = String(object.proposer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.content !== undefined && (obj.content = message.content ? any_1.Any.toJSON(message.content) : undefined);
        if (message.initialDeposit) obj.initialDeposit = message.initialDeposit.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.initialDeposit = [];
        message.proposer !== undefined && (obj.proposer = message.proposer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitProposal();
        if (object.content !== undefined && object.content !== null) message.content = any_1.Any.fromPartial(object.content);
        message.initialDeposit = object.initialDeposit?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        return message;
    }
};
function createBaseMsgSubmitProposalResponse() {
    return {
        proposalId: BigInt(0)
    };
}
exports.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        return message;
    }
};
function createBaseMsgVote() {
    return {
        proposalId: BigInt(0),
        voter: "",
        option: 0
    };
}
exports.MsgVote = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        if (message.option !== 0) writer.uint32(24).int32(message.option);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.option = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option)) obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        message.option !== undefined && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        return message;
    }
};
function createBaseMsgVoteResponse() {
    return {};
}
exports.MsgVoteResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgVoteResponse();
        return message;
    }
};
function createBaseMsgVoteWeighted() {
    return {
        proposalId: BigInt(0),
        voter: "",
        options: []
    };
}
exports.MsgVoteWeighted = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        for (const v of message.options)gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if (Array.isArray(object?.options)) obj.options = object.options.map((e)=>gov_1.WeightedVoteOption.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        if (message.options) obj.options = message.options.map((e)=>e ? gov_1.WeightedVoteOption.toJSON(e) : undefined);
        else obj.options = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e)=>gov_1.WeightedVoteOption.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgVoteWeightedResponse() {
    return {};
}
exports.MsgVoteWeightedResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
    }
};
function createBaseMsgDeposit() {
    return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
    };
}
exports.MsgDeposit = {
    typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.depositor !== "") writer.uint32(18).string(message.depositor);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.depositor = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== undefined && (obj.depositor = message.depositor);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgDeposit();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgDepositResponse() {
    return {};
}
exports.MsgDepositResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgDepositResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgDepositResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
    }
    SubmitProposal(request) {
        const data = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data);
        return promise.then((data)=>exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data)));
    }
    Vote(request) {
        const data = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data);
        return promise.then((data)=>exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data)));
    }
    VoteWeighted(request) {
        const data = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data);
        return promise.then((data)=>exports.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data)));
    }
    Deposit(request) {
        const data = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data);
        return promise.then((data)=>exports.MsgDepositResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"daf3f4769d78f41":"56aJC","468b118a32a80a3b":"1ymyZ","3c7c77174ae25025":"fjQm7","65bac1c8ba05a1a9":"bi36x","40e3e6f050cf2ba7":"eYjRL"}],"aKHGD":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupGovExtension = setupGovExtension;
const query_1 = require("347965eb7a085802");
const queryclient_1 = require("81da500a6bbd4965");
function setupGovExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        gov: {
            params: async (parametersType)=>{
                const response = await queryService.Params({
                    paramsType: parametersType
                });
                return response;
            },
            proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey)=>{
                const response = await queryService.Proposals({
                    proposalStatus,
                    depositor: depositorAddress,
                    voter: voterAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            proposal: async (proposalId)=>{
                const response = await queryService.Proposal({
                    proposalId: (0, queryclient_1.longify)(proposalId)
                });
                return response;
            },
            deposits: async (proposalId, paginationKey)=>{
                const response = await queryService.Deposits({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            deposit: async (proposalId, depositorAddress)=>{
                const response = await queryService.Deposit({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    depositor: depositorAddress
                });
                return response;
            },
            tally: async (proposalId)=>{
                const response = await queryService.TallyResult({
                    proposalId: (0, queryclient_1.longify)(proposalId)
                });
                return response;
            },
            votes: async (proposalId, paginationKey)=>{
                const response = await queryService.Votes({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            vote: async (proposalId, voterAddress)=>{
                const response = await queryService.Vote({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    voter: voterAddress
                });
                return response;
            }
        }
    };
}

},{"347965eb7a085802":"8Pn9i","81da500a6bbd4965":"cM4fi"}],"8Pn9i":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryTallyResultResponse = exports.QueryTallyResultRequest = exports.QueryDepositsResponse = exports.QueryDepositsRequest = exports.QueryDepositResponse = exports.QueryDepositRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryVotesResponse = exports.QueryVotesRequest = exports.QueryVoteResponse = exports.QueryVoteRequest = exports.QueryProposalsResponse = exports.QueryProposalsRequest = exports.QueryProposalResponse = exports.QueryProposalRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const gov_1 = require("87f83f6a352c97f");
const pagination_1 = require("de1959f134ca5eb3");
const binary_1 = require("d1e6778bf79381d6");
const helpers_1 = require("3be52235d1f4c40c");
exports.protobufPackage = "cosmos.gov.v1beta1";
function createBaseQueryProposalRequest() {
    return {
        proposalId: BigInt(0)
    };
}
exports.QueryProposalRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryProposalRequest();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryProposalRequest();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        return message;
    }
};
function createBaseQueryProposalResponse() {
    return {
        proposal: gov_1.Proposal.fromPartial({})
    };
}
exports.QueryProposalResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposal !== undefined) gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryProposalResponse();
        if ((0, helpers_1.isSet)(object.proposal)) obj.proposal = gov_1.Proposal.fromJSON(object.proposal);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposal !== undefined && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryProposalResponse();
        if (object.proposal !== undefined && object.proposal !== null) message.proposal = gov_1.Proposal.fromPartial(object.proposal);
        return message;
    }
};
function createBaseQueryProposalsRequest() {
    return {
        proposalStatus: 0,
        voter: "",
        depositor: "",
        pagination: undefined
    };
}
exports.QueryProposalsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalStatus !== 0) writer.uint32(8).int32(message.proposalStatus);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        if (message.depositor !== "") writer.uint32(26).string(message.depositor);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalStatus = reader.int32();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.depositor = reader.string();
                    break;
                case 4:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryProposalsRequest();
        if ((0, helpers_1.isSet)(object.proposalStatus)) obj.proposalStatus = (0, gov_1.proposalStatusFromJSON)(object.proposalStatus);
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalStatus !== undefined && (obj.proposalStatus = (0, gov_1.proposalStatusToJSON)(message.proposalStatus));
        message.voter !== undefined && (obj.voter = message.voter);
        message.depositor !== undefined && (obj.depositor = message.depositor);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryProposalsRequest();
        message.proposalStatus = object.proposalStatus ?? 0;
        message.voter = object.voter ?? "";
        message.depositor = object.depositor ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryProposalsResponse() {
    return {
        proposals: [],
        pagination: undefined
    };
}
exports.QueryProposalsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proposals)gov_1.Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryProposalsResponse();
        if (Array.isArray(object?.proposals)) obj.proposals = object.proposals.map((e)=>gov_1.Proposal.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.proposals) obj.proposals = message.proposals.map((e)=>e ? gov_1.Proposal.toJSON(e) : undefined);
        else obj.proposals = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryProposalsResponse();
        message.proposals = object.proposals?.map((e)=>gov_1.Proposal.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryVoteRequest() {
    return {
        proposalId: BigInt(0),
        voter: ""
    };
}
exports.QueryVoteRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryVoteRequest();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryVoteRequest();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        return message;
    }
};
function createBaseQueryVoteResponse() {
    return {
        vote: gov_1.Vote.fromPartial({})
    };
}
exports.QueryVoteResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.vote !== undefined) gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.vote = gov_1.Vote.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryVoteResponse();
        if ((0, helpers_1.isSet)(object.vote)) obj.vote = gov_1.Vote.fromJSON(object.vote);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.vote !== undefined && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryVoteResponse();
        if (object.vote !== undefined && object.vote !== null) message.vote = gov_1.Vote.fromPartial(object.vote);
        return message;
    }
};
function createBaseQueryVotesRequest() {
    return {
        proposalId: BigInt(0),
        pagination: undefined
    };
}
exports.QueryVotesRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryVotesRequest();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryVotesRequest();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryVotesResponse() {
    return {
        votes: [],
        pagination: undefined
    };
}
exports.QueryVotesResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.votes)gov_1.Vote.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryVotesResponse();
        if (Array.isArray(object?.votes)) obj.votes = object.votes.map((e)=>gov_1.Vote.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.votes) obj.votes = message.votes.map((e)=>e ? gov_1.Vote.toJSON(e) : undefined);
        else obj.votes = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryVotesResponse();
        message.votes = object.votes?.map((e)=>gov_1.Vote.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryParamsRequest() {
    return {
        paramsType: ""
    };
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.paramsType !== "") writer.uint32(10).string(message.paramsType);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.paramsType = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsRequest();
        if ((0, helpers_1.isSet)(object.paramsType)) obj.paramsType = String(object.paramsType);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.paramsType !== undefined && (obj.paramsType = message.paramsType);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsRequest();
        message.paramsType = object.paramsType ?? "";
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        votingParams: gov_1.VotingParams.fromPartial({}),
        depositParams: gov_1.DepositParams.fromPartial({}),
        tallyParams: gov_1.TallyParams.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingParams !== undefined) gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        if (message.depositParams !== undefined) gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        if (message.tallyParams !== undefined) gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.votingParams)) obj.votingParams = gov_1.VotingParams.fromJSON(object.votingParams);
        if ((0, helpers_1.isSet)(object.depositParams)) obj.depositParams = gov_1.DepositParams.fromJSON(object.depositParams);
        if ((0, helpers_1.isSet)(object.tallyParams)) obj.tallyParams = gov_1.TallyParams.fromJSON(object.tallyParams);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.votingParams !== undefined && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : undefined);
        message.depositParams !== undefined && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : undefined);
        message.tallyParams !== undefined && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.votingParams !== undefined && object.votingParams !== null) message.votingParams = gov_1.VotingParams.fromPartial(object.votingParams);
        if (object.depositParams !== undefined && object.depositParams !== null) message.depositParams = gov_1.DepositParams.fromPartial(object.depositParams);
        if (object.tallyParams !== undefined && object.tallyParams !== null) message.tallyParams = gov_1.TallyParams.fromPartial(object.tallyParams);
        return message;
    }
};
function createBaseQueryDepositRequest() {
    return {
        proposalId: BigInt(0),
        depositor: ""
    };
}
exports.QueryDepositRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.depositor !== "") writer.uint32(18).string(message.depositor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.depositor = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDepositRequest();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor)) obj.depositor = String(object.depositor);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== undefined && (obj.depositor = message.depositor);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDepositRequest();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.depositor = object.depositor ?? "";
        return message;
    }
};
function createBaseQueryDepositResponse() {
    return {
        deposit: gov_1.Deposit.fromPartial({})
    };
}
exports.QueryDepositResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.deposit !== undefined) gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDepositResponse();
        if ((0, helpers_1.isSet)(object.deposit)) obj.deposit = gov_1.Deposit.fromJSON(object.deposit);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.deposit !== undefined && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDepositResponse();
        if (object.deposit !== undefined && object.deposit !== null) message.deposit = gov_1.Deposit.fromPartial(object.deposit);
        return message;
    }
};
function createBaseQueryDepositsRequest() {
    return {
        proposalId: BigInt(0),
        pagination: undefined
    };
}
exports.QueryDepositsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDepositsRequest();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDepositsRequest();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDepositsResponse() {
    return {
        deposits: [],
        pagination: undefined
    };
}
exports.QueryDepositsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.deposits)gov_1.Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDepositsResponse();
        if (Array.isArray(object?.deposits)) obj.deposits = object.deposits.map((e)=>gov_1.Deposit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.deposits) obj.deposits = message.deposits.map((e)=>e ? gov_1.Deposit.toJSON(e) : undefined);
        else obj.deposits = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDepositsResponse();
        message.deposits = object.deposits?.map((e)=>gov_1.Deposit.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryTallyResultRequest() {
    return {
        proposalId: BigInt(0)
    };
}
exports.QueryTallyResultRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryTallyResultRequest();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryTallyResultRequest();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        return message;
    }
};
function createBaseQueryTallyResultResponse() {
    return {
        tally: gov_1.TallyResult.fromPartial({})
    };
}
exports.QueryTallyResultResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.tally !== undefined) gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryTallyResultResponse();
        if ((0, helpers_1.isSet)(object.tally)) obj.tally = gov_1.TallyResult.fromJSON(object.tally);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.tally !== undefined && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryTallyResultResponse();
        if (object.tally !== undefined && object.tally !== null) message.tally = gov_1.TallyResult.fromPartial(object.tally);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
    }
    Proposal(request) {
        const data = exports.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data);
        return promise.then((data)=>exports.QueryProposalResponse.decode(new binary_1.BinaryReader(data)));
    }
    Proposals(request) {
        const data = exports.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data);
        return promise.then((data)=>exports.QueryProposalsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Vote(request) {
        const data = exports.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data);
        return promise.then((data)=>exports.QueryVoteResponse.decode(new binary_1.BinaryReader(data)));
    }
    Votes(request) {
        const data = exports.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data);
        return promise.then((data)=>exports.QueryVotesResponse.decode(new binary_1.BinaryReader(data)));
    }
    Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Deposit(request) {
        const data = exports.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data);
        return promise.then((data)=>exports.QueryDepositResponse.decode(new binary_1.BinaryReader(data)));
    }
    Deposits(request) {
        const data = exports.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data);
        return promise.then((data)=>exports.QueryDepositsResponse.decode(new binary_1.BinaryReader(data)));
    }
    TallyResult(request) {
        const data = exports.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data);
        return promise.then((data)=>exports.QueryTallyResultResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"87f83f6a352c97f":"fjQm7","de1959f134ca5eb3":"43d5n","d1e6778bf79381d6":"bi36x","3be52235d1f4c40c":"eYjRL"}],"l037H":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createGroupAminoConverters = createGroupAminoConverters;
function createGroupAminoConverters() {
    // Missing, see https://github.com/cosmos/cosmjs/issues/1441
    return {};
}

},{}],"ckWmw":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.groupTypes = void 0;
const tx_1 = require("9338fe50bc32b099");
exports.groupTypes = [
    [
        "/cosmos.group.v1.MsgCreateGroup",
        tx_1.MsgCreateGroup
    ],
    [
        "/cosmos.group.v1.MsgCreateGroupPolicy",
        tx_1.MsgCreateGroupPolicy
    ],
    [
        "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        tx_1.MsgCreateGroupWithPolicy
    ],
    [
        "/cosmos.group.v1.MsgExec",
        tx_1.MsgExec
    ],
    [
        "/cosmos.group.v1.MsgLeaveGroup",
        tx_1.MsgLeaveGroup
    ],
    [
        "/cosmos.group.v1.MsgSubmitProposal",
        tx_1.MsgSubmitProposal
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupAdmin",
        tx_1.MsgUpdateGroupAdmin
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupMembers",
        tx_1.MsgUpdateGroupMembers
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupMetadata",
        tx_1.MsgUpdateGroupMetadata
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        tx_1.MsgUpdateGroupPolicyAdmin
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        tx_1.MsgUpdateGroupPolicyDecisionPolicy
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        tx_1.MsgUpdateGroupPolicyMetadata
    ],
    [
        "/cosmos.group.v1.MsgVote",
        tx_1.MsgVote
    ],
    [
        "/cosmos.group.v1.MsgWithdrawProposal",
        tx_1.MsgWithdrawProposal
    ]
]; // There are no EncodeObject implementations for the new v1 message types because
 // those things don't scale (https://github.com/cosmos/cosmjs/issues/1440). We need to
 // address this more fundamentally. Users can use
 // const msg = {
 //   typeUrl: "/cosmos.group.v1.MsgCreateGroup",
 //   value: MsgCreateGroup.fromPartial({ ... })
 // }
 // in their app.

},{"9338fe50bc32b099":"8holL"}],"8holL":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgLeaveGroupResponse = exports.MsgLeaveGroup = exports.MsgExecResponse = exports.MsgExec = exports.MsgVoteResponse = exports.MsgVote = exports.MsgWithdrawProposalResponse = exports.MsgWithdrawProposal = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.MsgUpdateGroupPolicyMetadataResponse = exports.MsgUpdateGroupPolicyMetadata = exports.MsgUpdateGroupPolicyDecisionPolicyResponse = exports.MsgUpdateGroupPolicyDecisionPolicy = exports.MsgCreateGroupWithPolicyResponse = exports.MsgCreateGroupWithPolicy = exports.MsgUpdateGroupPolicyAdminResponse = exports.MsgUpdateGroupPolicyAdmin = exports.MsgCreateGroupPolicyResponse = exports.MsgCreateGroupPolicy = exports.MsgUpdateGroupMetadataResponse = exports.MsgUpdateGroupMetadata = exports.MsgUpdateGroupAdminResponse = exports.MsgUpdateGroupAdmin = exports.MsgUpdateGroupMembersResponse = exports.MsgUpdateGroupMembers = exports.MsgCreateGroupResponse = exports.MsgCreateGroup = exports.execToJSON = exports.execFromJSON = exports.Exec = exports.protobufPackage = void 0;
/* eslint-disable */ const types_1 = require("dadc4e9f1a77acf8");
const any_1 = require("1ca3b0a3f57387ca");
const binary_1 = require("d6b547d5c78210dc");
const helpers_1 = require("c69dfa99f7485ad8");
exports.protobufPackage = "cosmos.group.v1";
/** Exec defines modes of execution of a proposal on creation or on new vote. */ var Exec;
(function(Exec) {
    /**
     * EXEC_UNSPECIFIED - An empty value means that there should be a separate
     * MsgExec request for the proposal to execute.
     */ Exec[Exec["EXEC_UNSPECIFIED"] = 0] = "EXEC_UNSPECIFIED";
    /**
     * EXEC_TRY - Try to execute the proposal immediately.
     * If the proposal is not allowed per the DecisionPolicy,
     * the proposal will still be open and could
     * be executed at a later point.
     */ Exec[Exec["EXEC_TRY"] = 1] = "EXEC_TRY";
    Exec[Exec["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Exec || (exports.Exec = Exec = {}));
function execFromJSON(object) {
    switch(object){
        case 0:
        case "EXEC_UNSPECIFIED":
            return Exec.EXEC_UNSPECIFIED;
        case 1:
        case "EXEC_TRY":
            return Exec.EXEC_TRY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Exec.UNRECOGNIZED;
    }
}
exports.execFromJSON = execFromJSON;
function execToJSON(object) {
    switch(object){
        case Exec.EXEC_UNSPECIFIED:
            return "EXEC_UNSPECIFIED";
        case Exec.EXEC_TRY:
            return "EXEC_TRY";
        case Exec.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.execToJSON = execToJSON;
function createBaseMsgCreateGroup() {
    return {
        admin: "",
        members: [],
        metadata: ""
    };
}
exports.MsgCreateGroup = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroup",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        for (const v of message.members)types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroup();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateGroup();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if (Array.isArray(object?.members)) obj.members = object.members.map((e)=>types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        if (message.members) obj.members = message.members.map((e)=>e ? types_1.MemberRequest.toJSON(e) : undefined);
        else obj.members = [];
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateGroup();
        message.admin = object.admin ?? "";
        message.members = object.members?.map((e)=>types_1.MemberRequest.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseMsgCreateGroupResponse() {
    return {
        groupId: BigInt(0)
    };
}
exports.MsgCreateGroupResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) writer.uint32(8).uint64(message.groupId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateGroupResponse();
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateGroupResponse();
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        return message;
    }
};
function createBaseMsgUpdateGroupMembers() {
    return {
        admin: "",
        groupId: BigInt(0),
        memberUpdates: []
    };
}
exports.MsgUpdateGroupMembers = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupId !== BigInt(0)) writer.uint32(16).uint64(message.groupId);
        for (const v of message.memberUpdates)types_1.MemberRequest.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembers();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupId = reader.uint64();
                    break;
                case 3:
                    message.memberUpdates.push(types_1.MemberRequest.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateGroupMembers();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if (Array.isArray(object?.memberUpdates)) obj.memberUpdates = object.memberUpdates.map((e)=>types_1.MemberRequest.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        if (message.memberUpdates) obj.memberUpdates = message.memberUpdates.map((e)=>e ? types_1.MemberRequest.toJSON(e) : undefined);
        else obj.memberUpdates = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateGroupMembers();
        message.admin = object.admin ?? "";
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        message.memberUpdates = object.memberUpdates?.map((e)=>types_1.MemberRequest.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgUpdateGroupMembersResponse() {
    return {};
}
exports.MsgUpdateGroupMembersResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembersResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateGroupMembersResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateGroupMembersResponse();
        return message;
    }
};
function createBaseMsgUpdateGroupAdmin() {
    return {
        admin: "",
        groupId: BigInt(0),
        newAdmin: ""
    };
}
exports.MsgUpdateGroupAdmin = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupId !== BigInt(0)) writer.uint32(16).uint64(message.groupId);
        if (message.newAdmin !== "") writer.uint32(26).string(message.newAdmin);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdmin();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupId = reader.uint64();
                    break;
                case 3:
                    message.newAdmin = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateGroupAdmin();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.newAdmin)) obj.newAdmin = String(object.newAdmin);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateGroupAdmin();
        message.admin = object.admin ?? "";
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        message.newAdmin = object.newAdmin ?? "";
        return message;
    }
};
function createBaseMsgUpdateGroupAdminResponse() {
    return {};
}
exports.MsgUpdateGroupAdminResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdminResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateGroupAdminResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateGroupAdminResponse();
        return message;
    }
};
function createBaseMsgUpdateGroupMetadata() {
    return {
        admin: "",
        groupId: BigInt(0),
        metadata: ""
    };
}
exports.MsgUpdateGroupMetadata = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupId !== BigInt(0)) writer.uint32(16).uint64(message.groupId);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadata();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupId = reader.uint64();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateGroupMetadata();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateGroupMetadata();
        message.admin = object.admin ?? "";
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseMsgUpdateGroupMetadataResponse() {
    return {};
}
exports.MsgUpdateGroupMetadataResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadataResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateGroupMetadataResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateGroupMetadataResponse();
        return message;
    }
};
function createBaseMsgCreateGroupPolicy() {
    return {
        admin: "",
        groupId: BigInt(0),
        metadata: "",
        decisionPolicy: undefined
    };
}
exports.MsgCreateGroupPolicy = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupId !== BigInt(0)) writer.uint32(16).uint64(message.groupId);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        if (message.decisionPolicy !== undefined) any_1.Any.encode(message.decisionPolicy, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicy();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupId = reader.uint64();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateGroupPolicy();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.decisionPolicy)) obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.decisionPolicy !== undefined && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateGroupPolicy();
        message.admin = object.admin ?? "";
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        message.metadata = object.metadata ?? "";
        if (object.decisionPolicy !== undefined && object.decisionPolicy !== null) message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        return message;
    }
};
function createBaseMsgCreateGroupPolicyResponse() {
    return {
        address: ""
    };
}
exports.MsgCreateGroupPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicyResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateGroupPolicyResponse();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateGroupPolicyResponse();
        message.address = object.address ?? "";
        return message;
    }
};
function createBaseMsgUpdateGroupPolicyAdmin() {
    return {
        admin: "",
        groupPolicyAddress: "",
        newAdmin: ""
    };
}
exports.MsgUpdateGroupPolicyAdmin = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupPolicyAddress !== "") writer.uint32(18).string(message.groupPolicyAddress);
        if (message.newAdmin !== "") writer.uint32(26).string(message.newAdmin);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupPolicyAddress = reader.string();
                    break;
                case 3:
                    message.newAdmin = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateGroupPolicyAdmin();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress)) obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.newAdmin)) obj.newAdmin = String(object.newAdmin);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupPolicyAddress !== undefined && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.newAdmin = object.newAdmin ?? "";
        return message;
    }
};
function createBaseMsgUpdateGroupPolicyAdminResponse() {
    return {};
}
exports.MsgUpdateGroupPolicyAdminResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateGroupPolicyAdminResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        return message;
    }
};
function createBaseMsgCreateGroupWithPolicy() {
    return {
        admin: "",
        members: [],
        groupMetadata: "",
        groupPolicyMetadata: "",
        groupPolicyAsAdmin: false,
        decisionPolicy: undefined
    };
}
exports.MsgCreateGroupWithPolicy = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        for (const v of message.members)types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.groupMetadata !== "") writer.uint32(26).string(message.groupMetadata);
        if (message.groupPolicyMetadata !== "") writer.uint32(34).string(message.groupPolicyMetadata);
        if (message.groupPolicyAsAdmin === true) writer.uint32(40).bool(message.groupPolicyAsAdmin);
        if (message.decisionPolicy !== undefined) any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicy();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.groupMetadata = reader.string();
                    break;
                case 4:
                    message.groupPolicyMetadata = reader.string();
                    break;
                case 5:
                    message.groupPolicyAsAdmin = reader.bool();
                    break;
                case 6:
                    message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateGroupWithPolicy();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if (Array.isArray(object?.members)) obj.members = object.members.map((e)=>types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.groupMetadata)) obj.groupMetadata = String(object.groupMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyMetadata)) obj.groupPolicyMetadata = String(object.groupPolicyMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyAsAdmin)) obj.groupPolicyAsAdmin = Boolean(object.groupPolicyAsAdmin);
        if ((0, helpers_1.isSet)(object.decisionPolicy)) obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        if (message.members) obj.members = message.members.map((e)=>e ? types_1.MemberRequest.toJSON(e) : undefined);
        else obj.members = [];
        message.groupMetadata !== undefined && (obj.groupMetadata = message.groupMetadata);
        message.groupPolicyMetadata !== undefined && (obj.groupPolicyMetadata = message.groupPolicyMetadata);
        message.groupPolicyAsAdmin !== undefined && (obj.groupPolicyAsAdmin = message.groupPolicyAsAdmin);
        message.decisionPolicy !== undefined && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateGroupWithPolicy();
        message.admin = object.admin ?? "";
        message.members = object.members?.map((e)=>types_1.MemberRequest.fromPartial(e)) || [];
        message.groupMetadata = object.groupMetadata ?? "";
        message.groupPolicyMetadata = object.groupPolicyMetadata ?? "";
        message.groupPolicyAsAdmin = object.groupPolicyAsAdmin ?? false;
        if (object.decisionPolicy !== undefined && object.decisionPolicy !== null) message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        return message;
    }
};
function createBaseMsgCreateGroupWithPolicyResponse() {
    return {
        groupId: BigInt(0),
        groupPolicyAddress: ""
    };
}
exports.MsgCreateGroupWithPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) writer.uint32(8).uint64(message.groupId);
        if (message.groupPolicyAddress !== "") writer.uint32(18).string(message.groupPolicyAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupId = reader.uint64();
                    break;
                case 2:
                    message.groupPolicyAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateGroupWithPolicyResponse();
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress)) obj.groupPolicyAddress = String(object.groupPolicyAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.groupPolicyAddress !== undefined && (obj.groupPolicyAddress = message.groupPolicyAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        return message;
    }
};
function createBaseMsgUpdateGroupPolicyDecisionPolicy() {
    return {
        admin: "",
        groupPolicyAddress: "",
        decisionPolicy: undefined
    };
}
exports.MsgUpdateGroupPolicyDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupPolicyAddress !== "") writer.uint32(18).string(message.groupPolicyAddress);
        if (message.decisionPolicy !== undefined) any_1.Any.encode(message.decisionPolicy, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupPolicyAddress = reader.string();
                    break;
                case 3:
                    message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress)) obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.decisionPolicy)) obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupPolicyAddress !== undefined && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.decisionPolicy !== undefined && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        if (object.decisionPolicy !== undefined && object.decisionPolicy !== null) message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        return message;
    }
};
function createBaseMsgUpdateGroupPolicyDecisionPolicyResponse() {
    return {};
}
exports.MsgUpdateGroupPolicyDecisionPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return message;
    }
};
function createBaseMsgUpdateGroupPolicyMetadata() {
    return {
        admin: "",
        groupPolicyAddress: "",
        metadata: ""
    };
}
exports.MsgUpdateGroupPolicyMetadata = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") writer.uint32(10).string(message.admin);
        if (message.groupPolicyAddress !== "") writer.uint32(18).string(message.groupPolicyAddress);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.admin = reader.string();
                    break;
                case 2:
                    message.groupPolicyAddress = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateGroupPolicyMetadata();
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress)) obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.admin !== undefined && (obj.admin = message.admin);
        message.groupPolicyAddress !== undefined && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseMsgUpdateGroupPolicyMetadataResponse() {
    return {};
}
exports.MsgUpdateGroupPolicyMetadataResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return message;
    }
};
function createBaseMsgSubmitProposal() {
    return {
        groupPolicyAddress: "",
        proposers: [],
        metadata: "",
        messages: [],
        exec: 0,
        title: "",
        summary: ""
    };
}
exports.MsgSubmitProposal = {
    typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupPolicyAddress !== "") writer.uint32(10).string(message.groupPolicyAddress);
        for (const v of message.proposers)writer.uint32(18).string(v);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        for (const v of message.messages)any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        if (message.exec !== 0) writer.uint32(40).int32(message.exec);
        if (message.title !== "") writer.uint32(50).string(message.title);
        if (message.summary !== "") writer.uint32(58).string(message.summary);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupPolicyAddress = reader.string();
                    break;
                case 2:
                    message.proposers.push(reader.string());
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.exec = reader.int32();
                    break;
                case 6:
                    message.title = reader.string();
                    break;
                case 7:
                    message.summary = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.groupPolicyAddress)) obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if (Array.isArray(object?.proposers)) obj.proposers = object.proposers.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if (Array.isArray(object?.messages)) obj.messages = object.messages.map((e)=>any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.exec)) obj.exec = execFromJSON(object.exec);
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary)) obj.summary = String(object.summary);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.groupPolicyAddress !== undefined && (obj.groupPolicyAddress = message.groupPolicyAddress);
        if (message.proposers) obj.proposers = message.proposers.map((e)=>e);
        else obj.proposers = [];
        message.metadata !== undefined && (obj.metadata = message.metadata);
        if (message.messages) obj.messages = message.messages.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.messages = [];
        message.exec !== undefined && (obj.exec = execToJSON(message.exec));
        message.title !== undefined && (obj.title = message.title);
        message.summary !== undefined && (obj.summary = message.summary);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitProposal();
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.proposers = object.proposers?.map((e)=>e) || [];
        message.metadata = object.metadata ?? "";
        message.messages = object.messages?.map((e)=>any_1.Any.fromPartial(e)) || [];
        message.exec = object.exec ?? 0;
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
    }
};
function createBaseMsgSubmitProposalResponse() {
    return {
        proposalId: BigInt(0)
    };
}
exports.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        return message;
    }
};
function createBaseMsgWithdrawProposal() {
    return {
        proposalId: BigInt(0),
        address: ""
    };
}
exports.MsgWithdrawProposal = {
    typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.address !== "") writer.uint32(18).string(message.address);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgWithdrawProposal();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgWithdrawProposal();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.address = object.address ?? "";
        return message;
    }
};
function createBaseMsgWithdrawProposalResponse() {
    return {};
}
exports.MsgWithdrawProposalResponse = {
    typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposalResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgWithdrawProposalResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgWithdrawProposalResponse();
        return message;
    }
};
function createBaseMsgVote() {
    return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        exec: 0
    };
}
exports.MsgVote = {
    typeUrl: "/cosmos.group.v1.MsgVote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        if (message.option !== 0) writer.uint32(24).int32(message.option);
        if (message.metadata !== "") writer.uint32(34).string(message.metadata);
        if (message.exec !== 0) writer.uint32(40).int32(message.exec);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.option = reader.int32();
                    break;
                case 4:
                    message.metadata = reader.string();
                    break;
                case 5:
                    message.exec = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option)) obj.option = (0, types_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.exec)) obj.exec = execFromJSON(object.exec);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        message.option !== undefined && (obj.option = (0, types_1.voteOptionToJSON)(message.option));
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.exec !== undefined && (obj.exec = execToJSON(message.exec));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        message.exec = object.exec ?? 0;
        return message;
    }
};
function createBaseMsgVoteResponse() {
    return {};
}
exports.MsgVoteResponse = {
    typeUrl: "/cosmos.group.v1.MsgVoteResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgVoteResponse();
        return message;
    }
};
function createBaseMsgExec() {
    return {
        proposalId: BigInt(0),
        executor: ""
    };
}
exports.MsgExec = {
    typeUrl: "/cosmos.group.v1.MsgExec",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.executor !== "") writer.uint32(18).string(message.executor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.executor = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.executor)) obj.executor = String(object.executor);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.executor !== undefined && (obj.executor = message.executor);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgExec();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.executor = object.executor ?? "";
        return message;
    }
};
function createBaseMsgExecResponse() {
    return {
        result: 0
    };
}
exports.MsgExecResponse = {
    typeUrl: "/cosmos.group.v1.MsgExecResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(16).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 2:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgExecResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = (0, types_1.proposalExecutorResultFromJSON)(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = (0, types_1.proposalExecutorResultToJSON)(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgExecResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgLeaveGroup() {
    return {
        address: "",
        groupId: BigInt(0)
    };
}
exports.MsgLeaveGroup = {
    typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.groupId !== BigInt(0)) writer.uint32(16).uint64(message.groupId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroup();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.groupId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgLeaveGroup();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgLeaveGroup();
        message.address = object.address ?? "";
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        return message;
    }
};
function createBaseMsgLeaveGroupResponse() {
    return {};
}
exports.MsgLeaveGroupResponse = {
    typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroupResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgLeaveGroupResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgLeaveGroupResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.CreateGroup = this.CreateGroup.bind(this);
        this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this);
        this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this);
        this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this);
        this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this);
        this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this);
        this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this);
        this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this);
        this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this);
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.WithdrawProposal = this.WithdrawProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Exec = this.Exec.bind(this);
        this.LeaveGroup = this.LeaveGroup.bind(this);
    }
    CreateGroup(request) {
        const data = exports.MsgCreateGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", data);
        return promise.then((data)=>exports.MsgCreateGroupResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateGroupMembers(request) {
        const data = exports.MsgUpdateGroupMembers.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", data);
        return promise.then((data)=>exports.MsgUpdateGroupMembersResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateGroupAdmin(request) {
        const data = exports.MsgUpdateGroupAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", data);
        return promise.then((data)=>exports.MsgUpdateGroupAdminResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateGroupMetadata(request) {
        const data = exports.MsgUpdateGroupMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", data);
        return promise.then((data)=>exports.MsgUpdateGroupMetadataResponse.decode(new binary_1.BinaryReader(data)));
    }
    CreateGroupPolicy(request) {
        const data = exports.MsgCreateGroupPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", data);
        return promise.then((data)=>exports.MsgCreateGroupPolicyResponse.decode(new binary_1.BinaryReader(data)));
    }
    CreateGroupWithPolicy(request) {
        const data = exports.MsgCreateGroupWithPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", data);
        return promise.then((data)=>exports.MsgCreateGroupWithPolicyResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateGroupPolicyAdmin(request) {
        const data = exports.MsgUpdateGroupPolicyAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", data);
        return promise.then((data)=>exports.MsgUpdateGroupPolicyAdminResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateGroupPolicyDecisionPolicy(request) {
        const data = exports.MsgUpdateGroupPolicyDecisionPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", data);
        return promise.then((data)=>exports.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateGroupPolicyMetadata(request) {
        const data = exports.MsgUpdateGroupPolicyMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", data);
        return promise.then((data)=>exports.MsgUpdateGroupPolicyMetadataResponse.decode(new binary_1.BinaryReader(data)));
    }
    SubmitProposal(request) {
        const data = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", data);
        return promise.then((data)=>exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data)));
    }
    WithdrawProposal(request) {
        const data = exports.MsgWithdrawProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", data);
        return promise.then((data)=>exports.MsgWithdrawProposalResponse.decode(new binary_1.BinaryReader(data)));
    }
    Vote(request) {
        const data = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Vote", data);
        return promise.then((data)=>exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data)));
    }
    Exec(request) {
        const data = exports.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Exec", data);
        return promise.then((data)=>exports.MsgExecResponse.decode(new binary_1.BinaryReader(data)));
    }
    LeaveGroup(request) {
        const data = exports.MsgLeaveGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", data);
        return promise.then((data)=>exports.MsgLeaveGroupResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"dadc4e9f1a77acf8":"dcmPV","1ca3b0a3f57387ca":"56aJC","d6b547d5c78210dc":"bi36x","c69dfa99f7485ad8":"eYjRL"}],"dcmPV":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Vote = exports.TallyResult = exports.Proposal = exports.GroupPolicyInfo = exports.GroupMember = exports.GroupInfo = exports.DecisionPolicyWindows = exports.PercentageDecisionPolicy = exports.ThresholdDecisionPolicy = exports.MemberRequest = exports.Member = exports.proposalExecutorResultToJSON = exports.proposalExecutorResultFromJSON = exports.ProposalExecutorResult = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
/* eslint-disable */ const timestamp_1 = require("1a14fefbc89514a9");
const duration_1 = require("a7e2acf832e28aad");
const any_1 = require("1c00996d04ff3819");
const binary_1 = require("dd5e88a7e6d4065f");
const helpers_1 = require("171ad04ccd1a1bf0");
exports.protobufPackage = "cosmos.group.v1";
/** VoteOption enumerates the valid vote options for a given proposal. */ var VoteOption;
(function(VoteOption) {
    /**
     * VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will
     * return an error.
     */ VoteOption[VoteOption["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
    /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */ VoteOption[VoteOption["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
    /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */ VoteOption[VoteOption["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
    /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */ VoteOption[VoteOption["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
    /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */ VoteOption[VoteOption["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
    VoteOption[VoteOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VoteOption || (exports.VoteOption = VoteOption = {}));
function voteOptionFromJSON(object) {
    switch(object){
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
            return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
            return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
            return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
            return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
            return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VoteOption.UNRECOGNIZED;
    }
}
exports.voteOptionFromJSON = voteOptionFromJSON;
function voteOptionToJSON(object) {
    switch(object){
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
            return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
            return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
            return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
            return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
            return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.voteOptionToJSON = voteOptionToJSON;
/** ProposalStatus defines proposal statuses. */ var ProposalStatus;
(function(ProposalStatus) {
    /** PROPOSAL_STATUS_UNSPECIFIED - An empty value is invalid and not allowed. */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
    /** PROPOSAL_STATUS_SUBMITTED - Initial status of a proposal when submitted. */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_SUBMITTED"] = 1] = "PROPOSAL_STATUS_SUBMITTED";
    /**
     * PROPOSAL_STATUS_ACCEPTED - Final status of a proposal when the final tally is done and the outcome
     * passes the group policy's decision policy.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_ACCEPTED"] = 2] = "PROPOSAL_STATUS_ACCEPTED";
    /**
     * PROPOSAL_STATUS_REJECTED - Final status of a proposal when the final tally is done and the outcome
     * is rejected by the group policy's decision policy.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_REJECTED"] = 3] = "PROPOSAL_STATUS_REJECTED";
    /**
     * PROPOSAL_STATUS_ABORTED - Final status of a proposal when the group policy is modified before the
     * final tally.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_ABORTED"] = 4] = "PROPOSAL_STATUS_ABORTED";
    /**
     * PROPOSAL_STATUS_WITHDRAWN - A proposal can be withdrawn before the voting start time by the owner.
     * When this happens the final status is Withdrawn.
     */ ProposalStatus[ProposalStatus["PROPOSAL_STATUS_WITHDRAWN"] = 5] = "PROPOSAL_STATUS_WITHDRAWN";
    ProposalStatus[ProposalStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
function proposalStatusFromJSON(object) {
    switch(object){
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
            return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_SUBMITTED":
            return ProposalStatus.PROPOSAL_STATUS_SUBMITTED;
        case 2:
        case "PROPOSAL_STATUS_ACCEPTED":
            return ProposalStatus.PROPOSAL_STATUS_ACCEPTED;
        case 3:
        case "PROPOSAL_STATUS_REJECTED":
            return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 4:
        case "PROPOSAL_STATUS_ABORTED":
            return ProposalStatus.PROPOSAL_STATUS_ABORTED;
        case 5:
        case "PROPOSAL_STATUS_WITHDRAWN":
            return ProposalStatus.PROPOSAL_STATUS_WITHDRAWN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProposalStatus.UNRECOGNIZED;
    }
}
exports.proposalStatusFromJSON = proposalStatusFromJSON;
function proposalStatusToJSON(object) {
    switch(object){
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
            return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_SUBMITTED:
            return "PROPOSAL_STATUS_SUBMITTED";
        case ProposalStatus.PROPOSAL_STATUS_ACCEPTED:
            return "PROPOSAL_STATUS_ACCEPTED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
            return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_ABORTED:
            return "PROPOSAL_STATUS_ABORTED";
        case ProposalStatus.PROPOSAL_STATUS_WITHDRAWN:
            return "PROPOSAL_STATUS_WITHDRAWN";
        case ProposalStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.proposalStatusToJSON = proposalStatusToJSON;
/** ProposalExecutorResult defines types of proposal executor results. */ var ProposalExecutorResult;
(function(ProposalExecutorResult) {
    /** PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED - An empty value is not allowed. */ ProposalExecutorResult[ProposalExecutorResult["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"] = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
    /** PROPOSAL_EXECUTOR_RESULT_NOT_RUN - We have not yet run the executor. */ ProposalExecutorResult[ProposalExecutorResult["PROPOSAL_EXECUTOR_RESULT_NOT_RUN"] = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
    /** PROPOSAL_EXECUTOR_RESULT_SUCCESS - The executor was successful and proposed action updated state. */ ProposalExecutorResult[ProposalExecutorResult["PROPOSAL_EXECUTOR_RESULT_SUCCESS"] = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
    /** PROPOSAL_EXECUTOR_RESULT_FAILURE - The executor returned an error and proposed action didn't update state. */ ProposalExecutorResult[ProposalExecutorResult["PROPOSAL_EXECUTOR_RESULT_FAILURE"] = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE";
    ProposalExecutorResult[ProposalExecutorResult["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProposalExecutorResult || (exports.ProposalExecutorResult = ProposalExecutorResult = {}));
function proposalExecutorResultFromJSON(object) {
    switch(object){
        case 0:
        case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
            return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
        case 1:
        case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
            return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
        case 2:
        case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
            return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
        case 3:
        case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
            return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProposalExecutorResult.UNRECOGNIZED;
    }
}
exports.proposalExecutorResultFromJSON = proposalExecutorResultFromJSON;
function proposalExecutorResultToJSON(object) {
    switch(object){
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
            return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
            return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
            return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE:
            return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
        case ProposalExecutorResult.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.proposalExecutorResultToJSON = proposalExecutorResultToJSON;
function createBaseMember() {
    return {
        address: "",
        weight: "",
        metadata: "",
        addedAt: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.Member = {
    typeUrl: "/cosmos.group.v1.Member",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.weight !== "") writer.uint32(18).string(message.weight);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        if (message.addedAt !== undefined) timestamp_1.Timestamp.encode(message.addedAt, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMember();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.weight = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.addedAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMember();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight)) obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.addedAt)) obj.addedAt = (0, helpers_1.fromJsonTimestamp)(object.addedAt);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.weight !== undefined && (obj.weight = message.weight);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.addedAt !== undefined && (obj.addedAt = (0, helpers_1.fromTimestamp)(message.addedAt).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMember();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        if (object.addedAt !== undefined && object.addedAt !== null) message.addedAt = timestamp_1.Timestamp.fromPartial(object.addedAt);
        return message;
    }
};
function createBaseMemberRequest() {
    return {
        address: "",
        weight: "",
        metadata: ""
    };
}
exports.MemberRequest = {
    typeUrl: "/cosmos.group.v1.MemberRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.weight !== "") writer.uint32(18).string(message.weight);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMemberRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.weight = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMemberRequest();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight)) obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.weight !== undefined && (obj.weight = message.weight);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMemberRequest();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        return message;
    }
};
function createBaseThresholdDecisionPolicy() {
    return {
        threshold: "",
        windows: undefined
    };
}
exports.ThresholdDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== "") writer.uint32(10).string(message.threshold);
        if (message.windows !== undefined) exports.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThresholdDecisionPolicy();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.threshold = reader.string();
                    break;
                case 2:
                    message.windows = exports.DecisionPolicyWindows.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseThresholdDecisionPolicy();
        if ((0, helpers_1.isSet)(object.threshold)) obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.windows)) obj.windows = exports.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.threshold !== undefined && (obj.threshold = message.threshold);
        message.windows !== undefined && (obj.windows = message.windows ? exports.DecisionPolicyWindows.toJSON(message.windows) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseThresholdDecisionPolicy();
        message.threshold = object.threshold ?? "";
        if (object.windows !== undefined && object.windows !== null) message.windows = exports.DecisionPolicyWindows.fromPartial(object.windows);
        return message;
    }
};
function createBasePercentageDecisionPolicy() {
    return {
        percentage: "",
        windows: undefined
    };
}
exports.PercentageDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.percentage !== "") writer.uint32(10).string(message.percentage);
        if (message.windows !== undefined) exports.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePercentageDecisionPolicy();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.percentage = reader.string();
                    break;
                case 2:
                    message.windows = exports.DecisionPolicyWindows.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePercentageDecisionPolicy();
        if ((0, helpers_1.isSet)(object.percentage)) obj.percentage = String(object.percentage);
        if ((0, helpers_1.isSet)(object.windows)) obj.windows = exports.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.percentage !== undefined && (obj.percentage = message.percentage);
        message.windows !== undefined && (obj.windows = message.windows ? exports.DecisionPolicyWindows.toJSON(message.windows) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePercentageDecisionPolicy();
        message.percentage = object.percentage ?? "";
        if (object.windows !== undefined && object.windows !== null) message.windows = exports.DecisionPolicyWindows.fromPartial(object.windows);
        return message;
    }
};
function createBaseDecisionPolicyWindows() {
    return {
        votingPeriod: duration_1.Duration.fromPartial({}),
        minExecutionPeriod: duration_1.Duration.fromPartial({})
    };
}
exports.DecisionPolicyWindows = {
    typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== undefined) duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        if (message.minExecutionPeriod !== undefined) duration_1.Duration.encode(message.minExecutionPeriod, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecisionPolicyWindows();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.minExecutionPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDecisionPolicyWindows();
        if ((0, helpers_1.isSet)(object.votingPeriod)) obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.minExecutionPeriod)) obj.minExecutionPeriod = duration_1.Duration.fromJSON(object.minExecutionPeriod);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.votingPeriod !== undefined && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : undefined);
        message.minExecutionPeriod !== undefined && (obj.minExecutionPeriod = message.minExecutionPeriod ? duration_1.Duration.toJSON(message.minExecutionPeriod) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDecisionPolicyWindows();
        if (object.votingPeriod !== undefined && object.votingPeriod !== null) message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        if (object.minExecutionPeriod !== undefined && object.minExecutionPeriod !== null) message.minExecutionPeriod = duration_1.Duration.fromPartial(object.minExecutionPeriod);
        return message;
    }
};
function createBaseGroupInfo() {
    return {
        id: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        totalWeight: "",
        createdAt: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.GroupInfo = {
    typeUrl: "/cosmos.group.v1.GroupInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) writer.uint32(8).uint64(message.id);
        if (message.admin !== "") writer.uint32(18).string(message.admin);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        if (message.version !== BigInt(0)) writer.uint32(32).uint64(message.version);
        if (message.totalWeight !== "") writer.uint32(42).string(message.totalWeight);
        if (message.createdAt !== undefined) timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(50).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.admin = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.version = reader.uint64();
                    break;
                case 5:
                    message.totalWeight = reader.string();
                    break;
                case 6:
                    message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGroupInfo();
        if ((0, helpers_1.isSet)(object.id)) obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version)) obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.totalWeight)) obj.totalWeight = String(object.totalWeight);
        if ((0, helpers_1.isSet)(object.createdAt)) obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || BigInt(0)).toString());
        message.admin !== undefined && (obj.admin = message.admin);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.version !== undefined && (obj.version = (message.version || BigInt(0)).toString());
        message.totalWeight !== undefined && (obj.totalWeight = message.totalWeight);
        message.createdAt !== undefined && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGroupInfo();
        if (object.id !== undefined && object.id !== null) message.id = BigInt(object.id.toString());
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== undefined && object.version !== null) message.version = BigInt(object.version.toString());
        message.totalWeight = object.totalWeight ?? "";
        if (object.createdAt !== undefined && object.createdAt !== null) message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        return message;
    }
};
function createBaseGroupMember() {
    return {
        groupId: BigInt(0),
        member: undefined
    };
}
exports.GroupMember = {
    typeUrl: "/cosmos.group.v1.GroupMember",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) writer.uint32(8).uint64(message.groupId);
        if (message.member !== undefined) exports.Member.encode(message.member, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMember();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupId = reader.uint64();
                    break;
                case 2:
                    message.member = exports.Member.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGroupMember();
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.member)) obj.member = exports.Member.fromJSON(object.member);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.member !== undefined && (obj.member = message.member ? exports.Member.toJSON(message.member) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGroupMember();
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        if (object.member !== undefined && object.member !== null) message.member = exports.Member.fromPartial(object.member);
        return message;
    }
};
function createBaseGroupPolicyInfo() {
    return {
        address: "",
        groupId: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        decisionPolicy: undefined,
        createdAt: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.GroupPolicyInfo = {
    typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.groupId !== BigInt(0)) writer.uint32(16).uint64(message.groupId);
        if (message.admin !== "") writer.uint32(26).string(message.admin);
        if (message.metadata !== "") writer.uint32(34).string(message.metadata);
        if (message.version !== BigInt(0)) writer.uint32(40).uint64(message.version);
        if (message.decisionPolicy !== undefined) any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        if (message.createdAt !== undefined) timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(58).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupPolicyInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.groupId = reader.uint64();
                    break;
                case 3:
                    message.admin = reader.string();
                    break;
                case 4:
                    message.metadata = reader.string();
                    break;
                case 5:
                    message.version = reader.uint64();
                    break;
                case 6:
                    message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGroupPolicyInfo();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId)) obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.admin)) obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version)) obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.decisionPolicy)) obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        if ((0, helpers_1.isSet)(object.createdAt)) obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.groupId !== undefined && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.admin !== undefined && (obj.admin = message.admin);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.version !== undefined && (obj.version = (message.version || BigInt(0)).toString());
        message.decisionPolicy !== undefined && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : undefined);
        message.createdAt !== undefined && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGroupPolicyInfo();
        message.address = object.address ?? "";
        if (object.groupId !== undefined && object.groupId !== null) message.groupId = BigInt(object.groupId.toString());
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== undefined && object.version !== null) message.version = BigInt(object.version.toString());
        if (object.decisionPolicy !== undefined && object.decisionPolicy !== null) message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        if (object.createdAt !== undefined && object.createdAt !== null) message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        return message;
    }
};
function createBaseProposal() {
    return {
        id: BigInt(0),
        groupPolicyAddress: "",
        metadata: "",
        proposers: [],
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        groupVersion: BigInt(0),
        groupPolicyVersion: BigInt(0),
        status: 0,
        finalTallyResult: exports.TallyResult.fromPartial({}),
        votingPeriodEnd: timestamp_1.Timestamp.fromPartial({}),
        executorResult: 0,
        messages: [],
        title: "",
        summary: ""
    };
}
exports.Proposal = {
    typeUrl: "/cosmos.group.v1.Proposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) writer.uint32(8).uint64(message.id);
        if (message.groupPolicyAddress !== "") writer.uint32(18).string(message.groupPolicyAddress);
        if (message.metadata !== "") writer.uint32(26).string(message.metadata);
        for (const v of message.proposers)writer.uint32(34).string(v);
        if (message.submitTime !== undefined) timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        if (message.groupVersion !== BigInt(0)) writer.uint32(48).uint64(message.groupVersion);
        if (message.groupPolicyVersion !== BigInt(0)) writer.uint32(56).uint64(message.groupPolicyVersion);
        if (message.status !== 0) writer.uint32(64).int32(message.status);
        if (message.finalTallyResult !== undefined) exports.TallyResult.encode(message.finalTallyResult, writer.uint32(74).fork()).ldelim();
        if (message.votingPeriodEnd !== undefined) timestamp_1.Timestamp.encode(message.votingPeriodEnd, writer.uint32(82).fork()).ldelim();
        if (message.executorResult !== 0) writer.uint32(88).int32(message.executorResult);
        for (const v of message.messages)any_1.Any.encode(v, writer.uint32(98).fork()).ldelim();
        if (message.title !== "") writer.uint32(106).string(message.title);
        if (message.summary !== "") writer.uint32(114).string(message.summary);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.groupPolicyAddress = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.proposers.push(reader.string());
                    break;
                case 5:
                    message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.groupVersion = reader.uint64();
                    break;
                case 7:
                    message.groupPolicyVersion = reader.uint64();
                    break;
                case 8:
                    message.status = reader.int32();
                    break;
                case 9:
                    message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.votingPeriodEnd = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.executorResult = reader.int32();
                    break;
                case 12:
                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.title = reader.string();
                    break;
                case 14:
                    message.summary = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id)) obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress)) obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if (Array.isArray(object?.proposers)) obj.proposers = object.proposers.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.submitTime)) obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.groupVersion)) obj.groupVersion = BigInt(object.groupVersion.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyVersion)) obj.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        if ((0, helpers_1.isSet)(object.status)) obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult)) obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.votingPeriodEnd)) obj.votingPeriodEnd = (0, helpers_1.fromJsonTimestamp)(object.votingPeriodEnd);
        if ((0, helpers_1.isSet)(object.executorResult)) obj.executorResult = proposalExecutorResultFromJSON(object.executorResult);
        if (Array.isArray(object?.messages)) obj.messages = object.messages.map((e)=>any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary)) obj.summary = String(object.summary);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || BigInt(0)).toString());
        message.groupPolicyAddress !== undefined && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        if (message.proposers) obj.proposers = message.proposers.map((e)=>e);
        else obj.proposers = [];
        message.submitTime !== undefined && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.groupVersion !== undefined && (obj.groupVersion = (message.groupVersion || BigInt(0)).toString());
        message.groupPolicyVersion !== undefined && (obj.groupPolicyVersion = (message.groupPolicyVersion || BigInt(0)).toString());
        message.status !== undefined && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== undefined && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : undefined);
        message.votingPeriodEnd !== undefined && (obj.votingPeriodEnd = (0, helpers_1.fromTimestamp)(message.votingPeriodEnd).toISOString());
        message.executorResult !== undefined && (obj.executorResult = proposalExecutorResultToJSON(message.executorResult));
        if (message.messages) obj.messages = message.messages.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.messages = [];
        message.title !== undefined && (obj.title = message.title);
        message.summary !== undefined && (obj.summary = message.summary);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProposal();
        if (object.id !== undefined && object.id !== null) message.id = BigInt(object.id.toString());
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        message.proposers = object.proposers?.map((e)=>e) || [];
        if (object.submitTime !== undefined && object.submitTime !== null) message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        if (object.groupVersion !== undefined && object.groupVersion !== null) message.groupVersion = BigInt(object.groupVersion.toString());
        if (object.groupPolicyVersion !== undefined && object.groupPolicyVersion !== null) message.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== undefined && object.finalTallyResult !== null) message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        if (object.votingPeriodEnd !== undefined && object.votingPeriodEnd !== null) message.votingPeriodEnd = timestamp_1.Timestamp.fromPartial(object.votingPeriodEnd);
        message.executorResult = object.executorResult ?? 0;
        message.messages = object.messages?.map((e)=>any_1.Any.fromPartial(e)) || [];
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
    }
};
function createBaseTallyResult() {
    return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
    };
}
exports.TallyResult = {
    typeUrl: "/cosmos.group.v1.TallyResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") writer.uint32(10).string(message.yesCount);
        if (message.abstainCount !== "") writer.uint32(18).string(message.abstainCount);
        if (message.noCount !== "") writer.uint32(26).string(message.noCount);
        if (message.noWithVetoCount !== "") writer.uint32(34).string(message.noWithVetoCount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.yesCount = reader.string();
                    break;
                case 2:
                    message.abstainCount = reader.string();
                    break;
                case 3:
                    message.noCount = reader.string();
                    break;
                case 4:
                    message.noWithVetoCount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount)) obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount)) obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount)) obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount)) obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.yesCount !== undefined && (obj.yesCount = message.yesCount);
        message.abstainCount !== undefined && (obj.abstainCount = message.abstainCount);
        message.noCount !== undefined && (obj.noCount = message.noCount);
        message.noWithVetoCount !== undefined && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
    }
};
function createBaseVote() {
    return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        submitTime: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.Vote = {
    typeUrl: "/cosmos.group.v1.Vote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) writer.uint32(8).uint64(message.proposalId);
        if (message.voter !== "") writer.uint32(18).string(message.voter);
        if (message.option !== 0) writer.uint32(24).int32(message.option);
        if (message.metadata !== "") writer.uint32(34).string(message.metadata);
        if (message.submitTime !== undefined) timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proposalId = reader.uint64();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.option = reader.int32();
                    break;
                case 4:
                    message.metadata = reader.string();
                    break;
                case 5:
                    message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId)) obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter)) obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option)) obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.submitTime)) obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.proposalId !== undefined && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== undefined && (obj.voter = message.voter);
        message.option !== undefined && (obj.option = voteOptionToJSON(message.option));
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.submitTime !== undefined && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVote();
        if (object.proposalId !== undefined && object.proposalId !== null) message.proposalId = BigInt(object.proposalId.toString());
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        if (object.submitTime !== undefined && object.submitTime !== null) message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        return message;
    }
};

},{"1a14fefbc89514a9":"6J6bq","a7e2acf832e28aad":"clU50","1c00996d04ff3819":"56aJC","dd5e88a7e6d4065f":"bi36x","171ad04ccd1a1bf0":"eYjRL"}],"goDLW":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgTransfer = isAminoMsgTransfer;
exports.createIbcAminoConverters = createIbcAminoConverters;
/* eslint-disable @typescript-eslint/naming-convention */ const amino_1 = require("27e99260ce611f3");
const tx_1 = require("e2b797a473e0a460");
function isAminoMsgTransfer(msg) {
    return msg.type === "cosmos-sdk/MsgTransfer";
}
function createIbcAminoConverters() {
    return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
            aminoType: "cosmos-sdk/MsgTransfer",
            toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo })=>({
                    source_port: sourcePort,
                    source_channel: sourceChannel,
                    token: token,
                    sender: sender,
                    receiver: receiver,
                    timeout_height: timeoutHeight ? {
                        revision_height: (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)?.toString(),
                        revision_number: (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)?.toString()
                    } : {},
                    timeout_timestamp: (0, amino_1.omitDefault)(timeoutTimestamp)?.toString(),
                    memo: (0, amino_1.omitDefault)(memo)
                }),
            fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo })=>tx_1.MsgTransfer.fromPartial({
                    sourcePort: source_port,
                    sourceChannel: source_channel,
                    token: token,
                    sender: sender,
                    receiver: receiver,
                    timeoutHeight: timeout_height ? {
                        revisionHeight: BigInt(timeout_height.revision_height || "0"),
                        revisionNumber: BigInt(timeout_height.revision_number || "0")
                    } : undefined,
                    timeoutTimestamp: BigInt(timeout_timestamp || "0"),
                    memo: memo ?? ""
                })
        }
    };
}

},{"27e99260ce611f3":"bh8mf","e2b797a473e0a460":"gBIkp"}],"gBIkp":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("3b81ed5eca1cd712");
const client_1 = require("1728273eb5ce8281");
const binary_1 = require("950279ea36570279");
const helpers_1 = require("e42d10a83f2a5b96");
exports.protobufPackage = "ibc.applications.transfer.v1";
function createBaseMsgTransfer() {
    return {
        sourcePort: "",
        sourceChannel: "",
        token: coin_1.Coin.fromPartial({}),
        sender: "",
        receiver: "",
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0),
        memo: ""
    };
}
exports.MsgTransfer = {
    typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.sourcePort !== "") writer.uint32(10).string(message.sourcePort);
        if (message.sourceChannel !== "") writer.uint32(18).string(message.sourceChannel);
        if (message.token !== undefined) coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        if (message.sender !== "") writer.uint32(34).string(message.sender);
        if (message.receiver !== "") writer.uint32(42).string(message.receiver);
        if (message.timeoutHeight !== undefined) client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        if (message.timeoutTimestamp !== BigInt(0)) writer.uint32(56).uint64(message.timeoutTimestamp);
        if (message.memo !== "") writer.uint32(66).string(message.memo);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sourcePort = reader.string();
                    break;
                case 2:
                    message.sourceChannel = reader.string();
                    break;
                case 3:
                    message.token = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.sender = reader.string();
                    break;
                case 5:
                    message.receiver = reader.string();
                    break;
                case 6:
                    message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.timeoutTimestamp = reader.uint64();
                    break;
                case 8:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgTransfer();
        if ((0, helpers_1.isSet)(object.sourcePort)) obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel)) obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.token)) obj.token = coin_1.Coin.fromJSON(object.token);
        if ((0, helpers_1.isSet)(object.sender)) obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.receiver)) obj.receiver = String(object.receiver);
        if ((0, helpers_1.isSet)(object.timeoutHeight)) obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp)) obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        if ((0, helpers_1.isSet)(object.memo)) obj.memo = String(object.memo);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.sourcePort !== undefined && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== undefined && (obj.sourceChannel = message.sourceChannel);
        message.token !== undefined && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : undefined);
        message.sender !== undefined && (obj.sender = message.sender);
        message.receiver !== undefined && (obj.receiver = message.receiver);
        message.timeoutHeight !== undefined && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : undefined);
        message.timeoutTimestamp !== undefined && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        message.memo !== undefined && (obj.memo = message.memo);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgTransfer();
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        if (object.token !== undefined && object.token !== null) message.token = coin_1.Coin.fromPartial(object.token);
        message.sender = object.sender ?? "";
        message.receiver = object.receiver ?? "";
        if (object.timeoutHeight !== undefined && object.timeoutHeight !== null) message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        if (object.timeoutTimestamp !== undefined && object.timeoutTimestamp !== null) message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        message.memo = object.memo ?? "";
        return message;
    }
};
function createBaseMsgTransferResponse() {
    return {
        sequence: BigInt(0)
    };
}
exports.MsgTransferResponse = {
    typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) writer.uint32(8).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgTransferResponse();
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgTransferResponse();
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: client_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") writer.uint32(10).string(message.signer);
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
    }
    Transfer(request) {
        const data = exports.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data);
        return promise.then((data)=>exports.MsgTransferResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"3b81ed5eca1cd712":"1ymyZ","1728273eb5ce8281":"3w7CV","950279ea36570279":"bi36x","e42d10a83f2a5b96":"eYjRL"}],"3w7CV":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpgradeProposal = exports.ClientUpdateProposal = exports.Params = exports.Height = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("9ace93fd3a33363e");
const upgrade_1 = require("7eca6d6b8d9496cd");
const binary_1 = require("64fb684d15738a79");
const helpers_1 = require("fff796c31a71f847");
exports.protobufPackage = "ibc.core.client.v1";
function createBaseIdentifiedClientState() {
    return {
        clientId: "",
        clientState: undefined
    };
}
exports.IdentifiedClientState = {
    typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.clientState !== undefined) any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.clientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseIdentifiedClientState();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState)) obj.clientState = any_1.Any.fromJSON(object.clientState);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseIdentifiedClientState();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== undefined && object.clientState !== null) message.clientState = any_1.Any.fromPartial(object.clientState);
        return message;
    }
};
function createBaseConsensusStateWithHeight() {
    return {
        height: exports.Height.fromPartial({}),
        consensusState: undefined
    };
}
exports.ConsensusStateWithHeight = {
    typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== undefined) exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        if (message.consensusState !== undefined) any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = exports.Height.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.consensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseConsensusStateWithHeight();
        if ((0, helpers_1.isSet)(object.height)) obj.height = exports.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.consensusState)) obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = message.height ? exports.Height.toJSON(message.height) : undefined);
        message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseConsensusStateWithHeight();
        if (object.height !== undefined && object.height !== null) message.height = exports.Height.fromPartial(object.height);
        if (object.consensusState !== undefined && object.consensusState !== null) message.consensusState = any_1.Any.fromPartial(object.consensusState);
        return message;
    }
};
function createBaseClientConsensusStates() {
    return {
        clientId: "",
        consensusStates: []
    };
}
exports.ClientConsensusStates = {
    typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        for (const v of message.consensusStates)exports.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseClientConsensusStates();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if (Array.isArray(object?.consensusStates)) obj.consensusStates = object.consensusStates.map((e)=>exports.ConsensusStateWithHeight.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        if (message.consensusStates) obj.consensusStates = message.consensusStates.map((e)=>e ? exports.ConsensusStateWithHeight.toJSON(e) : undefined);
        else obj.consensusStates = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseClientConsensusStates();
        message.clientId = object.clientId ?? "";
        message.consensusStates = object.consensusStates?.map((e)=>exports.ConsensusStateWithHeight.fromPartial(e)) || [];
        return message;
    }
};
function createBaseHeight() {
    return {
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
    };
}
exports.Height = {
    typeUrl: "/ibc.core.client.v1.Height",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.revisionNumber !== BigInt(0)) writer.uint32(8).uint64(message.revisionNumber);
        if (message.revisionHeight !== BigInt(0)) writer.uint32(16).uint64(message.revisionHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.revisionNumber = reader.uint64();
                    break;
                case 2:
                    message.revisionHeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseHeight();
        if ((0, helpers_1.isSet)(object.revisionNumber)) obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight)) obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.revisionNumber !== undefined && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== undefined && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseHeight();
        if (object.revisionNumber !== undefined && object.revisionNumber !== null) message.revisionNumber = BigInt(object.revisionNumber.toString());
        if (object.revisionHeight !== undefined && object.revisionHeight !== null) message.revisionHeight = BigInt(object.revisionHeight.toString());
        return message;
    }
};
function createBaseParams() {
    return {
        allowedClients: []
    };
}
exports.Params = {
    typeUrl: "/ibc.core.client.v1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowedClients)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.allowedClients.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if (Array.isArray(object?.allowedClients)) obj.allowedClients = object.allowedClients.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.allowedClients) obj.allowedClients = message.allowedClients.map((e)=>e);
        else obj.allowedClients = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.allowedClients = object.allowedClients?.map((e)=>e) || [];
        return message;
    }
};
function createBaseClientUpdateProposal() {
    return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
    };
}
exports.ClientUpdateProposal = {
    typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        if (message.subjectClientId !== "") writer.uint32(26).string(message.subjectClientId);
        if (message.substituteClientId !== "") writer.uint32(34).string(message.substituteClientId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.subjectClientId = reader.string();
                    break;
                case 4:
                    message.substituteClientId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseClientUpdateProposal();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.subjectClientId)) obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId)) obj.substituteClientId = String(object.substituteClientId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.subjectClientId !== undefined && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== undefined && (obj.substituteClientId = message.substituteClientId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseClientUpdateProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        return message;
    }
};
function createBaseUpgradeProposal() {
    return {
        title: "",
        description: "",
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: undefined
    };
}
exports.UpgradeProposal = {
    typeUrl: "/ibc.core.client.v1.UpgradeProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        if (message.plan !== undefined) upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        if (message.upgradedClientState !== undefined) any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan)) obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState)) obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.plan !== undefined && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : undefined);
        message.upgradedClientState !== undefined && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== undefined && object.plan !== null) message.plan = upgrade_1.Plan.fromPartial(object.plan);
        if (object.upgradedClientState !== undefined && object.upgradedClientState !== null) message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        return message;
    }
};

},{"9ace93fd3a33363e":"56aJC","7eca6d6b8d9496cd":"54VJG","64fb684d15738a79":"bi36x","fff796c31a71f847":"eYjRL"}],"54VJG":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModuleVersion = exports.CancelSoftwareUpgradeProposal = exports.SoftwareUpgradeProposal = exports.Plan = exports.protobufPackage = void 0;
/* eslint-disable */ const timestamp_1 = require("c5380ceb7e6229f");
const any_1 = require("313558c03575792d");
const binary_1 = require("f152b58435252e4c");
const helpers_1 = require("2bda82e6507d934f");
exports.protobufPackage = "cosmos.upgrade.v1beta1";
function createBasePlan() {
    return {
        name: "",
        time: timestamp_1.Timestamp.fromPartial({}),
        height: BigInt(0),
        info: "",
        upgradedClientState: undefined
    };
}
exports.Plan = {
    typeUrl: "/cosmos.upgrade.v1beta1.Plan",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") writer.uint32(10).string(message.name);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(18).fork()).ldelim();
        if (message.height !== BigInt(0)) writer.uint32(24).int64(message.height);
        if (message.info !== "") writer.uint32(34).string(message.info);
        if (message.upgradedClientState !== undefined) any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = reader.int64();
                    break;
                case 4:
                    message.info = reader.string();
                    break;
                case 5:
                    message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePlan();
        if ((0, helpers_1.isSet)(object.name)) obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.info)) obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.upgradedClientState)) obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.info !== undefined && (obj.info = message.info);
        message.upgradedClientState !== undefined && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePlan();
        message.name = object.name ?? "";
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.info = object.info ?? "";
        if (object.upgradedClientState !== undefined && object.upgradedClientState !== null) message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        return message;
    }
};
function createBaseSoftwareUpgradeProposal() {
    return {
        title: "",
        description: "",
        plan: exports.Plan.fromPartial({})
    };
}
exports.SoftwareUpgradeProposal = {
    typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        if (message.plan !== undefined) exports.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.plan = exports.Plan.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan)) obj.plan = exports.Plan.fromJSON(object.plan);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        message.plan !== undefined && (obj.plan = message.plan ? exports.Plan.toJSON(message.plan) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== undefined && object.plan !== null) message.plan = exports.Plan.fromPartial(object.plan);
        return message;
    }
};
function createBaseCancelSoftwareUpgradeProposal() {
    return {
        title: "",
        description: ""
    };
}
exports.CancelSoftwareUpgradeProposal = {
    typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") writer.uint32(10).string(message.title);
        if (message.description !== "") writer.uint32(18).string(message.description);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCancelSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title)) obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description)) obj.description = String(object.description);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.title !== undefined && (obj.title = message.title);
        message.description !== undefined && (obj.description = message.description);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
    }
};
function createBaseModuleVersion() {
    return {
        name: "",
        version: BigInt(0)
    };
}
exports.ModuleVersion = {
    typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") writer.uint32(10).string(message.name);
        if (message.version !== BigInt(0)) writer.uint32(16).uint64(message.version);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.version = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseModuleVersion();
        if ((0, helpers_1.isSet)(object.name)) obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.version)) obj.version = BigInt(object.version.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.version !== undefined && (obj.version = (message.version || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseModuleVersion();
        message.name = object.name ?? "";
        if (object.version !== undefined && object.version !== null) message.version = BigInt(object.version.toString());
        return message;
    }
};

},{"c5380ceb7e6229f":"6J6bq","313558c03575792d":"56aJC","f152b58435252e4c":"bi36x","2bda82e6507d934f":"eYjRL"}],"5kmcn":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ibcTypes = void 0;
exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
const tx_1 = require("119119581f5c68c7");
const tx_2 = require("480bbd5cf48b946f");
const tx_3 = require("fa5288f588602684");
const tx_4 = require("65693e8c944c72ce");
exports.ibcTypes = [
    [
        "/ibc.applications.transfer.v1.MsgTransfer",
        tx_1.MsgTransfer
    ],
    [
        "/ibc.core.channel.v1.MsgAcknowledgement",
        tx_2.MsgAcknowledgement
    ],
    [
        "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        tx_2.MsgChannelCloseConfirm
    ],
    [
        "/ibc.core.channel.v1.MsgChannelCloseInit",
        tx_2.MsgChannelCloseInit
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenAck",
        tx_2.MsgChannelOpenAck
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        tx_2.MsgChannelOpenConfirm
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenInit",
        tx_2.MsgChannelOpenInit
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenTry",
        tx_2.MsgChannelOpenTry
    ],
    [
        "/ibc.core.channel.v1.MsgRecvPacket",
        tx_2.MsgRecvPacket
    ],
    [
        "/ibc.core.channel.v1.MsgTimeout",
        tx_2.MsgTimeout
    ],
    [
        "/ibc.core.channel.v1.MsgTimeoutOnClose",
        tx_2.MsgTimeoutOnClose
    ],
    [
        "/ibc.core.client.v1.MsgCreateClient",
        tx_3.MsgCreateClient
    ],
    [
        "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        tx_3.MsgSubmitMisbehaviour
    ],
    [
        "/ibc.core.client.v1.MsgUpdateClient",
        tx_3.MsgUpdateClient
    ],
    [
        "/ibc.core.client.v1.MsgUpgradeClient",
        tx_3.MsgUpgradeClient
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenAck",
        tx_4.MsgConnectionOpenAck
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        tx_4.MsgConnectionOpenConfirm
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenInit",
        tx_4.MsgConnectionOpenInit
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenTry",
        tx_4.MsgConnectionOpenTry
    ]
];
function isMsgTransferEncodeObject(object) {
    return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
}

},{"119119581f5c68c7":"gBIkp","480bbd5cf48b946f":"9bWT8","fa5288f588602684":"fnGx8","65693e8c944c72ce":"gQgE7"}],"9bWT8":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgPruneAcknowledgementsResponse = exports.MsgPruneAcknowledgements = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgChannelUpgradeCancelResponse = exports.MsgChannelUpgradeCancel = exports.MsgChannelUpgradeTimeoutResponse = exports.MsgChannelUpgradeTimeout = exports.MsgChannelUpgradeOpenResponse = exports.MsgChannelUpgradeOpen = exports.MsgChannelUpgradeConfirmResponse = exports.MsgChannelUpgradeConfirm = exports.MsgChannelUpgradeAckResponse = exports.MsgChannelUpgradeAck = exports.MsgChannelUpgradeTryResponse = exports.MsgChannelUpgradeTry = exports.MsgChannelUpgradeInitResponse = exports.MsgChannelUpgradeInit = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.responseResultTypeToJSON = exports.responseResultTypeFromJSON = exports.ResponseResultType = exports.protobufPackage = void 0;
/* eslint-disable */ const channel_1 = require("d2042c05ac4f8cca");
const client_1 = require("5e1965ca76dc8b4b");
const upgrade_1 = require("42b5d329e3f892f5");
const binary_1 = require("da541db7a8a1dd6a");
const helpers_1 = require("6c42e51598ff0041");
exports.protobufPackage = "ibc.core.channel.v1";
/** ResponseResultType defines the possible outcomes of the execution of a message */ var ResponseResultType;
(function(ResponseResultType) {
    /** RESPONSE_RESULT_TYPE_UNSPECIFIED - Default zero value enumeration */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
    /** RESPONSE_RESULT_TYPE_NOOP - The message did not call the IBC application callbacks (because, for example, the packet had already been relayed) */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
    /** RESPONSE_RESULT_TYPE_SUCCESS - The message was executed successfully */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
    /** RESPONSE_RESULT_TYPE_FAILURE - The message was executed unsuccessfully */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_FAILURE"] = 3] = "RESPONSE_RESULT_TYPE_FAILURE";
    ResponseResultType[ResponseResultType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseResultType || (exports.ResponseResultType = ResponseResultType = {}));
function responseResultTypeFromJSON(object) {
    switch(object){
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
            return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
            return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
            return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case 3:
        case "RESPONSE_RESULT_TYPE_FAILURE":
            return ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseResultType.UNRECOGNIZED;
    }
}
exports.responseResultTypeFromJSON = responseResultTypeFromJSON;
function responseResultTypeToJSON(object) {
    switch(object){
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
            return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
            return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
            return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE:
            return "RESPONSE_RESULT_TYPE_FAILURE";
        case ResponseResultType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.responseResultTypeToJSON = responseResultTypeToJSON;
function createBaseMsgChannelOpenInit() {
    return {
        portId: "",
        channel: channel_1.Channel.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelOpenInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channel !== undefined) channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channel = channel_1.Channel.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelOpenInit();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channel)) obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelOpenInit();
        message.portId = object.portId ?? "";
        if (object.channel !== undefined && object.channel !== null) message.channel = channel_1.Channel.fromPartial(object.channel);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelOpenInitResponse() {
    return {
        channelId: "",
        version: ""
    };
}
exports.MsgChannelOpenInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.channelId !== "") writer.uint32(10).string(message.channelId);
        if (message.version !== "") writer.uint32(18).string(message.version);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.channelId = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelOpenInitResponse();
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelOpenInitResponse();
        message.channelId = object.channelId ?? "";
        message.version = object.version ?? "";
        return message;
    }
};
function createBaseMsgChannelOpenTry() {
    return {
        portId: "",
        previousChannelId: "",
        channel: channel_1.Channel.fromPartial({}),
        counterpartyVersion: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelOpenTry = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.previousChannelId !== "") writer.uint32(18).string(message.previousChannelId);
        if (message.channel !== undefined) channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        if (message.counterpartyVersion !== "") writer.uint32(34).string(message.counterpartyVersion);
        if (message.proofInit.length !== 0) writer.uint32(42).bytes(message.proofInit);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        if (message.signer !== "") writer.uint32(58).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.previousChannelId = reader.string();
                    break;
                case 3:
                    message.channel = channel_1.Channel.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.counterpartyVersion = reader.string();
                    break;
                case 5:
                    message.proofInit = reader.bytes();
                    break;
                case 6:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelOpenTry();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.previousChannelId)) obj.previousChannelId = String(object.previousChannelId);
        if ((0, helpers_1.isSet)(object.channel)) obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.counterpartyVersion)) obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofInit)) obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.previousChannelId !== undefined && (obj.previousChannelId = message.previousChannelId);
        message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);
        message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== undefined && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelOpenTry();
        message.portId = object.portId ?? "";
        message.previousChannelId = object.previousChannelId ?? "";
        if (object.channel !== undefined && object.channel !== null) message.channel = channel_1.Channel.fromPartial(object.channel);
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelOpenTryResponse() {
    return {
        version: "",
        channelId: ""
    };
}
exports.MsgChannelOpenTryResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") writer.uint32(10).string(message.version);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelOpenTryResponse();
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.version !== undefined && (obj.version = message.version);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelOpenTryResponse();
        message.version = object.version ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseMsgChannelOpenAck() {
    return {
        portId: "",
        channelId: "",
        counterpartyChannelId: "",
        counterpartyVersion: "",
        proofTry: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelOpenAck = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.counterpartyChannelId !== "") writer.uint32(26).string(message.counterpartyChannelId);
        if (message.counterpartyVersion !== "") writer.uint32(34).string(message.counterpartyVersion);
        if (message.proofTry.length !== 0) writer.uint32(42).bytes(message.proofTry);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        if (message.signer !== "") writer.uint32(58).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.counterpartyChannelId = reader.string();
                    break;
                case 4:
                    message.counterpartyVersion = reader.string();
                    break;
                case 5:
                    message.proofTry = reader.bytes();
                    break;
                case 6:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelOpenAck();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelId)) obj.counterpartyChannelId = String(object.counterpartyChannelId);
        if ((0, helpers_1.isSet)(object.counterpartyVersion)) obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofTry)) obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== undefined && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== undefined && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelOpenAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelId = object.counterpartyChannelId ?? "";
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofTry = object.proofTry ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelOpenAckResponse() {
    return {};
}
exports.MsgChannelOpenAckResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelOpenAckResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
    }
};
function createBaseMsgChannelOpenConfirm() {
    return {
        portId: "",
        channelId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelOpenConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.proofAck.length !== 0) writer.uint32(26).bytes(message.proofAck);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        if (message.signer !== "") writer.uint32(42).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.proofAck = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelOpenConfirm();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofAck)) obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.proofAck !== undefined && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelOpenConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelOpenConfirmResponse() {
    return {};
}
exports.MsgChannelOpenConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelOpenConfirmResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
    }
};
function createBaseMsgChannelCloseInit() {
    return {
        portId: "",
        channelId: "",
        signer: ""
    };
}
exports.MsgChannelCloseInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelCloseInit();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelCloseInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelCloseInitResponse() {
    return {};
}
exports.MsgChannelCloseInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelCloseInitResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
    }
};
function createBaseMsgChannelCloseConfirm() {
    return {
        portId: "",
        channelId: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
    };
}
exports.MsgChannelCloseConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.proofInit.length !== 0) writer.uint32(26).bytes(message.proofInit);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        if (message.signer !== "") writer.uint32(42).string(message.signer);
        if (message.counterpartyUpgradeSequence !== BigInt(0)) writer.uint32(48).uint64(message.counterpartyUpgradeSequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.proofInit = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.signer = reader.string();
                    break;
                case 6:
                    message.counterpartyUpgradeSequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelCloseConfirm();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofInit)) obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence)) obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.proofInit !== undefined && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== undefined && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelCloseConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== undefined && object.counterpartyUpgradeSequence !== null) message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return message;
    }
};
function createBaseMsgChannelCloseConfirmResponse() {
    return {};
}
exports.MsgChannelCloseConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelCloseConfirmResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
    }
};
function createBaseMsgRecvPacket() {
    return {
        packet: channel_1.Packet.fromPartial({}),
        proofCommitment: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgRecvPacket = {
    typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== undefined) channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        if (message.proofCommitment.length !== 0) writer.uint32(18).bytes(message.proofCommitment);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        if (message.signer !== "") writer.uint32(34).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proofCommitment = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgRecvPacket();
        if ((0, helpers_1.isSet)(object.packet)) obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofCommitment)) obj.proofCommitment = (0, helpers_1.bytesFromBase64)(object.proofCommitment);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);
        message.proofCommitment !== undefined && (obj.proofCommitment = (0, helpers_1.base64FromBytes)(message.proofCommitment !== undefined ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgRecvPacket();
        if (object.packet !== undefined && object.packet !== null) message.packet = channel_1.Packet.fromPartial(object.packet);
        message.proofCommitment = object.proofCommitment ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgRecvPacketResponse() {
    return {
        result: 0
    };
}
exports.MsgRecvPacketResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgRecvPacketResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgRecvPacketResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgTimeout() {
    return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: ""
    };
}
exports.MsgTimeout = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeout",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== undefined) channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        if (message.proofUnreceived.length !== 0) writer.uint32(18).bytes(message.proofUnreceived);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        if (message.nextSequenceRecv !== BigInt(0)) writer.uint32(32).uint64(message.nextSequenceRecv);
        if (message.signer !== "") writer.uint32(42).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proofUnreceived = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.nextSequenceRecv = reader.uint64();
                    break;
                case 5:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgTimeout();
        if ((0, helpers_1.isSet)(object.packet)) obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived)) obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv)) obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);
        message.proofUnreceived !== undefined && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgTimeout();
        if (object.packet !== undefined && object.packet !== null) message.packet = channel_1.Packet.fromPartial(object.packet);
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgTimeoutResponse() {
    return {
        result: 0
    };
}
exports.MsgTimeoutResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgTimeoutResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgTimeoutResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgTimeoutOnClose() {
    return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofClose: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
    };
}
exports.MsgTimeoutOnClose = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== undefined) channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        if (message.proofUnreceived.length !== 0) writer.uint32(18).bytes(message.proofUnreceived);
        if (message.proofClose.length !== 0) writer.uint32(26).bytes(message.proofClose);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        if (message.nextSequenceRecv !== BigInt(0)) writer.uint32(40).uint64(message.nextSequenceRecv);
        if (message.signer !== "") writer.uint32(50).string(message.signer);
        if (message.counterpartyUpgradeSequence !== BigInt(0)) writer.uint32(56).uint64(message.counterpartyUpgradeSequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proofUnreceived = reader.bytes();
                    break;
                case 3:
                    message.proofClose = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.nextSequenceRecv = reader.uint64();
                    break;
                case 6:
                    message.signer = reader.string();
                    break;
                case 7:
                    message.counterpartyUpgradeSequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgTimeoutOnClose();
        if ((0, helpers_1.isSet)(object.packet)) obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived)) obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofClose)) obj.proofClose = (0, helpers_1.bytesFromBase64)(object.proofClose);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv)) obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence)) obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);
        message.proofUnreceived !== undefined && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== undefined && (obj.proofClose = (0, helpers_1.base64FromBytes)(message.proofClose !== undefined ? message.proofClose : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== undefined && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== undefined && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgTimeoutOnClose();
        if (object.packet !== undefined && object.packet !== null) message.packet = channel_1.Packet.fromPartial(object.packet);
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        message.proofClose = object.proofClose ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== undefined && object.counterpartyUpgradeSequence !== null) message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return message;
    }
};
function createBaseMsgTimeoutOnCloseResponse() {
    return {
        result: 0
    };
}
exports.MsgTimeoutOnCloseResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgTimeoutOnCloseResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgAcknowledgement() {
    return {
        packet: channel_1.Packet.fromPartial({}),
        acknowledgement: new Uint8Array(),
        proofAcked: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgAcknowledgement = {
    typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== undefined) channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        if (message.acknowledgement.length !== 0) writer.uint32(18).bytes(message.acknowledgement);
        if (message.proofAcked.length !== 0) writer.uint32(26).bytes(message.proofAcked);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        if (message.signer !== "") writer.uint32(42).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.acknowledgement = reader.bytes();
                    break;
                case 3:
                    message.proofAcked = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgAcknowledgement();
        if ((0, helpers_1.isSet)(object.packet)) obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.acknowledgement)) obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proofAcked)) obj.proofAcked = (0, helpers_1.bytesFromBase64)(object.proofAcked);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);
        message.acknowledgement !== undefined && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== undefined && (obj.proofAcked = (0, helpers_1.base64FromBytes)(message.proofAcked !== undefined ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgAcknowledgement();
        if (object.packet !== undefined && object.packet !== null) message.packet = channel_1.Packet.fromPartial(object.packet);
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proofAcked = object.proofAcked ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgAcknowledgementResponse() {
    return {
        result: 0
    };
}
exports.MsgAcknowledgementResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgAcknowledgementResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeInit() {
    return {
        portId: "",
        channelId: "",
        fields: upgrade_1.UpgradeFields.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.fields !== undefined) upgrade_1.UpgradeFields.encode(message.fields, writer.uint32(26).fork()).ldelim();
        if (message.signer !== "") writer.uint32(34).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.fields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeInit();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.fields)) obj.fields = upgrade_1.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.fields !== undefined && (obj.fields = message.fields ? upgrade_1.UpgradeFields.toJSON(message.fields) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.fields !== undefined && object.fields !== null) message.fields = upgrade_1.UpgradeFields.fromPartial(object.fields);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeInitResponse() {
    return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0)
    };
}
exports.MsgChannelUpgradeInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInitResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== undefined) upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        if (message.upgradeSequence !== BigInt(0)) writer.uint32(16).uint64(message.upgradeSequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.upgradeSequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeInitResponse();
        if ((0, helpers_1.isSet)(object.upgrade)) obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence)) obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.upgrade !== undefined && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : undefined);
        message.upgradeSequence !== undefined && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeInitResponse();
        if (object.upgrade !== undefined && object.upgrade !== null) message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        if (object.upgradeSequence !== undefined && object.upgradeSequence !== null) message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return message;
    }
};
function createBaseMsgChannelUpgradeTry() {
    return {
        portId: "",
        channelId: "",
        proposedUpgradeConnectionHops: [],
        counterpartyUpgradeFields: upgrade_1.UpgradeFields.fromPartial({}),
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeTry = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        for (const v of message.proposedUpgradeConnectionHops)writer.uint32(26).string(v);
        if (message.counterpartyUpgradeFields !== undefined) upgrade_1.UpgradeFields.encode(message.counterpartyUpgradeFields, writer.uint32(34).fork()).ldelim();
        if (message.counterpartyUpgradeSequence !== BigInt(0)) writer.uint32(40).uint64(message.counterpartyUpgradeSequence);
        if (message.proofChannel.length !== 0) writer.uint32(50).bytes(message.proofChannel);
        if (message.proofUpgrade.length !== 0) writer.uint32(58).bytes(message.proofUpgrade);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(66).fork()).ldelim();
        if (message.signer !== "") writer.uint32(74).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.proposedUpgradeConnectionHops.push(reader.string());
                    break;
                case 4:
                    message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.counterpartyUpgradeSequence = reader.uint64();
                    break;
                case 6:
                    message.proofChannel = reader.bytes();
                    break;
                case 7:
                    message.proofUpgrade = reader.bytes();
                    break;
                case 8:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeTry();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if (Array.isArray(object?.proposedUpgradeConnectionHops)) obj.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeFields)) obj.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromJSON(object.counterpartyUpgradeFields);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence)) obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel)) obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade)) obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        if (message.proposedUpgradeConnectionHops) obj.proposedUpgradeConnectionHops = message.proposedUpgradeConnectionHops.map((e)=>e);
        else obj.proposedUpgradeConnectionHops = [];
        message.counterpartyUpgradeFields !== undefined && (obj.counterpartyUpgradeFields = message.counterpartyUpgradeFields ? upgrade_1.UpgradeFields.toJSON(message.counterpartyUpgradeFields) : undefined);
        message.counterpartyUpgradeSequence !== undefined && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== undefined && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== undefined ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== undefined && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== undefined ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeTry();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops?.map((e)=>e) || [];
        if (object.counterpartyUpgradeFields !== undefined && object.counterpartyUpgradeFields !== null) message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromPartial(object.counterpartyUpgradeFields);
        if (object.counterpartyUpgradeSequence !== undefined && object.counterpartyUpgradeSequence !== null) message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeTryResponse() {
    return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0),
        result: 0
    };
}
exports.MsgChannelUpgradeTryResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTryResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== undefined) upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        if (message.upgradeSequence !== BigInt(0)) writer.uint32(16).uint64(message.upgradeSequence);
        if (message.result !== 0) writer.uint32(24).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.upgradeSequence = reader.uint64();
                    break;
                case 3:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeTryResponse();
        if ((0, helpers_1.isSet)(object.upgrade)) obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence)) obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.upgrade !== undefined && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : undefined);
        message.upgradeSequence !== undefined && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeTryResponse();
        if (object.upgrade !== undefined && object.upgrade !== null) message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        if (object.upgradeSequence !== undefined && object.upgradeSequence !== null) message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeAck() {
    return {
        portId: "",
        channelId: "",
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeAck = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAck",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.counterpartyUpgrade !== undefined) upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(26).fork()).ldelim();
        if (message.proofChannel.length !== 0) writer.uint32(34).bytes(message.proofChannel);
        if (message.proofUpgrade.length !== 0) writer.uint32(42).bytes(message.proofUpgrade);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        if (message.signer !== "") writer.uint32(58).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAck();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.proofChannel = reader.bytes();
                    break;
                case 5:
                    message.proofUpgrade = reader.bytes();
                    break;
                case 6:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeAck();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade)) obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel)) obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade)) obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.counterpartyUpgrade !== undefined && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : undefined);
        message.proofChannel !== undefined && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== undefined ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== undefined && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== undefined ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyUpgrade !== undefined && object.counterpartyUpgrade !== null) message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeAckResponse() {
    return {
        result: 0
    };
}
exports.MsgChannelUpgradeAckResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAckResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAckResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeAckResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeAckResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeConfirm() {
    return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirm",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.counterpartyChannelState !== 0) writer.uint32(24).int32(message.counterpartyChannelState);
        if (message.counterpartyUpgrade !== undefined) upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(34).fork()).ldelim();
        if (message.proofChannel.length !== 0) writer.uint32(42).bytes(message.proofChannel);
        if (message.proofUpgrade.length !== 0) writer.uint32(50).bytes(message.proofUpgrade);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        if (message.signer !== "") writer.uint32(66).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.counterpartyChannelState = reader.int32();
                    break;
                case 4:
                    message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.proofChannel = reader.bytes();
                    break;
                case 6:
                    message.proofUpgrade = reader.bytes();
                    break;
                case 7:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeConfirm();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState)) obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade)) obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel)) obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade)) obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== undefined && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgrade !== undefined && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : undefined);
        message.proofChannel !== undefined && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== undefined ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== undefined && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== undefined ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgrade !== undefined && object.counterpartyUpgrade !== null) message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeConfirmResponse() {
    return {
        result: 0
    };
}
exports.MsgChannelUpgradeConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirmResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeConfirmResponse();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseResultTypeFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeOpen() {
    return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeOpen = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpen",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.counterpartyChannelState !== 0) writer.uint32(24).int32(message.counterpartyChannelState);
        if (message.counterpartyUpgradeSequence !== BigInt(0)) writer.uint32(32).uint64(message.counterpartyUpgradeSequence);
        if (message.proofChannel.length !== 0) writer.uint32(42).bytes(message.proofChannel);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        if (message.signer !== "") writer.uint32(58).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpen();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.counterpartyChannelState = reader.int32();
                    break;
                case 4:
                    message.counterpartyUpgradeSequence = reader.uint64();
                    break;
                case 5:
                    message.proofChannel = reader.bytes();
                    break;
                case 6:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeOpen();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState)) obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence)) obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel)) obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== undefined && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgradeSequence !== undefined && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== undefined && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== undefined ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeOpen();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgradeSequence !== undefined && object.counterpartyUpgradeSequence !== null) message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeOpenResponse() {
    return {};
}
exports.MsgChannelUpgradeOpenResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpenResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpenResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelUpgradeOpenResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelUpgradeOpenResponse();
        return message;
    }
};
function createBaseMsgChannelUpgradeTimeout() {
    return {
        portId: "",
        channelId: "",
        counterpartyChannel: channel_1.Channel.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeTimeout = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeout",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.counterpartyChannel !== undefined) channel_1.Channel.encode(message.counterpartyChannel, writer.uint32(26).fork()).ldelim();
        if (message.proofChannel.length !== 0) writer.uint32(34).bytes(message.proofChannel);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        if (message.signer !== "") writer.uint32(50).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeout();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.counterpartyChannel = channel_1.Channel.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.proofChannel = reader.bytes();
                    break;
                case 5:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeTimeout();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannel)) obj.counterpartyChannel = channel_1.Channel.fromJSON(object.counterpartyChannel);
        if ((0, helpers_1.isSet)(object.proofChannel)) obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.counterpartyChannel !== undefined && (obj.counterpartyChannel = message.counterpartyChannel ? channel_1.Channel.toJSON(message.counterpartyChannel) : undefined);
        message.proofChannel !== undefined && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== undefined ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeTimeout();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyChannel !== undefined && object.counterpartyChannel !== null) message.counterpartyChannel = channel_1.Channel.fromPartial(object.counterpartyChannel);
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeTimeoutResponse() {
    return {};
}
exports.MsgChannelUpgradeTimeoutResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeoutResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelUpgradeTimeoutResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        return message;
    }
};
function createBaseMsgChannelUpgradeCancel() {
    return {
        portId: "",
        channelId: "",
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proofErrorReceipt: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgChannelUpgradeCancel = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancel",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.errorReceipt !== undefined) upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(26).fork()).ldelim();
        if (message.proofErrorReceipt.length !== 0) writer.uint32(34).bytes(message.proofErrorReceipt);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        if (message.signer !== "") writer.uint32(50).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancel();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.proofErrorReceipt = reader.bytes();
                    break;
                case 5:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgChannelUpgradeCancel();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.errorReceipt)) obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proofErrorReceipt)) obj.proofErrorReceipt = (0, helpers_1.bytesFromBase64)(object.proofErrorReceipt);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.errorReceipt !== undefined && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : undefined);
        message.proofErrorReceipt !== undefined && (obj.proofErrorReceipt = (0, helpers_1.base64FromBytes)(message.proofErrorReceipt !== undefined ? message.proofErrorReceipt : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgChannelUpgradeCancel();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.errorReceipt !== undefined && object.errorReceipt !== null) message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        message.proofErrorReceipt = object.proofErrorReceipt ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgChannelUpgradeCancelResponse() {
    return {};
}
exports.MsgChannelUpgradeCancelResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancelResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancelResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgChannelUpgradeCancelResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgChannelUpgradeCancelResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: client_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/ibc.core.channel.v1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
function createBaseMsgPruneAcknowledgements() {
    return {
        portId: "",
        channelId: "",
        limit: BigInt(0),
        signer: ""
    };
}
exports.MsgPruneAcknowledgements = {
    typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgements",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.limit !== BigInt(0)) writer.uint32(24).uint64(message.limit);
        if (message.signer !== "") writer.uint32(34).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgements();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.limit = reader.uint64();
                    break;
                case 4:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgPruneAcknowledgements();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.limit)) obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.limit !== undefined && (obj.limit = (message.limit || BigInt(0)).toString());
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgPruneAcknowledgements();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.limit !== undefined && object.limit !== null) message.limit = BigInt(object.limit.toString());
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgPruneAcknowledgementsResponse() {
    return {
        totalPrunedSequences: BigInt(0),
        totalRemainingSequences: BigInt(0)
    };
}
exports.MsgPruneAcknowledgementsResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgementsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalPrunedSequences !== BigInt(0)) writer.uint32(8).uint64(message.totalPrunedSequences);
        if (message.totalRemainingSequences !== BigInt(0)) writer.uint32(16).uint64(message.totalRemainingSequences);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgementsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.totalPrunedSequences = reader.uint64();
                    break;
                case 2:
                    message.totalRemainingSequences = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgPruneAcknowledgementsResponse();
        if ((0, helpers_1.isSet)(object.totalPrunedSequences)) obj.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        if ((0, helpers_1.isSet)(object.totalRemainingSequences)) obj.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.totalPrunedSequences !== undefined && (obj.totalPrunedSequences = (message.totalPrunedSequences || BigInt(0)).toString());
        message.totalRemainingSequences !== undefined && (obj.totalRemainingSequences = (message.totalRemainingSequences || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgPruneAcknowledgementsResponse();
        if (object.totalPrunedSequences !== undefined && object.totalPrunedSequences !== null) message.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        if (object.totalRemainingSequences !== undefined && object.totalRemainingSequences !== null) message.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
        this.ChannelUpgradeInit = this.ChannelUpgradeInit.bind(this);
        this.ChannelUpgradeTry = this.ChannelUpgradeTry.bind(this);
        this.ChannelUpgradeAck = this.ChannelUpgradeAck.bind(this);
        this.ChannelUpgradeConfirm = this.ChannelUpgradeConfirm.bind(this);
        this.ChannelUpgradeOpen = this.ChannelUpgradeOpen.bind(this);
        this.ChannelUpgradeTimeout = this.ChannelUpgradeTimeout.bind(this);
        this.ChannelUpgradeCancel = this.ChannelUpgradeCancel.bind(this);
        this.UpdateChannelParams = this.UpdateChannelParams.bind(this);
        this.PruneAcknowledgements = this.PruneAcknowledgements.bind(this);
    }
    ChannelOpenInit(request) {
        const data = exports.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data);
        return promise.then((data)=>exports.MsgChannelOpenInitResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelOpenTry(request) {
        const data = exports.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data);
        return promise.then((data)=>exports.MsgChannelOpenTryResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelOpenAck(request) {
        const data = exports.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data);
        return promise.then((data)=>exports.MsgChannelOpenAckResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelOpenConfirm(request) {
        const data = exports.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data);
        return promise.then((data)=>exports.MsgChannelOpenConfirmResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelCloseInit(request) {
        const data = exports.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data);
        return promise.then((data)=>exports.MsgChannelCloseInitResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelCloseConfirm(request) {
        const data = exports.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data);
        return promise.then((data)=>exports.MsgChannelCloseConfirmResponse.decode(new binary_1.BinaryReader(data)));
    }
    RecvPacket(request) {
        const data = exports.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data);
        return promise.then((data)=>exports.MsgRecvPacketResponse.decode(new binary_1.BinaryReader(data)));
    }
    Timeout(request) {
        const data = exports.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data);
        return promise.then((data)=>exports.MsgTimeoutResponse.decode(new binary_1.BinaryReader(data)));
    }
    TimeoutOnClose(request) {
        const data = exports.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data);
        return promise.then((data)=>exports.MsgTimeoutOnCloseResponse.decode(new binary_1.BinaryReader(data)));
    }
    Acknowledgement(request) {
        const data = exports.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data);
        return promise.then((data)=>exports.MsgAcknowledgementResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeInit(request) {
        const data = exports.MsgChannelUpgradeInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeInit", data);
        return promise.then((data)=>exports.MsgChannelUpgradeInitResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeTry(request) {
        const data = exports.MsgChannelUpgradeTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTry", data);
        return promise.then((data)=>exports.MsgChannelUpgradeTryResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeAck(request) {
        const data = exports.MsgChannelUpgradeAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeAck", data);
        return promise.then((data)=>exports.MsgChannelUpgradeAckResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeConfirm(request) {
        const data = exports.MsgChannelUpgradeConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeConfirm", data);
        return promise.then((data)=>exports.MsgChannelUpgradeConfirmResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeOpen(request) {
        const data = exports.MsgChannelUpgradeOpen.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeOpen", data);
        return promise.then((data)=>exports.MsgChannelUpgradeOpenResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeTimeout(request) {
        const data = exports.MsgChannelUpgradeTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTimeout", data);
        return promise.then((data)=>exports.MsgChannelUpgradeTimeoutResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelUpgradeCancel(request) {
        const data = exports.MsgChannelUpgradeCancel.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeCancel", data);
        return promise.then((data)=>exports.MsgChannelUpgradeCancelResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateChannelParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "UpdateChannelParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    PruneAcknowledgements(request) {
        const data = exports.MsgPruneAcknowledgements.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "PruneAcknowledgements", data);
        return promise.then((data)=>exports.MsgPruneAcknowledgementsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"d2042c05ac4f8cca":"eujl6","5e1965ca76dc8b4b":"3w7CV","42b5d329e3f892f5":"fZsk6","da541db7a8a1dd6a":"bi36x","6c42e51598ff0041":"eYjRL"}],"eujl6":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.Timeout = exports.Acknowledgement = exports.PacketId = exports.PacketState = exports.Packet = exports.Counterparty = exports.IdentifiedChannel = exports.Channel = exports.orderToJSON = exports.orderFromJSON = exports.Order = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
/* eslint-disable */ const client_1 = require("f04282a1fdfd852f");
const binary_1 = require("c924d6a858361b78");
const helpers_1 = require("6cea181fb0d6f3a8");
exports.protobufPackage = "ibc.core.channel.v1";
/**
 * State defines if a channel is in one of the following states:
 * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
 */ var State;
(function(State) {
    /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */ State[State["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
    /** STATE_INIT - A channel has just started the opening handshake. */ State[State["STATE_INIT"] = 1] = "STATE_INIT";
    /** STATE_TRYOPEN - A channel has acknowledged the handshake step on the counterparty chain. */ State[State["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
    /**
     * STATE_OPEN - A channel has completed the handshake. Open channels are
     * ready to send and receive packets.
     */ State[State["STATE_OPEN"] = 3] = "STATE_OPEN";
    /**
     * STATE_CLOSED - A channel has been closed and can no longer be used to send or receive
     * packets.
     */ State[State["STATE_CLOSED"] = 4] = "STATE_CLOSED";
    /** STATE_FLUSHING - A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets. */ State[State["STATE_FLUSHING"] = 5] = "STATE_FLUSHING";
    /** STATE_FLUSHCOMPLETE - A channel has just completed flushing any in-flight packets. */ State[State["STATE_FLUSHCOMPLETE"] = 6] = "STATE_FLUSHCOMPLETE";
    State[State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(State || (exports.State = State = {}));
function stateFromJSON(object) {
    switch(object){
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
            return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
            return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
            return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
            return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
            return State.STATE_CLOSED;
        case 5:
        case "STATE_FLUSHING":
            return State.STATE_FLUSHING;
        case 6:
        case "STATE_FLUSHCOMPLETE":
            return State.STATE_FLUSHCOMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return State.UNRECOGNIZED;
    }
}
exports.stateFromJSON = stateFromJSON;
function stateToJSON(object) {
    switch(object){
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
            return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
            return "STATE_INIT";
        case State.STATE_TRYOPEN:
            return "STATE_TRYOPEN";
        case State.STATE_OPEN:
            return "STATE_OPEN";
        case State.STATE_CLOSED:
            return "STATE_CLOSED";
        case State.STATE_FLUSHING:
            return "STATE_FLUSHING";
        case State.STATE_FLUSHCOMPLETE:
            return "STATE_FLUSHCOMPLETE";
        case State.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.stateToJSON = stateToJSON;
/** Order defines if a channel is ORDERED or UNORDERED */ var Order;
(function(Order) {
    /** ORDER_NONE_UNSPECIFIED - zero-value for channel ordering */ Order[Order["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
    /**
     * ORDER_UNORDERED - packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     */ Order[Order["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
    /** ORDER_ORDERED - packets are delivered exactly in the order which they were sent */ Order[Order["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
    Order[Order["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Order || (exports.Order = Order = {}));
function orderFromJSON(object) {
    switch(object){
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
            return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
            return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
            return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Order.UNRECOGNIZED;
    }
}
exports.orderFromJSON = orderFromJSON;
function orderToJSON(object) {
    switch(object){
        case Order.ORDER_NONE_UNSPECIFIED:
            return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
            return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
            return "ORDER_ORDERED";
        case Order.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.orderToJSON = orderToJSON;
function createBaseChannel() {
    return {
        state: 0,
        ordering: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        upgradeSequence: BigInt(0)
    };
}
exports.Channel = {
    typeUrl: "/ibc.core.channel.v1.Channel",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) writer.uint32(8).int32(message.state);
        if (message.ordering !== 0) writer.uint32(16).int32(message.ordering);
        if (message.counterparty !== undefined) exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        for (const v of message.connectionHops)writer.uint32(34).string(v);
        if (message.version !== "") writer.uint32(42).string(message.version);
        if (message.upgradeSequence !== BigInt(0)) writer.uint32(48).uint64(message.upgradeSequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.state = reader.int32();
                    break;
                case 2:
                    message.ordering = reader.int32();
                    break;
                case 3:
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.connectionHops.push(reader.string());
                    break;
                case 5:
                    message.version = reader.string();
                    break;
                case 6:
                    message.upgradeSequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseChannel();
        if ((0, helpers_1.isSet)(object.state)) obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering)) obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty)) obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object?.connectionHops)) obj.connectionHops = object.connectionHops.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.upgradeSequence)) obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.state !== undefined && (obj.state = stateToJSON(message.state));
        message.ordering !== undefined && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);
        if (message.connectionHops) obj.connectionHops = message.connectionHops.map((e)=>e);
        else obj.connectionHops = [];
        message.version !== undefined && (obj.version = message.version);
        message.upgradeSequence !== undefined && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== undefined && object.counterparty !== null) message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        message.connectionHops = object.connectionHops?.map((e)=>e) || [];
        message.version = object.version ?? "";
        if (object.upgradeSequence !== undefined && object.upgradeSequence !== null) message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return message;
    }
};
function createBaseIdentifiedChannel() {
    return {
        state: 0,
        ordering: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        portId: "",
        channelId: "",
        upgradeSequence: BigInt(0)
    };
}
exports.IdentifiedChannel = {
    typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) writer.uint32(8).int32(message.state);
        if (message.ordering !== 0) writer.uint32(16).int32(message.ordering);
        if (message.counterparty !== undefined) exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        for (const v of message.connectionHops)writer.uint32(34).string(v);
        if (message.version !== "") writer.uint32(42).string(message.version);
        if (message.portId !== "") writer.uint32(50).string(message.portId);
        if (message.channelId !== "") writer.uint32(58).string(message.channelId);
        if (message.upgradeSequence !== BigInt(0)) writer.uint32(64).uint64(message.upgradeSequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.state = reader.int32();
                    break;
                case 2:
                    message.ordering = reader.int32();
                    break;
                case 3:
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.connectionHops.push(reader.string());
                    break;
                case 5:
                    message.version = reader.string();
                    break;
                case 6:
                    message.portId = reader.string();
                    break;
                case 7:
                    message.channelId = reader.string();
                    break;
                case 8:
                    message.upgradeSequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseIdentifiedChannel();
        if ((0, helpers_1.isSet)(object.state)) obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering)) obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty)) obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object?.connectionHops)) obj.connectionHops = object.connectionHops.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.upgradeSequence)) obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.state !== undefined && (obj.state = stateToJSON(message.state));
        message.ordering !== undefined && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);
        if (message.connectionHops) obj.connectionHops = message.connectionHops.map((e)=>e);
        else obj.connectionHops = [];
        message.version !== undefined && (obj.version = message.version);
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.upgradeSequence !== undefined && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseIdentifiedChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== undefined && object.counterparty !== null) message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        message.connectionHops = object.connectionHops?.map((e)=>e) || [];
        message.version = object.version ?? "";
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.upgradeSequence !== undefined && object.upgradeSequence !== null) message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return message;
    }
};
function createBaseCounterparty() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.Counterparty = {
    typeUrl: "/ibc.core.channel.v1.Counterparty",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCounterparty();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBasePacket() {
    return {
        sequence: BigInt(0),
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0)
    };
}
exports.Packet = {
    typeUrl: "/ibc.core.channel.v1.Packet",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) writer.uint32(8).uint64(message.sequence);
        if (message.sourcePort !== "") writer.uint32(18).string(message.sourcePort);
        if (message.sourceChannel !== "") writer.uint32(26).string(message.sourceChannel);
        if (message.destinationPort !== "") writer.uint32(34).string(message.destinationPort);
        if (message.destinationChannel !== "") writer.uint32(42).string(message.destinationChannel);
        if (message.data.length !== 0) writer.uint32(50).bytes(message.data);
        if (message.timeoutHeight !== undefined) client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        if (message.timeoutTimestamp !== BigInt(0)) writer.uint32(64).uint64(message.timeoutTimestamp);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sequence = reader.uint64();
                    break;
                case 2:
                    message.sourcePort = reader.string();
                    break;
                case 3:
                    message.sourceChannel = reader.string();
                    break;
                case 4:
                    message.destinationPort = reader.string();
                    break;
                case 5:
                    message.destinationChannel = reader.string();
                    break;
                case 6:
                    message.data = reader.bytes();
                    break;
                case 7:
                    message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.timeoutTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePacket();
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.sourcePort)) obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel)) obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.destinationPort)) obj.destinationPort = String(object.destinationPort);
        if ((0, helpers_1.isSet)(object.destinationChannel)) obj.destinationChannel = String(object.destinationChannel);
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.timeoutHeight)) obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp)) obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.sourcePort !== undefined && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== undefined && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== undefined && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== undefined && (obj.destinationChannel = message.destinationChannel);
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.timeoutHeight !== undefined && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : undefined);
        message.timeoutTimestamp !== undefined && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBasePacket();
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        message.destinationPort = object.destinationPort ?? "";
        message.destinationChannel = object.destinationChannel ?? "";
        message.data = object.data ?? new Uint8Array();
        if (object.timeoutHeight !== undefined && object.timeoutHeight !== null) message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        if (object.timeoutTimestamp !== undefined && object.timeoutTimestamp !== null) message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        return message;
    }
};
function createBasePacketState() {
    return {
        portId: "",
        channelId: "",
        sequence: BigInt(0),
        data: new Uint8Array()
    };
}
exports.PacketState = {
    typeUrl: "/ibc.core.channel.v1.PacketState",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        if (message.data.length !== 0) writer.uint32(34).bytes(message.data);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePacketState();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBasePacketState();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        message.data = object.data ?? new Uint8Array();
        return message;
    }
};
function createBasePacketId() {
    return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
    };
}
exports.PacketId = {
    typeUrl: "/ibc.core.channel.v1.PacketId",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePacketId();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBasePacketId();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseAcknowledgement() {
    return {
        result: undefined,
        error: undefined
    };
}
exports.Acknowledgement = {
    typeUrl: "/ibc.core.channel.v1.Acknowledgement",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== undefined) writer.uint32(170).bytes(message.result);
        if (message.error !== undefined) writer.uint32(178).string(message.error);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 21:
                    message.result = reader.bytes();
                    break;
                case 22:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAcknowledgement();
        if ((0, helpers_1.isSet)(object.result)) obj.result = (0, helpers_1.bytesFromBase64)(object.result);
        if ((0, helpers_1.isSet)(object.error)) obj.error = String(object.error);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = message.result !== undefined ? (0, helpers_1.base64FromBytes)(message.result) : undefined);
        message.error !== undefined && (obj.error = message.error);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAcknowledgement();
        message.result = object.result ?? undefined;
        message.error = object.error ?? undefined;
        return message;
    }
};
function createBaseTimeout() {
    return {
        height: client_1.Height.fromPartial({}),
        timestamp: BigInt(0)
    };
}
exports.Timeout = {
    typeUrl: "/ibc.core.channel.v1.Timeout",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        if (message.timestamp !== BigInt(0)) writer.uint32(16).uint64(message.timestamp);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimeout();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTimeout();
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = BigInt(object.timestamp.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTimeout();
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = BigInt(object.timestamp.toString());
        return message;
    }
};
function createBaseParams() {
    return {
        upgradeTimeout: exports.Timeout.fromPartial({})
    };
}
exports.Params = {
    typeUrl: "/ibc.core.channel.v1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradeTimeout !== undefined) exports.Timeout.encode(message.upgradeTimeout, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.upgradeTimeout = exports.Timeout.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.upgradeTimeout)) obj.upgradeTimeout = exports.Timeout.fromJSON(object.upgradeTimeout);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.upgradeTimeout !== undefined && (obj.upgradeTimeout = message.upgradeTimeout ? exports.Timeout.toJSON(message.upgradeTimeout) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        if (object.upgradeTimeout !== undefined && object.upgradeTimeout !== null) message.upgradeTimeout = exports.Timeout.fromPartial(object.upgradeTimeout);
        return message;
    }
};

},{"f04282a1fdfd852f":"3w7CV","c924d6a858361b78":"bi36x","6cea181fb0d6f3a8":"eYjRL"}],"fZsk6":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorReceipt = exports.UpgradeFields = exports.Upgrade = exports.protobufPackage = void 0;
/* eslint-disable */ const channel_1 = require("b1698f3b979efb8d");
const binary_1 = require("800fa9afed6a62e8");
const helpers_1 = require("da8e39c3268bb41");
exports.protobufPackage = "ibc.core.channel.v1";
function createBaseUpgrade() {
    return {
        fields: exports.UpgradeFields.fromPartial({}),
        timeout: channel_1.Timeout.fromPartial({}),
        nextSequenceSend: BigInt(0)
    };
}
exports.Upgrade = {
    typeUrl: "/ibc.core.channel.v1.Upgrade",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.fields !== undefined) exports.UpgradeFields.encode(message.fields, writer.uint32(10).fork()).ldelim();
        if (message.timeout !== undefined) channel_1.Timeout.encode(message.timeout, writer.uint32(18).fork()).ldelim();
        if (message.nextSequenceSend !== BigInt(0)) writer.uint32(24).uint64(message.nextSequenceSend);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgrade();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fields = exports.UpgradeFields.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.timeout = channel_1.Timeout.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.nextSequenceSend = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseUpgrade();
        if ((0, helpers_1.isSet)(object.fields)) obj.fields = exports.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.timeout)) obj.timeout = channel_1.Timeout.fromJSON(object.timeout);
        if ((0, helpers_1.isSet)(object.nextSequenceSend)) obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.fields !== undefined && (obj.fields = message.fields ? exports.UpgradeFields.toJSON(message.fields) : undefined);
        message.timeout !== undefined && (obj.timeout = message.timeout ? channel_1.Timeout.toJSON(message.timeout) : undefined);
        message.nextSequenceSend !== undefined && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpgrade();
        if (object.fields !== undefined && object.fields !== null) message.fields = exports.UpgradeFields.fromPartial(object.fields);
        if (object.timeout !== undefined && object.timeout !== null) message.timeout = channel_1.Timeout.fromPartial(object.timeout);
        if (object.nextSequenceSend !== undefined && object.nextSequenceSend !== null) message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        return message;
    }
};
function createBaseUpgradeFields() {
    return {
        ordering: 0,
        connectionHops: [],
        version: ""
    };
}
exports.UpgradeFields = {
    typeUrl: "/ibc.core.channel.v1.UpgradeFields",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.ordering !== 0) writer.uint32(8).int32(message.ordering);
        for (const v of message.connectionHops)writer.uint32(18).string(v);
        if (message.version !== "") writer.uint32(26).string(message.version);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradeFields();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.ordering = reader.int32();
                    break;
                case 2:
                    message.connectionHops.push(reader.string());
                    break;
                case 3:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseUpgradeFields();
        if ((0, helpers_1.isSet)(object.ordering)) obj.ordering = (0, channel_1.orderFromJSON)(object.ordering);
        if (Array.isArray(object?.connectionHops)) obj.connectionHops = object.connectionHops.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.ordering !== undefined && (obj.ordering = (0, channel_1.orderToJSON)(message.ordering));
        if (message.connectionHops) obj.connectionHops = message.connectionHops.map((e)=>e);
        else obj.connectionHops = [];
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpgradeFields();
        message.ordering = object.ordering ?? 0;
        message.connectionHops = object.connectionHops?.map((e)=>e) || [];
        message.version = object.version ?? "";
        return message;
    }
};
function createBaseErrorReceipt() {
    return {
        sequence: BigInt(0),
        message: ""
    };
}
exports.ErrorReceipt = {
    typeUrl: "/ibc.core.channel.v1.ErrorReceipt",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) writer.uint32(8).uint64(message.sequence);
        if (message.message !== "") writer.uint32(18).string(message.message);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseErrorReceipt();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sequence = reader.uint64();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseErrorReceipt();
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.message)) obj.message = String(object.message);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseErrorReceipt();
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        message.message = object.message ?? "";
        return message;
    }
};

},{"b1698f3b979efb8d":"eujl6","800fa9afed6a62e8":"bi36x","da8e39c3268bb41":"eYjRL"}],"fnGx8":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgIBCSoftwareUpgradeResponse = exports.MsgIBCSoftwareUpgrade = exports.MsgRecoverClientResponse = exports.MsgRecoverClient = exports.MsgSubmitMisbehaviourResponse = exports.MsgSubmitMisbehaviour = exports.MsgUpgradeClientResponse = exports.MsgUpgradeClient = exports.MsgUpdateClientResponse = exports.MsgUpdateClient = exports.MsgCreateClientResponse = exports.MsgCreateClient = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("9827b790137a3556");
const upgrade_1 = require("8a1dddc3e4d493ad");
const client_1 = require("60bed7366947965b");
const binary_1 = require("53f4ebdd11cefbbd");
const helpers_1 = require("4972e9d0abf14960");
exports.protobufPackage = "ibc.core.client.v1";
function createBaseMsgCreateClient() {
    return {
        clientState: undefined,
        consensusState: undefined,
        signer: ""
    };
}
exports.MsgCreateClient = {
    typeUrl: "/ibc.core.client.v1.MsgCreateClient",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== undefined) any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        if (message.consensusState !== undefined) any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.consensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateClient();
        if ((0, helpers_1.isSet)(object.clientState)) obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState)) obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);
        message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateClient();
        if (object.clientState !== undefined && object.clientState !== null) message.clientState = any_1.Any.fromPartial(object.clientState);
        if (object.consensusState !== undefined && object.consensusState !== null) message.consensusState = any_1.Any.fromPartial(object.consensusState);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgCreateClientResponse() {
    return {};
}
exports.MsgCreateClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCreateClientResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCreateClientResponse();
        return message;
    }
};
function createBaseMsgUpdateClient() {
    return {
        clientId: "",
        clientMessage: undefined,
        signer: ""
    };
}
exports.MsgUpdateClient = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.clientMessage !== undefined) any_1.Any.encode(message.clientMessage, writer.uint32(18).fork()).ldelim();
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.clientMessage = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateClient();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientMessage)) obj.clientMessage = any_1.Any.fromJSON(object.clientMessage);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.clientMessage !== undefined && (obj.clientMessage = message.clientMessage ? any_1.Any.toJSON(message.clientMessage) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateClient();
        message.clientId = object.clientId ?? "";
        if (object.clientMessage !== undefined && object.clientMessage !== null) message.clientMessage = any_1.Any.fromPartial(object.clientMessage);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgUpdateClientResponse() {
    return {};
}
exports.MsgUpdateClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateClientResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
    }
};
function createBaseMsgUpgradeClient() {
    return {
        clientId: "",
        clientState: undefined,
        consensusState: undefined,
        proofUpgradeClient: new Uint8Array(),
        proofUpgradeConsensusState: new Uint8Array(),
        signer: ""
    };
}
exports.MsgUpgradeClient = {
    typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.clientState !== undefined) any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        if (message.consensusState !== undefined) any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        if (message.proofUpgradeClient.length !== 0) writer.uint32(34).bytes(message.proofUpgradeClient);
        if (message.proofUpgradeConsensusState.length !== 0) writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        if (message.signer !== "") writer.uint32(50).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.clientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.consensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.proofUpgradeClient = reader.bytes();
                    break;
                case 5:
                    message.proofUpgradeConsensusState = reader.bytes();
                    break;
                case 6:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpgradeClient();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState)) obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState)) obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proofUpgradeClient)) obj.proofUpgradeClient = (0, helpers_1.bytesFromBase64)(object.proofUpgradeClient);
        if ((0, helpers_1.isSet)(object.proofUpgradeConsensusState)) obj.proofUpgradeConsensusState = (0, helpers_1.bytesFromBase64)(object.proofUpgradeConsensusState);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);
        message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);
        message.proofUpgradeClient !== undefined && (obj.proofUpgradeClient = (0, helpers_1.base64FromBytes)(message.proofUpgradeClient !== undefined ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== undefined && (obj.proofUpgradeConsensusState = (0, helpers_1.base64FromBytes)(message.proofUpgradeConsensusState !== undefined ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpgradeClient();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== undefined && object.clientState !== null) message.clientState = any_1.Any.fromPartial(object.clientState);
        if (object.consensusState !== undefined && object.consensusState !== null) message.consensusState = any_1.Any.fromPartial(object.consensusState);
        message.proofUpgradeClient = object.proofUpgradeClient ?? new Uint8Array();
        message.proofUpgradeConsensusState = object.proofUpgradeConsensusState ?? new Uint8Array();
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgUpgradeClientResponse() {
    return {};
}
exports.MsgUpgradeClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpgradeClientResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
    }
};
function createBaseMsgSubmitMisbehaviour() {
    return {
        clientId: "",
        misbehaviour: undefined,
        signer: ""
    };
}
exports.MsgSubmitMisbehaviour = {
    typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.misbehaviour !== undefined) any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgSubmitMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.misbehaviour)) obj.misbehaviour = any_1.Any.fromJSON(object.misbehaviour);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.misbehaviour !== undefined && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgSubmitMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.misbehaviour !== undefined && object.misbehaviour !== null) message.misbehaviour = any_1.Any.fromPartial(object.misbehaviour);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgSubmitMisbehaviourResponse() {
    return {};
}
exports.MsgSubmitMisbehaviourResponse = {
    typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgSubmitMisbehaviourResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
    }
};
function createBaseMsgRecoverClient() {
    return {
        subjectClientId: "",
        substituteClientId: "",
        signer: ""
    };
}
exports.MsgRecoverClient = {
    typeUrl: "/ibc.core.client.v1.MsgRecoverClient",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.subjectClientId !== "") writer.uint32(10).string(message.subjectClientId);
        if (message.substituteClientId !== "") writer.uint32(18).string(message.substituteClientId);
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.subjectClientId = reader.string();
                    break;
                case 2:
                    message.substituteClientId = reader.string();
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgRecoverClient();
        if ((0, helpers_1.isSet)(object.subjectClientId)) obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId)) obj.substituteClientId = String(object.substituteClientId);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.subjectClientId !== undefined && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== undefined && (obj.substituteClientId = message.substituteClientId);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgRecoverClient();
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgRecoverClientResponse() {
    return {};
}
exports.MsgRecoverClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgRecoverClientResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgRecoverClientResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgRecoverClientResponse();
        return message;
    }
};
function createBaseMsgIBCSoftwareUpgrade() {
    return {
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: undefined,
        signer: ""
    };
}
exports.MsgIBCSoftwareUpgrade = {
    typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgrade",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.plan !== undefined) upgrade_1.Plan.encode(message.plan, writer.uint32(10).fork()).ldelim();
        if (message.upgradedClientState !== undefined) any_1.Any.encode(message.upgradedClientState, writer.uint32(18).fork()).ldelim();
        if (message.signer !== "") writer.uint32(26).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgrade();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgIBCSoftwareUpgrade();
        if ((0, helpers_1.isSet)(object.plan)) obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState)) obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.plan !== undefined && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : undefined);
        message.upgradedClientState !== undefined && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgIBCSoftwareUpgrade();
        if (object.plan !== undefined && object.plan !== null) message.plan = upgrade_1.Plan.fromPartial(object.plan);
        if (object.upgradedClientState !== undefined && object.upgradedClientState !== null) message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgIBCSoftwareUpgradeResponse() {
    return {};
}
exports.MsgIBCSoftwareUpgradeResponse = {
    typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgradeResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgIBCSoftwareUpgradeResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: client_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") writer.uint32(10).string(message.signer);
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
        this.RecoverClient = this.RecoverClient.bind(this);
        this.IBCSoftwareUpgrade = this.IBCSoftwareUpgrade.bind(this);
        this.UpdateClientParams = this.UpdateClientParams.bind(this);
    }
    CreateClient(request) {
        const data = exports.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data);
        return promise.then((data)=>exports.MsgCreateClientResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateClient(request) {
        const data = exports.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data);
        return promise.then((data)=>exports.MsgUpdateClientResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpgradeClient(request) {
        const data = exports.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data);
        return promise.then((data)=>exports.MsgUpgradeClientResponse.decode(new binary_1.BinaryReader(data)));
    }
    SubmitMisbehaviour(request) {
        const data = exports.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data);
        return promise.then((data)=>exports.MsgSubmitMisbehaviourResponse.decode(new binary_1.BinaryReader(data)));
    }
    RecoverClient(request) {
        const data = exports.MsgRecoverClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "RecoverClient", data);
        return promise.then((data)=>exports.MsgRecoverClientResponse.decode(new binary_1.BinaryReader(data)));
    }
    IBCSoftwareUpgrade(request) {
        const data = exports.MsgIBCSoftwareUpgrade.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "IBCSoftwareUpgrade", data);
        return promise.then((data)=>exports.MsgIBCSoftwareUpgradeResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateClientParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClientParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"9827b790137a3556":"56aJC","8a1dddc3e4d493ad":"54VJG","60bed7366947965b":"3w7CV","53f4ebdd11cefbbd":"bi36x","4972e9d0abf14960":"eYjRL"}],"gQgE7":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;
/* eslint-disable */ const connection_1 = require("dfd61643a8832f5e");
const any_1 = require("66d197a011111920");
const client_1 = require("53df54e23c68beeb");
const binary_1 = require("219cd94098d18216");
const helpers_1 = require("20b254046b6cc3f2");
exports.protobufPackage = "ibc.core.connection.v1";
function createBaseMsgConnectionOpenInit() {
    return {
        clientId: "",
        counterparty: connection_1.Counterparty.fromPartial({}),
        version: undefined,
        delayPeriod: BigInt(0),
        signer: ""
    };
}
exports.MsgConnectionOpenInit = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.counterparty !== undefined) connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        if (message.version !== undefined) connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        if (message.delayPeriod !== BigInt(0)) writer.uint32(32).uint64(message.delayPeriod);
        if (message.signer !== "") writer.uint32(42).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.version = connection_1.Version.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.delayPeriod = reader.uint64();
                    break;
                case 5:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgConnectionOpenInit();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.counterparty)) obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.version)) obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.delayPeriod)) obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.counterparty !== undefined && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);
        message.version !== undefined && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);
        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgConnectionOpenInit();
        message.clientId = object.clientId ?? "";
        if (object.counterparty !== undefined && object.counterparty !== null) message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        if (object.version !== undefined && object.version !== null) message.version = connection_1.Version.fromPartial(object.version);
        if (object.delayPeriod !== undefined && object.delayPeriod !== null) message.delayPeriod = BigInt(object.delayPeriod.toString());
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgConnectionOpenInitResponse() {
    return {};
}
exports.MsgConnectionOpenInitResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgConnectionOpenInitResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
    }
};
function createBaseMsgConnectionOpenTry() {
    return {
        clientId: "",
        previousConnectionId: "",
        clientState: undefined,
        counterparty: connection_1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0),
        counterpartyVersions: [],
        proofHeight: client_1.Height.fromPartial({}),
        proofInit: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
    };
}
exports.MsgConnectionOpenTry = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.previousConnectionId !== "") writer.uint32(18).string(message.previousConnectionId);
        if (message.clientState !== undefined) any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        if (message.counterparty !== undefined) connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        if (message.delayPeriod !== BigInt(0)) writer.uint32(40).uint64(message.delayPeriod);
        for (const v of message.counterpartyVersions)connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        if (message.proofInit.length !== 0) writer.uint32(66).bytes(message.proofInit);
        if (message.proofClient.length !== 0) writer.uint32(74).bytes(message.proofClient);
        if (message.proofConsensus.length !== 0) writer.uint32(82).bytes(message.proofConsensus);
        if (message.consensusHeight !== undefined) client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        if (message.signer !== "") writer.uint32(98).string(message.signer);
        if (message.hostConsensusStateProof.length !== 0) writer.uint32(106).bytes(message.hostConsensusStateProof);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.previousConnectionId = reader.string();
                    break;
                case 3:
                    message.clientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.delayPeriod = reader.uint64();
                    break;
                case 6:
                    message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.proofInit = reader.bytes();
                    break;
                case 9:
                    message.proofClient = reader.bytes();
                    break;
                case 10:
                    message.proofConsensus = reader.bytes();
                    break;
                case 11:
                    message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.signer = reader.string();
                    break;
                case 13:
                    message.hostConsensusStateProof = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgConnectionOpenTry();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.previousConnectionId)) obj.previousConnectionId = String(object.previousConnectionId);
        if ((0, helpers_1.isSet)(object.clientState)) obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.counterparty)) obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod)) obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if (Array.isArray(object?.counterpartyVersions)) obj.counterpartyVersions = object.counterpartyVersions.map((e)=>connection_1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofInit)) obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofClient)) obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus)) obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight)) obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof)) obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.previousConnectionId !== undefined && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);
        message.counterparty !== undefined && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);
        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        if (message.counterpartyVersions) obj.counterpartyVersions = message.counterpartyVersions.map((e)=>e ? connection_1.Version.toJSON(e) : undefined);
        else obj.counterpartyVersions = [];
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.proofInit !== undefined && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));
        message.proofClient !== undefined && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== undefined && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== undefined && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        message.hostConsensusStateProof !== undefined && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== undefined ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgConnectionOpenTry();
        message.clientId = object.clientId ?? "";
        message.previousConnectionId = object.previousConnectionId ?? "";
        if (object.clientState !== undefined && object.clientState !== null) message.clientState = any_1.Any.fromPartial(object.clientState);
        if (object.counterparty !== undefined && object.counterparty !== null) message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        if (object.delayPeriod !== undefined && object.delayPeriod !== null) message.delayPeriod = BigInt(object.delayPeriod.toString());
        message.counterpartyVersions = object.counterpartyVersions?.map((e)=>connection_1.Version.fromPartial(e)) || [];
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.proofInit = object.proofInit ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== undefined && object.consensusHeight !== null) message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
    }
};
function createBaseMsgConnectionOpenTryResponse() {
    return {};
}
exports.MsgConnectionOpenTryResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgConnectionOpenTryResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
    }
};
function createBaseMsgConnectionOpenAck() {
    return {
        connectionId: "",
        counterpartyConnectionId: "",
        version: undefined,
        clientState: undefined,
        proofHeight: client_1.Height.fromPartial({}),
        proofTry: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
    };
}
exports.MsgConnectionOpenAck = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") writer.uint32(10).string(message.connectionId);
        if (message.counterpartyConnectionId !== "") writer.uint32(18).string(message.counterpartyConnectionId);
        if (message.version !== undefined) connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        if (message.clientState !== undefined) any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        if (message.proofTry.length !== 0) writer.uint32(50).bytes(message.proofTry);
        if (message.proofClient.length !== 0) writer.uint32(58).bytes(message.proofClient);
        if (message.proofConsensus.length !== 0) writer.uint32(66).bytes(message.proofConsensus);
        if (message.consensusHeight !== undefined) client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        if (message.signer !== "") writer.uint32(82).string(message.signer);
        if (message.hostConsensusStateProof.length !== 0) writer.uint32(90).bytes(message.hostConsensusStateProof);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connectionId = reader.string();
                    break;
                case 2:
                    message.counterpartyConnectionId = reader.string();
                    break;
                case 3:
                    message.version = connection_1.Version.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.proofTry = reader.bytes();
                    break;
                case 7:
                    message.proofClient = reader.bytes();
                    break;
                case 8:
                    message.proofConsensus = reader.bytes();
                    break;
                case 9:
                    message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.signer = reader.string();
                    break;
                case 11:
                    message.hostConsensusStateProof = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgConnectionOpenAck();
        if ((0, helpers_1.isSet)(object.connectionId)) obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.counterpartyConnectionId)) obj.counterpartyConnectionId = String(object.counterpartyConnectionId);
        if ((0, helpers_1.isSet)(object.version)) obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.clientState)) obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofTry)) obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofClient)) obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus)) obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight)) obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof)) obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== undefined && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== undefined && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);
        message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.proofTry !== undefined && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));
        message.proofClient !== undefined && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== undefined && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== undefined && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        message.hostConsensusStateProof !== undefined && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== undefined ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgConnectionOpenAck();
        message.connectionId = object.connectionId ?? "";
        message.counterpartyConnectionId = object.counterpartyConnectionId ?? "";
        if (object.version !== undefined && object.version !== null) message.version = connection_1.Version.fromPartial(object.version);
        if (object.clientState !== undefined && object.clientState !== null) message.clientState = any_1.Any.fromPartial(object.clientState);
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.proofTry = object.proofTry ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== undefined && object.consensusHeight !== null) message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
    }
};
function createBaseMsgConnectionOpenAckResponse() {
    return {};
}
exports.MsgConnectionOpenAckResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgConnectionOpenAckResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
    }
};
function createBaseMsgConnectionOpenConfirm() {
    return {
        connectionId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
    };
}
exports.MsgConnectionOpenConfirm = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") writer.uint32(10).string(message.connectionId);
        if (message.proofAck.length !== 0) writer.uint32(18).bytes(message.proofAck);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        if (message.signer !== "") writer.uint32(34).string(message.signer);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connectionId = reader.string();
                    break;
                case 2:
                    message.proofAck = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgConnectionOpenConfirm();
        if ((0, helpers_1.isSet)(object.connectionId)) obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.proofAck)) obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        message.proofAck !== undefined && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.signer !== undefined && (obj.signer = message.signer);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgConnectionOpenConfirm();
        message.connectionId = object.connectionId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        message.signer = object.signer ?? "";
        return message;
    }
};
function createBaseMsgConnectionOpenConfirmResponse() {
    return {};
}
exports.MsgConnectionOpenConfirmResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgConnectionOpenConfirmResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: client_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/ibc.core.connection.v1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") writer.uint32(10).string(message.signer);
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer)) obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
        this.UpdateConnectionParams = this.UpdateConnectionParams.bind(this);
    }
    ConnectionOpenInit(request) {
        const data = exports.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data);
        return promise.then((data)=>exports.MsgConnectionOpenInitResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionOpenTry(request) {
        const data = exports.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data);
        return promise.then((data)=>exports.MsgConnectionOpenTryResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionOpenAck(request) {
        const data = exports.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data);
        return promise.then((data)=>exports.MsgConnectionOpenAckResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionOpenConfirm(request) {
        const data = exports.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data);
        return promise.then((data)=>exports.MsgConnectionOpenConfirmResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateConnectionParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "UpdateConnectionParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"dfd61643a8832f5e":"2q35I","66d197a011111920":"56aJC","53df54e23c68beeb":"3w7CV","219cd94098d18216":"bi36x","20b254046b6cc3f2":"eYjRL"}],"2q35I":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
/* eslint-disable */ const commitment_1 = require("ff1107c48d7b6ffb");
const binary_1 = require("fe2a36e460bc6d2a");
const helpers_1 = require("6aca78dc2067d45d");
exports.protobufPackage = "ibc.core.connection.v1";
/**
 * State defines if a connection is in one of the following states:
 * INIT, TRYOPEN, OPEN or UNINITIALIZED.
 */ var State;
(function(State) {
    /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */ State[State["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
    /** STATE_INIT - A connection end has just started the opening handshake. */ State[State["STATE_INIT"] = 1] = "STATE_INIT";
    /**
     * STATE_TRYOPEN - A connection end has acknowledged the handshake step on the counterparty
     * chain.
     */ State[State["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
    /** STATE_OPEN - A connection end has completed the handshake. */ State[State["STATE_OPEN"] = 3] = "STATE_OPEN";
    State[State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(State || (exports.State = State = {}));
function stateFromJSON(object) {
    switch(object){
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
            return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
            return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
            return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
            return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return State.UNRECOGNIZED;
    }
}
exports.stateFromJSON = stateFromJSON;
function stateToJSON(object) {
    switch(object){
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
            return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
            return "STATE_INIT";
        case State.STATE_TRYOPEN:
            return "STATE_TRYOPEN";
        case State.STATE_OPEN:
            return "STATE_OPEN";
        case State.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.stateToJSON = stateToJSON;
function createBaseConnectionEnd() {
    return {
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
    };
}
exports.ConnectionEnd = {
    typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        for (const v of message.versions)exports.Version.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.state !== 0) writer.uint32(24).int32(message.state);
        if (message.counterparty !== undefined) exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        if (message.delayPeriod !== BigInt(0)) writer.uint32(40).uint64(message.delayPeriod);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.versions.push(exports.Version.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.delayPeriod = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseConnectionEnd();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if (Array.isArray(object?.versions)) obj.versions = object.versions.map((e)=>exports.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state)) obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty)) obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod)) obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        if (message.versions) obj.versions = message.versions.map((e)=>e ? exports.Version.toJSON(e) : undefined);
        else obj.versions = [];
        message.state !== undefined && (obj.state = stateToJSON(message.state));
        message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);
        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseConnectionEnd();
        message.clientId = object.clientId ?? "";
        message.versions = object.versions?.map((e)=>exports.Version.fromPartial(e)) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== undefined && object.counterparty !== null) message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        if (object.delayPeriod !== undefined && object.delayPeriod !== null) message.delayPeriod = BigInt(object.delayPeriod.toString());
        return message;
    }
};
function createBaseIdentifiedConnection() {
    return {
        id: "",
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
    };
}
exports.IdentifiedConnection = {
    typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== "") writer.uint32(10).string(message.id);
        if (message.clientId !== "") writer.uint32(18).string(message.clientId);
        for (const v of message.versions)exports.Version.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.state !== 0) writer.uint32(32).int32(message.state);
        if (message.counterparty !== undefined) exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        if (message.delayPeriod !== BigInt(0)) writer.uint32(48).uint64(message.delayPeriod);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.clientId = reader.string();
                    break;
                case 3:
                    message.versions.push(exports.Version.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.state = reader.int32();
                    break;
                case 5:
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.delayPeriod = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseIdentifiedConnection();
        if ((0, helpers_1.isSet)(object.id)) obj.id = String(object.id);
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if (Array.isArray(object?.versions)) obj.versions = object.versions.map((e)=>exports.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state)) obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty)) obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod)) obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.clientId !== undefined && (obj.clientId = message.clientId);
        if (message.versions) obj.versions = message.versions.map((e)=>e ? exports.Version.toJSON(e) : undefined);
        else obj.versions = [];
        message.state !== undefined && (obj.state = stateToJSON(message.state));
        message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);
        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseIdentifiedConnection();
        message.id = object.id ?? "";
        message.clientId = object.clientId ?? "";
        message.versions = object.versions?.map((e)=>exports.Version.fromPartial(e)) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== undefined && object.counterparty !== null) message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        if (object.delayPeriod !== undefined && object.delayPeriod !== null) message.delayPeriod = BigInt(object.delayPeriod.toString());
        return message;
    }
};
function createBaseCounterparty() {
    return {
        clientId: "",
        connectionId: "",
        prefix: commitment_1.MerklePrefix.fromPartial({})
    };
}
exports.Counterparty = {
    typeUrl: "/ibc.core.connection.v1.Counterparty",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.connectionId !== "") writer.uint32(18).string(message.connectionId);
        if (message.prefix !== undefined) commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.connectionId = reader.string();
                    break;
                case 3:
                    message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.connectionId)) obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.prefix)) obj.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        message.prefix !== undefined && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCounterparty();
        message.clientId = object.clientId ?? "";
        message.connectionId = object.connectionId ?? "";
        if (object.prefix !== undefined && object.prefix !== null) message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);
        return message;
    }
};
function createBaseClientPaths() {
    return {
        paths: []
    };
}
exports.ClientPaths = {
    typeUrl: "/ibc.core.connection.v1.ClientPaths",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.paths)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.paths.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseClientPaths();
        if (Array.isArray(object?.paths)) obj.paths = object.paths.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.paths) obj.paths = message.paths.map((e)=>e);
        else obj.paths = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseClientPaths();
        message.paths = object.paths?.map((e)=>e) || [];
        return message;
    }
};
function createBaseConnectionPaths() {
    return {
        clientId: "",
        paths: []
    };
}
exports.ConnectionPaths = {
    typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        for (const v of message.paths)writer.uint32(18).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.paths.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseConnectionPaths();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if (Array.isArray(object?.paths)) obj.paths = object.paths.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        if (message.paths) obj.paths = message.paths.map((e)=>e);
        else obj.paths = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseConnectionPaths();
        message.clientId = object.clientId ?? "";
        message.paths = object.paths?.map((e)=>e) || [];
        return message;
    }
};
function createBaseVersion() {
    return {
        identifier: "",
        features: []
    };
}
exports.Version = {
    typeUrl: "/ibc.core.connection.v1.Version",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifier !== "") writer.uint32(10).string(message.identifier);
        for (const v of message.features)writer.uint32(18).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identifier = reader.string();
                    break;
                case 2:
                    message.features.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVersion();
        if ((0, helpers_1.isSet)(object.identifier)) obj.identifier = String(object.identifier);
        if (Array.isArray(object?.features)) obj.features = object.features.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.identifier !== undefined && (obj.identifier = message.identifier);
        if (message.features) obj.features = message.features.map((e)=>e);
        else obj.features = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVersion();
        message.identifier = object.identifier ?? "";
        message.features = object.features?.map((e)=>e) || [];
        return message;
    }
};
function createBaseParams() {
    return {
        maxExpectedTimePerBlock: BigInt(0)
    };
}
exports.Params = {
    typeUrl: "/ibc.core.connection.v1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxExpectedTimePerBlock !== BigInt(0)) writer.uint32(8).uint64(message.maxExpectedTimePerBlock);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.maxExpectedTimePerBlock = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxExpectedTimePerBlock)) obj.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.maxExpectedTimePerBlock !== undefined && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        if (object.maxExpectedTimePerBlock !== undefined && object.maxExpectedTimePerBlock !== null) message.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        return message;
    }
};

},{"ff1107c48d7b6ffb":"iMPyZ","fe2a36e460bc6d2a":"bi36x","6aca78dc2067d45d":"eYjRL"}],"iMPyZ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MerkleProof = exports.MerklePath = exports.MerklePrefix = exports.MerkleRoot = exports.protobufPackage = void 0;
/* eslint-disable */ const proofs_1 = require("1fe8529c0cae0e85");
const binary_1 = require("92471ee51e9d03ad");
const helpers_1 = require("86f85a0d8013c1d7");
exports.protobufPackage = "ibc.core.commitment.v1";
function createBaseMerkleRoot() {
    return {
        hash: new Uint8Array()
    };
}
exports.MerkleRoot = {
    typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) writer.uint32(10).bytes(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMerkleRoot();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMerkleRoot();
        message.hash = object.hash ?? new Uint8Array();
        return message;
    }
};
function createBaseMerklePrefix() {
    return {
        keyPrefix: new Uint8Array()
    };
}
exports.MerklePrefix = {
    typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.keyPrefix.length !== 0) writer.uint32(10).bytes(message.keyPrefix);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPrefix = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMerklePrefix();
        if ((0, helpers_1.isSet)(object.keyPrefix)) obj.keyPrefix = (0, helpers_1.bytesFromBase64)(object.keyPrefix);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.keyPrefix !== undefined && (obj.keyPrefix = (0, helpers_1.base64FromBytes)(message.keyPrefix !== undefined ? message.keyPrefix : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMerklePrefix();
        message.keyPrefix = object.keyPrefix ?? new Uint8Array();
        return message;
    }
};
function createBaseMerklePath() {
    return {
        keyPath: []
    };
}
exports.MerklePath = {
    typeUrl: "/ibc.core.commitment.v1.MerklePath",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.keyPath)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPath.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMerklePath();
        if (Array.isArray(object?.keyPath)) obj.keyPath = object.keyPath.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.keyPath) obj.keyPath = message.keyPath.map((e)=>e);
        else obj.keyPath = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMerklePath();
        message.keyPath = object.keyPath?.map((e)=>e) || [];
        return message;
    }
};
function createBaseMerkleProof() {
    return {
        proofs: []
    };
}
exports.MerkleProof = {
    typeUrl: "/ibc.core.commitment.v1.MerkleProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proofs)proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMerkleProof();
        if (Array.isArray(object?.proofs)) obj.proofs = object.proofs.map((e)=>proofs_1.CommitmentProof.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.proofs) obj.proofs = message.proofs.map((e)=>e ? proofs_1.CommitmentProof.toJSON(e) : undefined);
        else obj.proofs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMerkleProof();
        message.proofs = object.proofs?.map((e)=>proofs_1.CommitmentProof.fromPartial(e)) || [];
        return message;
    }
};

},{"1fe8529c0cae0e85":"3OFfD","92471ee51e9d03ad":"bi36x","86f85a0d8013c1d7":"eYjRL"}],"3OFfD":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("4a984558aa9088ba");
const helpers_1 = require("37df7708beb2546");
exports.protobufPackage = "cosmos.ics23.v1";
var HashOp;
(function(HashOp) {
    /** NO_HASH - NO_HASH is the default if no data passed. Note this is an illegal argument some places. */ HashOp[HashOp["NO_HASH"] = 0] = "NO_HASH";
    HashOp[HashOp["SHA256"] = 1] = "SHA256";
    HashOp[HashOp["SHA512"] = 2] = "SHA512";
    HashOp[HashOp["KECCAK"] = 3] = "KECCAK";
    HashOp[HashOp["RIPEMD160"] = 4] = "RIPEMD160";
    /** BITCOIN - ripemd160(sha256(x)) */ HashOp[HashOp["BITCOIN"] = 5] = "BITCOIN";
    HashOp[HashOp["SHA512_256"] = 6] = "SHA512_256";
    HashOp[HashOp["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HashOp || (exports.HashOp = HashOp = {}));
function hashOpFromJSON(object) {
    switch(object){
        case 0:
        case "NO_HASH":
            return HashOp.NO_HASH;
        case 1:
        case "SHA256":
            return HashOp.SHA256;
        case 2:
        case "SHA512":
            return HashOp.SHA512;
        case 3:
        case "KECCAK":
            return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
            return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
            return HashOp.BITCOIN;
        case 6:
        case "SHA512_256":
            return HashOp.SHA512_256;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HashOp.UNRECOGNIZED;
    }
}
exports.hashOpFromJSON = hashOpFromJSON;
function hashOpToJSON(object) {
    switch(object){
        case HashOp.NO_HASH:
            return "NO_HASH";
        case HashOp.SHA256:
            return "SHA256";
        case HashOp.SHA512:
            return "SHA512";
        case HashOp.KECCAK:
            return "KECCAK";
        case HashOp.RIPEMD160:
            return "RIPEMD160";
        case HashOp.BITCOIN:
            return "BITCOIN";
        case HashOp.SHA512_256:
            return "SHA512_256";
        case HashOp.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.hashOpToJSON = hashOpToJSON;
/**
 * LengthOp defines how to process the key and value of the LeafOp
 * to include length information. After encoding the length with the given
 * algorithm, the length will be prepended to the key and value bytes.
 * (Each one with it's own encoded length)
 */ var LengthOp;
(function(LengthOp) {
    /** NO_PREFIX - NO_PREFIX don't include any length info */ LengthOp[LengthOp["NO_PREFIX"] = 0] = "NO_PREFIX";
    /** VAR_PROTO - VAR_PROTO uses protobuf (and go-amino) varint encoding of the length */ LengthOp[LengthOp["VAR_PROTO"] = 1] = "VAR_PROTO";
    /** VAR_RLP - VAR_RLP uses rlp int encoding of the length */ LengthOp[LengthOp["VAR_RLP"] = 2] = "VAR_RLP";
    /** FIXED32_BIG - FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer */ LengthOp[LengthOp["FIXED32_BIG"] = 3] = "FIXED32_BIG";
    /** FIXED32_LITTLE - FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer */ LengthOp[LengthOp["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
    /** FIXED64_BIG - FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer */ LengthOp[LengthOp["FIXED64_BIG"] = 5] = "FIXED64_BIG";
    /** FIXED64_LITTLE - FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer */ LengthOp[LengthOp["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
    /** REQUIRE_32_BYTES - REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output) */ LengthOp[LengthOp["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
    /** REQUIRE_64_BYTES - REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output) */ LengthOp[LengthOp["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
    LengthOp[LengthOp["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LengthOp || (exports.LengthOp = LengthOp = {}));
function lengthOpFromJSON(object) {
    switch(object){
        case 0:
        case "NO_PREFIX":
            return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
            return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
            return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
            return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
            return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
            return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
            return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
            return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
            return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
            return LengthOp.UNRECOGNIZED;
    }
}
exports.lengthOpFromJSON = lengthOpFromJSON;
function lengthOpToJSON(object) {
    switch(object){
        case LengthOp.NO_PREFIX:
            return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
            return "VAR_PROTO";
        case LengthOp.VAR_RLP:
            return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
            return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
            return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
            return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
            return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
            return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
            return "REQUIRE_64_BYTES";
        case LengthOp.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.lengthOpToJSON = lengthOpToJSON;
function createBaseExistenceProof() {
    return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: undefined,
        path: []
    };
}
exports.ExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.ExistenceProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        if (message.value.length !== 0) writer.uint32(18).bytes(message.value);
        if (message.leaf !== undefined) exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        for (const v of message.path)exports.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExistenceProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                case 3:
                    message.leaf = exports.LeafOp.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.path.push(exports.InnerOp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseExistenceProof();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value)) obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf)) obj.leaf = exports.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object?.path)) obj.path = object.path.map((e)=>exports.InnerOp.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        message.leaf !== undefined && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);
        if (message.path) obj.path = message.path.map((e)=>e ? exports.InnerOp.toJSON(e) : undefined);
        else obj.path = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== undefined && object.leaf !== null) message.leaf = exports.LeafOp.fromPartial(object.leaf);
        message.path = object.path?.map((e)=>exports.InnerOp.fromPartial(e)) || [];
        return message;
    }
};
function createBaseNonExistenceProof() {
    return {
        key: new Uint8Array(),
        left: undefined,
        right: undefined
    };
}
exports.NonExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        if (message.left !== undefined) exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        if (message.right !== undefined) exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNonExistenceProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.left = exports.ExistenceProof.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.right = exports.ExistenceProof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left)) obj.left = exports.ExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right)) obj.right = exports.ExistenceProof.fromJSON(object.right);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.left !== undefined && (obj.left = message.left ? exports.ExistenceProof.toJSON(message.left) : undefined);
        message.right !== undefined && (obj.right = message.right ? exports.ExistenceProof.toJSON(message.right) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== undefined && object.left !== null) message.left = exports.ExistenceProof.fromPartial(object.left);
        if (object.right !== undefined && object.right !== null) message.right = exports.ExistenceProof.fromPartial(object.right);
        return message;
    }
};
function createBaseCommitmentProof() {
    return {
        exist: undefined,
        nonexist: undefined,
        batch: undefined,
        compressed: undefined
    };
}
exports.CommitmentProof = {
    typeUrl: "/cosmos.ics23.v1.CommitmentProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== undefined) exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        if (message.nonexist !== undefined) exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        if (message.batch !== undefined) exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        if (message.compressed !== undefined) exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommitmentProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.batch = exports.BatchProof.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommitmentProof();
        if ((0, helpers_1.isSet)(object.exist)) obj.exist = exports.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist)) obj.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);
        if ((0, helpers_1.isSet)(object.batch)) obj.batch = exports.BatchProof.fromJSON(object.batch);
        if ((0, helpers_1.isSet)(object.compressed)) obj.compressed = exports.CompressedBatchProof.fromJSON(object.compressed);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.exist !== undefined && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : undefined);
        message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : undefined);
        message.batch !== undefined && (obj.batch = message.batch ? exports.BatchProof.toJSON(message.batch) : undefined);
        message.compressed !== undefined && (obj.compressed = message.compressed ? exports.CompressedBatchProof.toJSON(message.compressed) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommitmentProof();
        if (object.exist !== undefined && object.exist !== null) message.exist = exports.ExistenceProof.fromPartial(object.exist);
        if (object.nonexist !== undefined && object.nonexist !== null) message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);
        if (object.batch !== undefined && object.batch !== null) message.batch = exports.BatchProof.fromPartial(object.batch);
        if (object.compressed !== undefined && object.compressed !== null) message.compressed = exports.CompressedBatchProof.fromPartial(object.compressed);
        return message;
    }
};
function createBaseLeafOp() {
    return {
        hash: 0,
        prehashKey: 0,
        prehashValue: 0,
        length: 0,
        prefix: new Uint8Array()
    };
}
exports.LeafOp = {
    typeUrl: "/cosmos.ics23.v1.LeafOp",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) writer.uint32(8).int32(message.hash);
        if (message.prehashKey !== 0) writer.uint32(16).int32(message.prehashKey);
        if (message.prehashValue !== 0) writer.uint32(24).int32(message.prehashValue);
        if (message.length !== 0) writer.uint32(32).int32(message.length);
        if (message.prefix.length !== 0) writer.uint32(42).bytes(message.prefix);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeafOp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.int32();
                    break;
                case 2:
                    message.prehashKey = reader.int32();
                    break;
                case 3:
                    message.prehashValue = reader.int32();
                    break;
                case 4:
                    message.length = reader.int32();
                    break;
                case 5:
                    message.prefix = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseLeafOp();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prehashKey)) obj.prehashKey = hashOpFromJSON(object.prehashKey);
        if ((0, helpers_1.isSet)(object.prehashValue)) obj.prehashValue = hashOpFromJSON(object.prehashValue);
        if ((0, helpers_1.isSet)(object.length)) obj.length = lengthOpFromJSON(object.length);
        if ((0, helpers_1.isSet)(object.prefix)) obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== undefined && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== undefined && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== undefined && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== undefined && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== undefined ? message.prefix : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseLeafOp();
        message.hash = object.hash ?? 0;
        message.prehashKey = object.prehashKey ?? 0;
        message.prehashValue = object.prehashValue ?? 0;
        message.length = object.length ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        return message;
    }
};
function createBaseInnerOp() {
    return {
        hash: 0,
        prefix: new Uint8Array(),
        suffix: new Uint8Array()
    };
}
exports.InnerOp = {
    typeUrl: "/cosmos.ics23.v1.InnerOp",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) writer.uint32(8).int32(message.hash);
        if (message.prefix.length !== 0) writer.uint32(18).bytes(message.prefix);
        if (message.suffix.length !== 0) writer.uint32(26).bytes(message.suffix);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInnerOp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.int32();
                    break;
                case 2:
                    message.prefix = reader.bytes();
                    break;
                case 3:
                    message.suffix = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseInnerOp();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prefix)) obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        if ((0, helpers_1.isSet)(object.suffix)) obj.suffix = (0, helpers_1.bytesFromBase64)(object.suffix);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== undefined && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== undefined ? message.prefix : new Uint8Array()));
        message.suffix !== undefined && (obj.suffix = (0, helpers_1.base64FromBytes)(message.suffix !== undefined ? message.suffix : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseInnerOp();
        message.hash = object.hash ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        message.suffix = object.suffix ?? new Uint8Array();
        return message;
    }
};
function createBaseProofSpec() {
    return {
        leafSpec: undefined,
        innerSpec: undefined,
        maxDepth: 0,
        minDepth: 0
    };
}
exports.ProofSpec = {
    typeUrl: "/cosmos.ics23.v1.ProofSpec",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.leafSpec !== undefined) exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        if (message.innerSpec !== undefined) exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        if (message.maxDepth !== 0) writer.uint32(24).int32(message.maxDepth);
        if (message.minDepth !== 0) writer.uint32(32).int32(message.minDepth);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProofSpec();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.maxDepth = reader.int32();
                    break;
                case 4:
                    message.minDepth = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProofSpec();
        if ((0, helpers_1.isSet)(object.leafSpec)) obj.leafSpec = exports.LeafOp.fromJSON(object.leafSpec);
        if ((0, helpers_1.isSet)(object.innerSpec)) obj.innerSpec = exports.InnerSpec.fromJSON(object.innerSpec);
        if ((0, helpers_1.isSet)(object.maxDepth)) obj.maxDepth = Number(object.maxDepth);
        if ((0, helpers_1.isSet)(object.minDepth)) obj.minDepth = Number(object.minDepth);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.leafSpec !== undefined && (obj.leafSpec = message.leafSpec ? exports.LeafOp.toJSON(message.leafSpec) : undefined);
        message.innerSpec !== undefined && (obj.innerSpec = message.innerSpec ? exports.InnerSpec.toJSON(message.innerSpec) : undefined);
        message.maxDepth !== undefined && (obj.maxDepth = Math.round(message.maxDepth));
        message.minDepth !== undefined && (obj.minDepth = Math.round(message.minDepth));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProofSpec();
        if (object.leafSpec !== undefined && object.leafSpec !== null) message.leafSpec = exports.LeafOp.fromPartial(object.leafSpec);
        if (object.innerSpec !== undefined && object.innerSpec !== null) message.innerSpec = exports.InnerSpec.fromPartial(object.innerSpec);
        message.maxDepth = object.maxDepth ?? 0;
        message.minDepth = object.minDepth ?? 0;
        return message;
    }
};
function createBaseInnerSpec() {
    return {
        childOrder: [],
        childSize: 0,
        minPrefixLength: 0,
        maxPrefixLength: 0,
        emptyChild: new Uint8Array(),
        hash: 0
    };
}
exports.InnerSpec = {
    typeUrl: "/cosmos.ics23.v1.InnerSpec",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.childOrder)writer.int32(v);
        writer.ldelim();
        if (message.childSize !== 0) writer.uint32(16).int32(message.childSize);
        if (message.minPrefixLength !== 0) writer.uint32(24).int32(message.minPrefixLength);
        if (message.maxPrefixLength !== 0) writer.uint32(32).int32(message.maxPrefixLength);
        if (message.emptyChild.length !== 0) writer.uint32(42).bytes(message.emptyChild);
        if (message.hash !== 0) writer.uint32(48).int32(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInnerSpec();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.childOrder.push(reader.int32());
                    } else message.childOrder.push(reader.int32());
                    break;
                case 2:
                    message.childSize = reader.int32();
                    break;
                case 3:
                    message.minPrefixLength = reader.int32();
                    break;
                case 4:
                    message.maxPrefixLength = reader.int32();
                    break;
                case 5:
                    message.emptyChild = reader.bytes();
                    break;
                case 6:
                    message.hash = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseInnerSpec();
        if (Array.isArray(object?.childOrder)) obj.childOrder = object.childOrder.map((e)=>Number(e));
        if ((0, helpers_1.isSet)(object.childSize)) obj.childSize = Number(object.childSize);
        if ((0, helpers_1.isSet)(object.minPrefixLength)) obj.minPrefixLength = Number(object.minPrefixLength);
        if ((0, helpers_1.isSet)(object.maxPrefixLength)) obj.maxPrefixLength = Number(object.maxPrefixLength);
        if ((0, helpers_1.isSet)(object.emptyChild)) obj.emptyChild = (0, helpers_1.bytesFromBase64)(object.emptyChild);
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = hashOpFromJSON(object.hash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.childOrder) obj.childOrder = message.childOrder.map((e)=>Math.round(e));
        else obj.childOrder = [];
        message.childSize !== undefined && (obj.childSize = Math.round(message.childSize));
        message.minPrefixLength !== undefined && (obj.minPrefixLength = Math.round(message.minPrefixLength));
        message.maxPrefixLength !== undefined && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));
        message.emptyChild !== undefined && (obj.emptyChild = (0, helpers_1.base64FromBytes)(message.emptyChild !== undefined ? message.emptyChild : new Uint8Array()));
        message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseInnerSpec();
        message.childOrder = object.childOrder?.map((e)=>e) || [];
        message.childSize = object.childSize ?? 0;
        message.minPrefixLength = object.minPrefixLength ?? 0;
        message.maxPrefixLength = object.maxPrefixLength ?? 0;
        message.emptyChild = object.emptyChild ?? new Uint8Array();
        message.hash = object.hash ?? 0;
        return message;
    }
};
function createBaseBatchProof() {
    return {
        entries: []
    };
}
exports.BatchProof = {
    typeUrl: "/cosmos.ics23.v1.BatchProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries)exports.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBatchProof();
        if (Array.isArray(object?.entries)) obj.entries = object.entries.map((e)=>exports.BatchEntry.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.entries) obj.entries = message.entries.map((e)=>e ? exports.BatchEntry.toJSON(e) : undefined);
        else obj.entries = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBatchProof();
        message.entries = object.entries?.map((e)=>exports.BatchEntry.fromPartial(e)) || [];
        return message;
    }
};
function createBaseBatchEntry() {
    return {
        exist: undefined,
        nonexist: undefined
    };
}
exports.BatchEntry = {
    typeUrl: "/cosmos.ics23.v1.BatchEntry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== undefined) exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        if (message.nonexist !== undefined) exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBatchEntry();
        if ((0, helpers_1.isSet)(object.exist)) obj.exist = exports.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist)) obj.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.exist !== undefined && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : undefined);
        message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBatchEntry();
        if (object.exist !== undefined && object.exist !== null) message.exist = exports.ExistenceProof.fromPartial(object.exist);
        if (object.nonexist !== undefined && object.nonexist !== null) message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);
        return message;
    }
};
function createBaseCompressedBatchProof() {
    return {
        entries: [],
        lookupInners: []
    };
}
exports.CompressedBatchProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries)exports.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.lookupInners)exports.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCompressedBatchProof();
        if (Array.isArray(object?.entries)) obj.entries = object.entries.map((e)=>exports.CompressedBatchEntry.fromJSON(e));
        if (Array.isArray(object?.lookupInners)) obj.lookupInners = object.lookupInners.map((e)=>exports.InnerOp.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.entries) obj.entries = message.entries.map((e)=>e ? exports.CompressedBatchEntry.toJSON(e) : undefined);
        else obj.entries = [];
        if (message.lookupInners) obj.lookupInners = message.lookupInners.map((e)=>e ? exports.InnerOp.toJSON(e) : undefined);
        else obj.lookupInners = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCompressedBatchProof();
        message.entries = object.entries?.map((e)=>exports.CompressedBatchEntry.fromPartial(e)) || [];
        message.lookupInners = object.lookupInners?.map((e)=>exports.InnerOp.fromPartial(e)) || [];
        return message;
    }
};
function createBaseCompressedBatchEntry() {
    return {
        exist: undefined,
        nonexist: undefined
    };
}
exports.CompressedBatchEntry = {
    typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== undefined) exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        if (message.nonexist !== undefined) exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCompressedBatchEntry();
        if ((0, helpers_1.isSet)(object.exist)) obj.exist = exports.CompressedExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist)) obj.nonexist = exports.CompressedNonExistenceProof.fromJSON(object.nonexist);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.exist !== undefined && (obj.exist = message.exist ? exports.CompressedExistenceProof.toJSON(message.exist) : undefined);
        message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.CompressedNonExistenceProof.toJSON(message.nonexist) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCompressedBatchEntry();
        if (object.exist !== undefined && object.exist !== null) message.exist = exports.CompressedExistenceProof.fromPartial(object.exist);
        if (object.nonexist !== undefined && object.nonexist !== null) message.nonexist = exports.CompressedNonExistenceProof.fromPartial(object.nonexist);
        return message;
    }
};
function createBaseCompressedExistenceProof() {
    return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: undefined,
        path: []
    };
}
exports.CompressedExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        if (message.value.length !== 0) writer.uint32(18).bytes(message.value);
        if (message.leaf !== undefined) exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        writer.uint32(34).fork();
        for (const v of message.path)writer.int32(v);
        writer.ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompressedExistenceProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                case 3:
                    message.leaf = exports.LeafOp.decode(reader, reader.uint32());
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.path.push(reader.int32());
                    } else message.path.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCompressedExistenceProof();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value)) obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf)) obj.leaf = exports.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object?.path)) obj.path = object.path.map((e)=>Number(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        message.leaf !== undefined && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);
        if (message.path) obj.path = message.path.map((e)=>Math.round(e));
        else obj.path = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCompressedExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== undefined && object.leaf !== null) message.leaf = exports.LeafOp.fromPartial(object.leaf);
        message.path = object.path?.map((e)=>e) || [];
        return message;
    }
};
function createBaseCompressedNonExistenceProof() {
    return {
        key: new Uint8Array(),
        left: undefined,
        right: undefined
    };
}
exports.CompressedNonExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        if (message.left !== undefined) exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        if (message.right !== undefined) exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompressedNonExistenceProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCompressedNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left)) obj.left = exports.CompressedExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right)) obj.right = exports.CompressedExistenceProof.fromJSON(object.right);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.left !== undefined && (obj.left = message.left ? exports.CompressedExistenceProof.toJSON(message.left) : undefined);
        message.right !== undefined && (obj.right = message.right ? exports.CompressedExistenceProof.toJSON(message.right) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCompressedNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== undefined && object.left !== null) message.left = exports.CompressedExistenceProof.fromPartial(object.left);
        if (object.right !== undefined && object.right !== null) message.right = exports.CompressedExistenceProof.fromPartial(object.right);
        return message;
    }
};

},{"4a984558aa9088ba":"bi36x","37df7708beb2546":"eYjRL"}],"6RmWV":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupIbcExtension = setupIbcExtension;
const query_1 = require("f890ad61446dc4ed");
const query_2 = require("bf50cd7bc349db0b");
const query_3 = require("cd11092d75dc3c1d");
const query_4 = require("7f5582b42352db98");
const tendermint_1 = require("5597675ab41900f3");
const queryclient_1 = require("8f72da5cd246c96f");
function decodeTendermintClientStateAny(clientState) {
    if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ClientState") throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
    return tendermint_1.ClientState.decode(clientState.value);
}
function decodeTendermintConsensusStateAny(clientState) {
    if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ConsensusState") throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
    return tendermint_1.ConsensusState.decode(clientState.value);
}
function setupIbcExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use these services to get easy typed access to query methods
    // These cannot be used for proof verification
    const channelQueryService = new query_2.QueryClientImpl(rpc);
    const clientQueryService = new query_3.QueryClientImpl(rpc);
    const connectionQueryService = new query_4.QueryClientImpl(rpc);
    const transferQueryService = new query_1.QueryClientImpl(rpc);
    return {
        ibc: {
            channel: {
                channel: async (portId, channelId)=>channelQueryService.Channel({
                        portId: portId,
                        channelId: channelId
                    }),
                channels: async (paginationKey)=>channelQueryService.Channels({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allChannels: async ()=>{
                    const channels = [];
                    let response;
                    let key;
                    do {
                        response = await channelQueryService.Channels({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        channels.push(...response.channels);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_2.QueryChannelsResponse.fromPartial({
                        channels: channels,
                        height: response.height
                    });
                },
                connectionChannels: async (connection, paginationKey)=>channelQueryService.ConnectionChannels({
                        connection: connection,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allConnectionChannels: async (connection)=>{
                    const channels = [];
                    let response;
                    let key;
                    do {
                        response = await channelQueryService.ConnectionChannels({
                            connection: connection,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        channels.push(...response.channels);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_2.QueryConnectionChannelsResponse.fromPartial({
                        channels: channels,
                        height: response.height
                    });
                },
                clientState: async (portId, channelId)=>channelQueryService.ChannelClientState({
                        portId: portId,
                        channelId: channelId
                    }),
                consensusState: async (portId, channelId, revisionNumber, revisionHeight)=>channelQueryService.ChannelConsensusState({
                        portId: portId,
                        channelId: channelId,
                        revisionNumber: BigInt(revisionNumber),
                        revisionHeight: BigInt(revisionHeight)
                    }),
                packetCommitment: async (portId, channelId, sequence)=>channelQueryService.PacketCommitment({
                        portId: portId,
                        channelId: channelId,
                        sequence: (0, queryclient_1.longify)(sequence)
                    }),
                packetCommitments: async (portId, channelId, paginationKey)=>channelQueryService.PacketCommitments({
                        channelId: channelId,
                        portId: portId,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allPacketCommitments: async (portId, channelId)=>{
                    const commitments = [];
                    let response;
                    let key;
                    do {
                        response = await channelQueryService.PacketCommitments({
                            channelId: channelId,
                            portId: portId,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        commitments.push(...response.commitments);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_2.QueryPacketCommitmentsResponse.fromPartial({
                        commitments: commitments,
                        height: response.height
                    });
                },
                packetReceipt: async (portId, channelId, sequence)=>channelQueryService.PacketReceipt({
                        portId: portId,
                        channelId: channelId,
                        sequence: (0, queryclient_1.longify)(sequence)
                    }),
                packetAcknowledgement: async (portId, channelId, sequence)=>channelQueryService.PacketAcknowledgement({
                        portId: portId,
                        channelId: channelId,
                        sequence: (0, queryclient_1.longify)(sequence)
                    }),
                packetAcknowledgements: async (portId, channelId, paginationKey)=>{
                    const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                        portId: portId,
                        channelId: channelId,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    });
                    return channelQueryService.PacketAcknowledgements(request);
                },
                allPacketAcknowledgements: async (portId, channelId)=>{
                    const acknowledgements = [];
                    let response;
                    let key;
                    do {
                        const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                            channelId: channelId,
                            portId: portId,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        response = await channelQueryService.PacketAcknowledgements(request);
                        acknowledgements.push(...response.acknowledgements);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                        acknowledgements: acknowledgements,
                        height: response.height
                    });
                },
                unreceivedPackets: async (portId, channelId, packetCommitmentSequences)=>channelQueryService.UnreceivedPackets({
                        portId: portId,
                        channelId: channelId,
                        packetCommitmentSequences: packetCommitmentSequences.map((s)=>BigInt(s))
                    }),
                unreceivedAcks: async (portId, channelId, packetAckSequences)=>channelQueryService.UnreceivedAcks({
                        portId: portId,
                        channelId: channelId,
                        packetAckSequences: packetAckSequences.map((s)=>BigInt(s))
                    }),
                nextSequenceReceive: async (portId, channelId)=>channelQueryService.NextSequenceReceive({
                        portId: portId,
                        channelId: channelId
                    })
            },
            client: {
                state: async (clientId)=>clientQueryService.ClientState({
                        clientId
                    }),
                states: async (paginationKey)=>clientQueryService.ClientStates({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allStates: async ()=>{
                    const clientStates = [];
                    let response;
                    let key;
                    do {
                        response = await clientQueryService.ClientStates({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        clientStates.push(...response.clientStates);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_3.QueryClientStatesResponse.fromPartial({
                        clientStates: clientStates
                    });
                },
                consensusState: async (clientId, consensusHeight)=>clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                        clientId: clientId,
                        revisionHeight: consensusHeight !== undefined ? BigInt(consensusHeight) : undefined,
                        latestHeight: consensusHeight === undefined
                    })),
                consensusStates: async (clientId, paginationKey)=>clientQueryService.ConsensusStates({
                        clientId: clientId,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allConsensusStates: async (clientId)=>{
                    const consensusStates = [];
                    let response;
                    let key;
                    do {
                        response = await clientQueryService.ConsensusStates({
                            clientId: clientId,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        consensusStates.push(...response.consensusStates);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_3.QueryConsensusStatesResponse.fromPartial({
                        consensusStates: consensusStates
                    });
                },
                params: async ()=>clientQueryService.ClientParams({}),
                stateTm: async (clientId)=>{
                    const response = await clientQueryService.ClientState({
                        clientId
                    });
                    return decodeTendermintClientStateAny(response.clientState);
                },
                statesTm: async (paginationKey)=>{
                    const { clientStates } = await clientQueryService.ClientStates({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    });
                    return clientStates.map(({ clientState })=>decodeTendermintClientStateAny(clientState));
                },
                allStatesTm: async ()=>{
                    const clientStates = [];
                    let response;
                    let key;
                    do {
                        response = await clientQueryService.ClientStates({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        clientStates.push(...response.clientStates);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return clientStates.map(({ clientState })=>decodeTendermintClientStateAny(clientState));
                },
                consensusStateTm: async (clientId, consensusHeight)=>{
                    const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                        clientId: clientId,
                        revisionHeight: consensusHeight?.revisionHeight,
                        revisionNumber: consensusHeight?.revisionNumber,
                        latestHeight: consensusHeight === undefined
                    }));
                    return decodeTendermintConsensusStateAny(response.consensusState);
                }
            },
            connection: {
                connection: async (connectionId)=>connectionQueryService.Connection({
                        connectionId: connectionId
                    }),
                connections: async (paginationKey)=>connectionQueryService.Connections({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allConnections: async ()=>{
                    const connections = [];
                    let response;
                    let key;
                    do {
                        response = await connectionQueryService.Connections({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        connections.push(...response.connections);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_4.QueryConnectionsResponse.fromPartial({
                        connections: connections,
                        height: response.height
                    });
                },
                clientConnections: async (clientId)=>connectionQueryService.ClientConnections({
                        clientId: clientId
                    }),
                clientState: async (connectionId)=>connectionQueryService.ConnectionClientState({
                        connectionId: connectionId
                    }),
                consensusState: async (connectionId, revisionHeight)=>connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
                        connectionId: connectionId,
                        revisionHeight: BigInt(revisionHeight)
                    }))
            },
            transfer: {
                denomTrace: async (hash)=>transferQueryService.DenomTrace({
                        hash: hash
                    }),
                denomTraces: async (paginationKey)=>transferQueryService.DenomTraces({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allDenomTraces: async ()=>{
                    const denomTraces = [];
                    let response;
                    let key;
                    do {
                        response = await transferQueryService.DenomTraces({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        denomTraces.push(...response.denomTraces);
                        key = response.pagination?.nextKey;
                    }while (key && key.length);
                    return query_1.QueryDenomTracesResponse.fromPartial({
                        denomTraces: denomTraces
                    });
                },
                params: async ()=>transferQueryService.Params({})
            }
        }
    };
}

},{"f890ad61446dc4ed":"aNRH6","bf50cd7bc349db0b":"77XtN","cd11092d75dc3c1d":"1d5d5","7f5582b42352db98":"b4WB1","5597675ab41900f3":"6thki","8f72da5cd246c96f":"cM4fi"}],"aNRH6":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryTotalEscrowForDenomResponse = exports.QueryTotalEscrowForDenomRequest = exports.QueryEscrowAddressResponse = exports.QueryEscrowAddressRequest = exports.QueryDenomHashResponse = exports.QueryDenomHashRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryDenomTracesResponse = exports.QueryDenomTracesRequest = exports.QueryDenomTraceResponse = exports.QueryDenomTraceRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("b1ee355ebb906ea7");
const transfer_1 = require("564bfb58acd333dd");
const coin_1 = require("6b1df1ada50d2103");
const binary_1 = require("b74f66f6fd64e868");
const helpers_1 = require("148de3d8f755bbab");
exports.protobufPackage = "ibc.applications.transfer.v1";
function createBaseQueryDenomTraceRequest() {
    return {
        hash: ""
    };
}
exports.QueryDenomTraceRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") writer.uint32(10).string(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomTraceRequest();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = String(object.hash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = message.hash);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomTraceRequest();
        message.hash = object.hash ?? "";
        return message;
    }
};
function createBaseQueryDenomTraceResponse() {
    return {
        denomTrace: undefined
    };
}
exports.QueryDenomTraceResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denomTrace !== undefined) transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomTraceResponse();
        if ((0, helpers_1.isSet)(object.denomTrace)) obj.denomTrace = transfer_1.DenomTrace.fromJSON(object.denomTrace);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denomTrace !== undefined && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomTraceResponse();
        if (object.denomTrace !== undefined && object.denomTrace !== null) message.denomTrace = transfer_1.DenomTrace.fromPartial(object.denomTrace);
        return message;
    }
};
function createBaseQueryDenomTracesRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryDenomTracesRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomTracesRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomTracesRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDenomTracesResponse() {
    return {
        denomTraces: [],
        pagination: undefined
    };
}
exports.QueryDenomTracesResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomTraces)transfer_1.DenomTrace.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomTracesResponse();
        if (Array.isArray(object?.denomTraces)) obj.denomTraces = object.denomTraces.map((e)=>transfer_1.DenomTrace.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.denomTraces) obj.denomTraces = message.denomTraces.map((e)=>e ? transfer_1.DenomTrace.toJSON(e) : undefined);
        else obj.denomTraces = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomTracesResponse();
        message.denomTraces = object.denomTraces?.map((e)=>transfer_1.DenomTrace.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: undefined
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = transfer_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = transfer_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = transfer_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQueryDenomHashRequest() {
    return {
        trace: ""
    };
}
exports.QueryDenomHashRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.trace !== "") writer.uint32(10).string(message.trace);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.trace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomHashRequest();
        if ((0, helpers_1.isSet)(object.trace)) obj.trace = String(object.trace);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.trace !== undefined && (obj.trace = message.trace);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomHashRequest();
        message.trace = object.trace ?? "";
        return message;
    }
};
function createBaseQueryDenomHashResponse() {
    return {
        hash: ""
    };
}
exports.QueryDenomHashResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") writer.uint32(10).string(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDenomHashResponse();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = String(object.hash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = message.hash);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDenomHashResponse();
        message.hash = object.hash ?? "";
        return message;
    }
};
function createBaseQueryEscrowAddressRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryEscrowAddressRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryEscrowAddressRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryEscrowAddressRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryEscrowAddressResponse() {
    return {
        escrowAddress: ""
    };
}
exports.QueryEscrowAddressResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.escrowAddress !== "") writer.uint32(10).string(message.escrowAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.escrowAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryEscrowAddressResponse();
        if ((0, helpers_1.isSet)(object.escrowAddress)) obj.escrowAddress = String(object.escrowAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.escrowAddress !== undefined && (obj.escrowAddress = message.escrowAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryEscrowAddressResponse();
        message.escrowAddress = object.escrowAddress ?? "";
        return message;
    }
};
function createBaseQueryTotalEscrowForDenomRequest() {
    return {
        denom: ""
    };
}
exports.QueryTotalEscrowForDenomRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") writer.uint32(10).string(message.denom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryTotalEscrowForDenomRequest();
        if ((0, helpers_1.isSet)(object.denom)) obj.denom = String(object.denom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryTotalEscrowForDenomRequest();
        message.denom = object.denom ?? "";
        return message;
    }
};
function createBaseQueryTotalEscrowForDenomResponse() {
    return {
        amount: coin_1.Coin.fromPartial({})
    };
}
exports.QueryTotalEscrowForDenomResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryTotalEscrowForDenomResponse();
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryTotalEscrowForDenomResponse();
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.DenomTraces = this.DenomTraces.bind(this);
        this.DenomTrace = this.DenomTrace.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomHash = this.DenomHash.bind(this);
        this.EscrowAddress = this.EscrowAddress.bind(this);
        this.TotalEscrowForDenom = this.TotalEscrowForDenom.bind(this);
    }
    DenomTraces(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data);
        return promise.then((data)=>exports.QueryDenomTracesResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomTrace(request) {
        const data = exports.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data);
        return promise.then((data)=>exports.QueryDenomTraceResponse.decode(new binary_1.BinaryReader(data)));
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DenomHash(request) {
        const data = exports.QueryDenomHashRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", data);
        return promise.then((data)=>exports.QueryDenomHashResponse.decode(new binary_1.BinaryReader(data)));
    }
    EscrowAddress(request) {
        const data = exports.QueryEscrowAddressRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", data);
        return promise.then((data)=>exports.QueryEscrowAddressResponse.decode(new binary_1.BinaryReader(data)));
    }
    TotalEscrowForDenom(request) {
        const data = exports.QueryTotalEscrowForDenomRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "TotalEscrowForDenom", data);
        return promise.then((data)=>exports.QueryTotalEscrowForDenomResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"b1ee355ebb906ea7":"43d5n","564bfb58acd333dd":"caMQA","6b1df1ada50d2103":"1ymyZ","b74f66f6fd64e868":"bi36x","148de3d8f755bbab":"eYjRL"}],"caMQA":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.DenomTrace = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("a36d63e8e4126292");
const helpers_1 = require("e3210864763906c2");
exports.protobufPackage = "ibc.applications.transfer.v1";
function createBaseDenomTrace() {
    return {
        path: "",
        baseDenom: ""
    };
}
exports.DenomTrace = {
    typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.path !== "") writer.uint32(10).string(message.path);
        if (message.baseDenom !== "") writer.uint32(18).string(message.baseDenom);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.path = reader.string();
                    break;
                case 2:
                    message.baseDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDenomTrace();
        if ((0, helpers_1.isSet)(object.path)) obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.baseDenom)) obj.baseDenom = String(object.baseDenom);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.path !== undefined && (obj.path = message.path);
        message.baseDenom !== undefined && (obj.baseDenom = message.baseDenom);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDenomTrace();
        message.path = object.path ?? "";
        message.baseDenom = object.baseDenom ?? "";
        return message;
    }
};
function createBaseParams() {
    return {
        sendEnabled: false,
        receiveEnabled: false
    };
}
exports.Params = {
    typeUrl: "/ibc.applications.transfer.v1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.sendEnabled === true) writer.uint32(8).bool(message.sendEnabled);
        if (message.receiveEnabled === true) writer.uint32(16).bool(message.receiveEnabled);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sendEnabled = reader.bool();
                    break;
                case 2:
                    message.receiveEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.sendEnabled)) obj.sendEnabled = Boolean(object.sendEnabled);
        if ((0, helpers_1.isSet)(object.receiveEnabled)) obj.receiveEnabled = Boolean(object.receiveEnabled);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.sendEnabled !== undefined && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== undefined && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.sendEnabled = object.sendEnabled ?? false;
        message.receiveEnabled = object.receiveEnabled ?? false;
        return message;
    }
};

},{"a36d63e8e4126292":"bi36x","e3210864763906c2":"eYjRL"}],"77XtN":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryChannelParamsResponse = exports.QueryChannelParamsRequest = exports.QueryUpgradeResponse = exports.QueryUpgradeRequest = exports.QueryUpgradeErrorResponse = exports.QueryUpgradeErrorRequest = exports.QueryNextSequenceSendResponse = exports.QueryNextSequenceSendRequest = exports.QueryNextSequenceReceiveResponse = exports.QueryNextSequenceReceiveRequest = exports.QueryUnreceivedAcksResponse = exports.QueryUnreceivedAcksRequest = exports.QueryUnreceivedPacketsResponse = exports.QueryUnreceivedPacketsRequest = exports.QueryPacketAcknowledgementsResponse = exports.QueryPacketAcknowledgementsRequest = exports.QueryPacketAcknowledgementResponse = exports.QueryPacketAcknowledgementRequest = exports.QueryPacketReceiptResponse = exports.QueryPacketReceiptRequest = exports.QueryPacketCommitmentsResponse = exports.QueryPacketCommitmentsRequest = exports.QueryPacketCommitmentResponse = exports.QueryPacketCommitmentRequest = exports.QueryChannelConsensusStateResponse = exports.QueryChannelConsensusStateRequest = exports.QueryChannelClientStateResponse = exports.QueryChannelClientStateRequest = exports.QueryConnectionChannelsResponse = exports.QueryConnectionChannelsRequest = exports.QueryChannelsResponse = exports.QueryChannelsRequest = exports.QueryChannelResponse = exports.QueryChannelRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("6b871c44f0d88b48");
const channel_1 = require("93b872502955d504");
const client_1 = require("b3e568b030063a42");
const any_1 = require("52fda253a425830f");
const upgrade_1 = require("5a3810b3abfb72a4");
const binary_1 = require("d49d0ef22622e89");
const helpers_1 = require("649ba8d80575fd3");
exports.protobufPackage = "ibc.core.channel.v1";
function createBaseQueryChannelRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryChannelRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryChannelResponse() {
    return {
        channel: undefined,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryChannelResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.channel !== undefined) channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.channel = channel_1.Channel.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelResponse();
        if ((0, helpers_1.isSet)(object.channel)) obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelResponse();
        if (object.channel !== undefined && object.channel !== null) message.channel = channel_1.Channel.fromPartial(object.channel);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryChannelsRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryChannelsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelsRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelsRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryChannelsResponse() {
    return {
        channels: [],
        pagination: undefined,
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryChannelsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels)channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelsResponse();
        if (Array.isArray(object?.channels)) obj.channels = object.channels.map((e)=>channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.channels) obj.channels = message.channels.map((e)=>e ? channel_1.IdentifiedChannel.toJSON(e) : undefined);
        else obj.channels = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelsResponse();
        message.channels = object.channels?.map((e)=>channel_1.IdentifiedChannel.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryConnectionChannelsRequest() {
    return {
        connection: "",
        pagination: undefined
    };
}
exports.QueryConnectionChannelsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== "") writer.uint32(10).string(message.connection);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connection = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionChannelsRequest();
        if ((0, helpers_1.isSet)(object.connection)) obj.connection = String(object.connection);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connection !== undefined && (obj.connection = message.connection);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionChannelsRequest();
        message.connection = object.connection ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryConnectionChannelsResponse() {
    return {
        channels: [],
        pagination: undefined,
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryConnectionChannelsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels)channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionChannelsResponse();
        if (Array.isArray(object?.channels)) obj.channels = object.channels.map((e)=>channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.channels) obj.channels = message.channels.map((e)=>e ? channel_1.IdentifiedChannel.toJSON(e) : undefined);
        else obj.channels = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionChannelsResponse();
        message.channels = object.channels?.map((e)=>channel_1.IdentifiedChannel.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryChannelClientStateRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryChannelClientStateRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelClientStateRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelClientStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryChannelClientStateResponse() {
    return {
        identifiedClientState: undefined,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryChannelClientStateResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== undefined) client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState)) obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.identifiedClientState !== undefined && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelClientStateResponse();
        if (object.identifiedClientState !== undefined && object.identifiedClientState !== null) message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryChannelConsensusStateRequest() {
    return {
        portId: "",
        channelId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
    };
}
exports.QueryChannelConsensusStateRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.revisionNumber !== BigInt(0)) writer.uint32(24).uint64(message.revisionNumber);
        if (message.revisionHeight !== BigInt(0)) writer.uint32(32).uint64(message.revisionHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.revisionNumber = reader.uint64();
                    break;
                case 4:
                    message.revisionHeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.revisionNumber)) obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight)) obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.revisionNumber !== undefined && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== undefined && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelConsensusStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.revisionNumber !== undefined && object.revisionNumber !== null) message.revisionNumber = BigInt(object.revisionNumber.toString());
        if (object.revisionHeight !== undefined && object.revisionHeight !== null) message.revisionHeight = BigInt(object.revisionHeight.toString());
        return message;
    }
};
function createBaseQueryChannelConsensusStateResponse() {
    return {
        consensusState: undefined,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryChannelConsensusStateResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== undefined) any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        if (message.clientId !== "") writer.uint32(18).string(message.clientId);
        if (message.proof.length !== 0) writer.uint32(26).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.clientId = reader.string();
                    break;
                case 3:
                    message.proof = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState)) obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelConsensusStateResponse();
        if (object.consensusState !== undefined && object.consensusState !== null) message.consensusState = any_1.Any.fromPartial(object.consensusState);
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryPacketCommitmentRequest() {
    return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
    };
}
exports.QueryPacketCommitmentRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketCommitmentRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketCommitmentRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseQueryPacketCommitmentResponse() {
    return {
        commitment: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryPacketCommitmentResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.commitment.length !== 0) writer.uint32(10).bytes(message.commitment);
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.commitment = reader.bytes();
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketCommitmentResponse();
        if ((0, helpers_1.isSet)(object.commitment)) obj.commitment = (0, helpers_1.bytesFromBase64)(object.commitment);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.commitment !== undefined && (obj.commitment = (0, helpers_1.base64FromBytes)(message.commitment !== undefined ? message.commitment : new Uint8Array()));
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketCommitmentResponse();
        message.commitment = object.commitment ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryPacketCommitmentsRequest() {
    return {
        portId: "",
        channelId: "",
        pagination: undefined
    };
}
exports.QueryPacketCommitmentsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketCommitmentsRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketCommitmentsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryPacketCommitmentsResponse() {
    return {
        commitments: [],
        pagination: undefined,
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryPacketCommitmentsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commitments)channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketCommitmentsResponse();
        if (Array.isArray(object?.commitments)) obj.commitments = object.commitments.map((e)=>channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.commitments) obj.commitments = message.commitments.map((e)=>e ? channel_1.PacketState.toJSON(e) : undefined);
        else obj.commitments = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketCommitmentsResponse();
        message.commitments = object.commitments?.map((e)=>channel_1.PacketState.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryPacketReceiptRequest() {
    return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
    };
}
exports.QueryPacketReceiptRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketReceiptRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketReceiptRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseQueryPacketReceiptResponse() {
    return {
        received: false,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryPacketReceiptResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.received === true) writer.uint32(16).bool(message.received);
        if (message.proof.length !== 0) writer.uint32(26).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 2:
                    message.received = reader.bool();
                    break;
                case 3:
                    message.proof = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketReceiptResponse();
        if ((0, helpers_1.isSet)(object.received)) obj.received = Boolean(object.received);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.received !== undefined && (obj.received = message.received);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketReceiptResponse();
        message.received = object.received ?? false;
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryPacketAcknowledgementRequest() {
    return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
    };
}
exports.QueryPacketAcknowledgementRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.sequence !== BigInt(0)) writer.uint32(24).uint64(message.sequence);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketAcknowledgementRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence)) obj.sequence = BigInt(object.sequence.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketAcknowledgementRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== undefined && object.sequence !== null) message.sequence = BigInt(object.sequence.toString());
        return message;
    }
};
function createBaseQueryPacketAcknowledgementResponse() {
    return {
        acknowledgement: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryPacketAcknowledgementResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.acknowledgement.length !== 0) writer.uint32(10).bytes(message.acknowledgement);
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.acknowledgement = reader.bytes();
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.acknowledgement)) obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.acknowledgement !== undefined && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketAcknowledgementResponse();
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryPacketAcknowledgementsRequest() {
    return {
        portId: "",
        channelId: "",
        pagination: undefined,
        packetCommitmentSequences: []
    };
}
exports.QueryPacketAcknowledgementsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        writer.uint32(34).fork();
        for (const v of message.packetCommitmentSequences)writer.uint64(v);
        writer.ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.packetCommitmentSequences.push(reader.uint64());
                    } else message.packetCommitmentSequences.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketAcknowledgementsRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if (Array.isArray(object?.packetCommitmentSequences)) obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e)=>BigInt(e.toString()));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        if (message.packetCommitmentSequences) obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e)=>(e || BigInt(0)).toString());
        else obj.packetCommitmentSequences = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketAcknowledgementsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        message.packetCommitmentSequences = object.packetCommitmentSequences?.map((e)=>BigInt(e.toString())) || [];
        return message;
    }
};
function createBaseQueryPacketAcknowledgementsResponse() {
    return {
        acknowledgements: [],
        pagination: undefined,
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryPacketAcknowledgementsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.acknowledgements)channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPacketAcknowledgementsResponse();
        if (Array.isArray(object?.acknowledgements)) obj.acknowledgements = object.acknowledgements.map((e)=>channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.acknowledgements) obj.acknowledgements = message.acknowledgements.map((e)=>e ? channel_1.PacketState.toJSON(e) : undefined);
        else obj.acknowledgements = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPacketAcknowledgementsResponse();
        message.acknowledgements = object.acknowledgements?.map((e)=>channel_1.PacketState.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryUnreceivedPacketsRequest() {
    return {
        portId: "",
        channelId: "",
        packetCommitmentSequences: []
    };
}
exports.QueryUnreceivedPacketsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        writer.uint32(26).fork();
        for (const v of message.packetCommitmentSequences)writer.uint64(v);
        writer.ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.packetCommitmentSequences.push(reader.uint64());
                    } else message.packetCommitmentSequences.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUnreceivedPacketsRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if (Array.isArray(object?.packetCommitmentSequences)) obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e)=>BigInt(e.toString()));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e)=>(e || BigInt(0)).toString());
        else obj.packetCommitmentSequences = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUnreceivedPacketsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetCommitmentSequences = object.packetCommitmentSequences?.map((e)=>BigInt(e.toString())) || [];
        return message;
    }
};
function createBaseQueryUnreceivedPacketsResponse() {
    return {
        sequences: [],
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryUnreceivedPacketsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences)writer.uint64(v);
        writer.ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.sequences.push(reader.uint64());
                    } else message.sequences.push(reader.uint64());
                    break;
                case 2:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUnreceivedPacketsResponse();
        if (Array.isArray(object?.sequences)) obj.sequences = object.sequences.map((e)=>BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.sequences) obj.sequences = message.sequences.map((e)=>(e || BigInt(0)).toString());
        else obj.sequences = [];
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUnreceivedPacketsResponse();
        message.sequences = object.sequences?.map((e)=>BigInt(e.toString())) || [];
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryUnreceivedAcksRequest() {
    return {
        portId: "",
        channelId: "",
        packetAckSequences: []
    };
}
exports.QueryUnreceivedAcksRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        writer.uint32(26).fork();
        for (const v of message.packetAckSequences)writer.uint64(v);
        writer.ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.packetAckSequences.push(reader.uint64());
                    } else message.packetAckSequences.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUnreceivedAcksRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        if (Array.isArray(object?.packetAckSequences)) obj.packetAckSequences = object.packetAckSequences.map((e)=>BigInt(e.toString()));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        if (message.packetAckSequences) obj.packetAckSequences = message.packetAckSequences.map((e)=>(e || BigInt(0)).toString());
        else obj.packetAckSequences = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUnreceivedAcksRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetAckSequences = object.packetAckSequences?.map((e)=>BigInt(e.toString())) || [];
        return message;
    }
};
function createBaseQueryUnreceivedAcksResponse() {
    return {
        sequences: [],
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryUnreceivedAcksResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences)writer.uint64(v);
        writer.ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.sequences.push(reader.uint64());
                    } else message.sequences.push(reader.uint64());
                    break;
                case 2:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUnreceivedAcksResponse();
        if (Array.isArray(object?.sequences)) obj.sequences = object.sequences.map((e)=>BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.sequences) obj.sequences = message.sequences.map((e)=>(e || BigInt(0)).toString());
        else obj.sequences = [];
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUnreceivedAcksResponse();
        message.sequences = object.sequences?.map((e)=>BigInt(e.toString())) || [];
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryNextSequenceReceiveRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryNextSequenceReceiveRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryNextSequenceReceiveRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryNextSequenceReceiveRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryNextSequenceReceiveResponse() {
    return {
        nextSequenceReceive: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryNextSequenceReceiveResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceReceive !== BigInt(0)) writer.uint32(8).uint64(message.nextSequenceReceive);
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.nextSequenceReceive = reader.uint64();
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryNextSequenceReceiveResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceReceive)) obj.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.nextSequenceReceive !== undefined && (obj.nextSequenceReceive = (message.nextSequenceReceive || BigInt(0)).toString());
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryNextSequenceReceiveResponse();
        if (object.nextSequenceReceive !== undefined && object.nextSequenceReceive !== null) message.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryNextSequenceSendRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryNextSequenceSendRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryNextSequenceSendRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryNextSequenceSendRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryNextSequenceSendResponse() {
    return {
        nextSequenceSend: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryNextSequenceSendResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceSend !== BigInt(0)) writer.uint32(8).uint64(message.nextSequenceSend);
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.nextSequenceSend = reader.uint64();
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryNextSequenceSendResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceSend)) obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.nextSequenceSend !== undefined && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryNextSequenceSendResponse();
        if (object.nextSequenceSend !== undefined && object.nextSequenceSend !== null) message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryUpgradeErrorRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryUpgradeErrorRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUpgradeErrorRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUpgradeErrorRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryUpgradeErrorResponse() {
    return {
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryUpgradeErrorResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.errorReceipt !== undefined) upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUpgradeErrorResponse();
        if ((0, helpers_1.isSet)(object.errorReceipt)) obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.errorReceipt !== undefined && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUpgradeErrorResponse();
        if (object.errorReceipt !== undefined && object.errorReceipt !== null) message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryUpgradeRequest() {
    return {
        portId: "",
        channelId: ""
    };
}
exports.QueryUpgradeRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUpgradeRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") writer.uint32(10).string(message.portId);
        if (message.channelId !== "") writer.uint32(18).string(message.channelId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.portId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUpgradeRequest();
        if ((0, helpers_1.isSet)(object.portId)) obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId)) obj.channelId = String(object.channelId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.portId !== undefined && (obj.portId = message.portId);
        message.channelId !== undefined && (obj.channelId = message.channelId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUpgradeRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
    }
};
function createBaseQueryUpgradeResponse() {
    return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryUpgradeResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUpgradeResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== undefined) upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUpgradeResponse();
        if ((0, helpers_1.isSet)(object.upgrade)) obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.upgrade !== undefined && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUpgradeResponse();
        if (object.upgrade !== undefined && object.upgrade !== null) message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryChannelParamsRequest() {
    return {};
}
exports.QueryChannelParamsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryChannelParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryChannelParamsRequest();
        return message;
    }
};
function createBaseQueryChannelParamsResponse() {
    return {
        params: undefined
    };
}
exports.QueryChannelParamsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryChannelParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryChannelParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
        this.NextSequenceSend = this.NextSequenceSend.bind(this);
        this.UpgradeError = this.UpgradeError.bind(this);
        this.Upgrade = this.Upgrade.bind(this);
        this.ChannelParams = this.ChannelParams.bind(this);
    }
    Channel(request) {
        const data = exports.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data);
        return promise.then((data)=>exports.QueryChannelResponse.decode(new binary_1.BinaryReader(data)));
    }
    Channels(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data);
        return promise.then((data)=>exports.QueryChannelsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionChannels(request) {
        const data = exports.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data);
        return promise.then((data)=>exports.QueryConnectionChannelsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelClientState(request) {
        const data = exports.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data);
        return promise.then((data)=>exports.QueryChannelClientStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelConsensusState(request) {
        const data = exports.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data);
        return promise.then((data)=>exports.QueryChannelConsensusStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    PacketCommitment(request) {
        const data = exports.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data);
        return promise.then((data)=>exports.QueryPacketCommitmentResponse.decode(new binary_1.BinaryReader(data)));
    }
    PacketCommitments(request) {
        const data = exports.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data);
        return promise.then((data)=>exports.QueryPacketCommitmentsResponse.decode(new binary_1.BinaryReader(data)));
    }
    PacketReceipt(request) {
        const data = exports.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data);
        return promise.then((data)=>exports.QueryPacketReceiptResponse.decode(new binary_1.BinaryReader(data)));
    }
    PacketAcknowledgement(request) {
        const data = exports.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data);
        return promise.then((data)=>exports.QueryPacketAcknowledgementResponse.decode(new binary_1.BinaryReader(data)));
    }
    PacketAcknowledgements(request) {
        const data = exports.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data);
        return promise.then((data)=>exports.QueryPacketAcknowledgementsResponse.decode(new binary_1.BinaryReader(data)));
    }
    UnreceivedPackets(request) {
        const data = exports.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data);
        return promise.then((data)=>exports.QueryUnreceivedPacketsResponse.decode(new binary_1.BinaryReader(data)));
    }
    UnreceivedAcks(request) {
        const data = exports.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data);
        return promise.then((data)=>exports.QueryUnreceivedAcksResponse.decode(new binary_1.BinaryReader(data)));
    }
    NextSequenceReceive(request) {
        const data = exports.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data);
        return promise.then((data)=>exports.QueryNextSequenceReceiveResponse.decode(new binary_1.BinaryReader(data)));
    }
    NextSequenceSend(request) {
        const data = exports.QueryNextSequenceSendRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceSend", data);
        return promise.then((data)=>exports.QueryNextSequenceSendResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpgradeError(request) {
        const data = exports.QueryUpgradeErrorRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UpgradeError", data);
        return promise.then((data)=>exports.QueryUpgradeErrorResponse.decode(new binary_1.BinaryReader(data)));
    }
    Upgrade(request) {
        const data = exports.QueryUpgradeRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Upgrade", data);
        return promise.then((data)=>exports.QueryUpgradeResponse.decode(new binary_1.BinaryReader(data)));
    }
    ChannelParams(request = {}) {
        const data = exports.QueryChannelParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelParams", data);
        return promise.then((data)=>exports.QueryChannelParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"6b871c44f0d88b48":"43d5n","93b872502955d504":"eujl6","b3e568b030063a42":"3w7CV","52fda253a425830f":"56aJC","5a3810b3abfb72a4":"fZsk6","d49d0ef22622e89":"bi36x","649ba8d80575fd3":"eYjRL"}],"1d5d5":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryVerifyMembershipResponse = exports.QueryVerifyMembershipRequest = exports.QueryUpgradedConsensusStateResponse = exports.QueryUpgradedConsensusStateRequest = exports.QueryUpgradedClientStateResponse = exports.QueryUpgradedClientStateRequest = exports.QueryClientParamsResponse = exports.QueryClientParamsRequest = exports.QueryClientStatusResponse = exports.QueryClientStatusRequest = exports.QueryConsensusStateHeightsResponse = exports.QueryConsensusStateHeightsRequest = exports.QueryConsensusStatesResponse = exports.QueryConsensusStatesRequest = exports.QueryConsensusStateResponse = exports.QueryConsensusStateRequest = exports.QueryClientStatesResponse = exports.QueryClientStatesRequest = exports.QueryClientStateResponse = exports.QueryClientStateRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("aae4056f16958ff0");
const client_1 = require("b3b08d6e633fb4e");
const commitment_1 = require("59c292dc21cc8ea2");
const any_1 = require("3b80846fd9cfd79d");
const binary_1 = require("576ed9923ea5392a");
const helpers_1 = require("1bf2a67cbf06e974");
exports.protobufPackage = "ibc.core.client.v1";
function createBaseQueryClientStateRequest() {
    return {
        clientId: ""
    };
}
exports.QueryClientStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientStateRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientStateRequest();
        message.clientId = object.clientId ?? "";
        return message;
    }
};
function createBaseQueryClientStateResponse() {
    return {
        clientState: undefined,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryClientStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== undefined) any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientStateResponse();
        if ((0, helpers_1.isSet)(object.clientState)) obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientStateResponse();
        if (object.clientState !== undefined && object.clientState !== null) message.clientState = any_1.Any.fromPartial(object.clientState);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryClientStatesRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryClientStatesRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientStatesRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientStatesRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryClientStatesResponse() {
    return {
        clientStates: [],
        pagination: undefined
    };
}
exports.QueryClientStatesResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.clientStates)client_1.IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientStatesResponse();
        if (Array.isArray(object?.clientStates)) obj.clientStates = object.clientStates.map((e)=>client_1.IdentifiedClientState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.clientStates) obj.clientStates = message.clientStates.map((e)=>e ? client_1.IdentifiedClientState.toJSON(e) : undefined);
        else obj.clientStates = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientStatesResponse();
        message.clientStates = object.clientStates?.map((e)=>client_1.IdentifiedClientState.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryConsensusStateRequest() {
    return {
        clientId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0),
        latestHeight: false
    };
}
exports.QueryConsensusStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.revisionNumber !== BigInt(0)) writer.uint32(16).uint64(message.revisionNumber);
        if (message.revisionHeight !== BigInt(0)) writer.uint32(24).uint64(message.revisionHeight);
        if (message.latestHeight === true) writer.uint32(32).bool(message.latestHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.revisionNumber = reader.uint64();
                    break;
                case 3:
                    message.revisionHeight = reader.uint64();
                    break;
                case 4:
                    message.latestHeight = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.revisionNumber)) obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight)) obj.revisionHeight = BigInt(object.revisionHeight.toString());
        if ((0, helpers_1.isSet)(object.latestHeight)) obj.latestHeight = Boolean(object.latestHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.revisionNumber !== undefined && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== undefined && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        message.latestHeight !== undefined && (obj.latestHeight = message.latestHeight);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConsensusStateRequest();
        message.clientId = object.clientId ?? "";
        if (object.revisionNumber !== undefined && object.revisionNumber !== null) message.revisionNumber = BigInt(object.revisionNumber.toString());
        if (object.revisionHeight !== undefined && object.revisionHeight !== null) message.revisionHeight = BigInt(object.revisionHeight.toString());
        message.latestHeight = object.latestHeight ?? false;
        return message;
    }
};
function createBaseQueryConsensusStateResponse() {
    return {
        consensusState: undefined,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryConsensusStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== undefined) any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState)) obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConsensusStateResponse();
        if (object.consensusState !== undefined && object.consensusState !== null) message.consensusState = any_1.Any.fromPartial(object.consensusState);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryConsensusStatesRequest() {
    return {
        clientId: "",
        pagination: undefined
    };
}
exports.QueryConsensusStatesRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConsensusStatesRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConsensusStatesRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryConsensusStatesResponse() {
    return {
        consensusStates: [],
        pagination: undefined
    };
}
exports.QueryConsensusStatesResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStates)client_1.ConsensusStateWithHeight.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConsensusStatesResponse();
        if (Array.isArray(object?.consensusStates)) obj.consensusStates = object.consensusStates.map((e)=>client_1.ConsensusStateWithHeight.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.consensusStates) obj.consensusStates = message.consensusStates.map((e)=>e ? client_1.ConsensusStateWithHeight.toJSON(e) : undefined);
        else obj.consensusStates = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConsensusStatesResponse();
        message.consensusStates = object.consensusStates?.map((e)=>client_1.ConsensusStateWithHeight.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryConsensusStateHeightsRequest() {
    return {
        clientId: "",
        pagination: undefined
    };
}
exports.QueryConsensusStateHeightsRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConsensusStateHeightsRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConsensusStateHeightsRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryConsensusStateHeightsResponse() {
    return {
        consensusStateHeights: [],
        pagination: undefined
    };
}
exports.QueryConsensusStateHeightsResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStateHeights)client_1.Height.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consensusStateHeights.push(client_1.Height.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConsensusStateHeightsResponse();
        if (Array.isArray(object?.consensusStateHeights)) obj.consensusStateHeights = object.consensusStateHeights.map((e)=>client_1.Height.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.consensusStateHeights) obj.consensusStateHeights = message.consensusStateHeights.map((e)=>e ? client_1.Height.toJSON(e) : undefined);
        else obj.consensusStateHeights = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConsensusStateHeightsResponse();
        message.consensusStateHeights = object.consensusStateHeights?.map((e)=>client_1.Height.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryClientStatusRequest() {
    return {
        clientId: ""
    };
}
exports.QueryClientStatusRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientStatusRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientStatusRequest();
        message.clientId = object.clientId ?? "";
        return message;
    }
};
function createBaseQueryClientStatusResponse() {
    return {
        status: ""
    };
}
exports.QueryClientStatusResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") writer.uint32(10).string(message.status);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.status = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientStatusResponse();
        if ((0, helpers_1.isSet)(object.status)) obj.status = String(object.status);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.status !== undefined && (obj.status = message.status);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientStatusResponse();
        message.status = object.status ?? "";
        return message;
    }
};
function createBaseQueryClientParamsRequest() {
    return {};
}
exports.QueryClientParamsRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryClientParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryClientParamsRequest();
        return message;
    }
};
function createBaseQueryClientParamsResponse() {
    return {
        params: undefined
    };
}
exports.QueryClientParamsResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQueryUpgradedClientStateRequest() {
    return {};
}
exports.QueryUpgradedClientStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryUpgradedClientStateRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryUpgradedClientStateRequest();
        return message;
    }
};
function createBaseQueryUpgradedClientStateResponse() {
    return {
        upgradedClientState: undefined
    };
}
exports.QueryUpgradedClientStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedClientState !== undefined) any_1.Any.encode(message.upgradedClientState, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUpgradedClientStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedClientState)) obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.upgradedClientState !== undefined && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUpgradedClientStateResponse();
        if (object.upgradedClientState !== undefined && object.upgradedClientState !== null) message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        return message;
    }
};
function createBaseQueryUpgradedConsensusStateRequest() {
    return {};
}
exports.QueryUpgradedConsensusStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryUpgradedConsensusStateRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryUpgradedConsensusStateRequest();
        return message;
    }
};
function createBaseQueryUpgradedConsensusStateResponse() {
    return {
        upgradedConsensusState: undefined
    };
}
exports.QueryUpgradedConsensusStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedConsensusState !== undefined) any_1.Any.encode(message.upgradedConsensusState, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.upgradedConsensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUpgradedConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedConsensusState)) obj.upgradedConsensusState = any_1.Any.fromJSON(object.upgradedConsensusState);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.upgradedConsensusState !== undefined && (obj.upgradedConsensusState = message.upgradedConsensusState ? any_1.Any.toJSON(message.upgradedConsensusState) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUpgradedConsensusStateResponse();
        if (object.upgradedConsensusState !== undefined && object.upgradedConsensusState !== null) message.upgradedConsensusState = any_1.Any.fromPartial(object.upgradedConsensusState);
        return message;
    }
};
function createBaseQueryVerifyMembershipRequest() {
    return {
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        merklePath: commitment_1.MerklePath.fromPartial({}),
        value: new Uint8Array(),
        timeDelay: BigInt(0),
        blockDelay: BigInt(0)
    };
}
exports.QueryVerifyMembershipRequest = {
    typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        if (message.merklePath !== undefined) commitment_1.MerklePath.encode(message.merklePath, writer.uint32(34).fork()).ldelim();
        if (message.value.length !== 0) writer.uint32(42).bytes(message.value);
        if (message.timeDelay !== BigInt(0)) writer.uint32(48).uint64(message.timeDelay);
        if (message.blockDelay !== BigInt(0)) writer.uint32(56).uint64(message.blockDelay);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.merklePath = commitment_1.MerklePath.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.value = reader.bytes();
                    break;
                case 6:
                    message.timeDelay = reader.uint64();
                    break;
                case 7:
                    message.blockDelay = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryVerifyMembershipRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.merklePath)) obj.merklePath = commitment_1.MerklePath.fromJSON(object.merklePath);
        if ((0, helpers_1.isSet)(object.value)) obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.timeDelay)) obj.timeDelay = BigInt(object.timeDelay.toString());
        if ((0, helpers_1.isSet)(object.blockDelay)) obj.blockDelay = BigInt(object.blockDelay.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        message.merklePath !== undefined && (obj.merklePath = message.merklePath ? commitment_1.MerklePath.toJSON(message.merklePath) : undefined);
        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        message.timeDelay !== undefined && (obj.timeDelay = (message.timeDelay || BigInt(0)).toString());
        message.blockDelay !== undefined && (obj.blockDelay = (message.blockDelay || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryVerifyMembershipRequest();
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        if (object.merklePath !== undefined && object.merklePath !== null) message.merklePath = commitment_1.MerklePath.fromPartial(object.merklePath);
        message.value = object.value ?? new Uint8Array();
        if (object.timeDelay !== undefined && object.timeDelay !== null) message.timeDelay = BigInt(object.timeDelay.toString());
        if (object.blockDelay !== undefined && object.blockDelay !== null) message.blockDelay = BigInt(object.blockDelay.toString());
        return message;
    }
};
function createBaseQueryVerifyMembershipResponse() {
    return {
        success: false
    };
}
exports.QueryVerifyMembershipResponse = {
    typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.success === true) writer.uint32(8).bool(message.success);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.success = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryVerifyMembershipResponse();
        if ((0, helpers_1.isSet)(object.success)) obj.success = Boolean(object.success);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryVerifyMembershipResponse();
        message.success = object.success ?? false;
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this);
        this.ClientStatus = this.ClientStatus.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
        this.UpgradedClientState = this.UpgradedClientState.bind(this);
        this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
        this.VerifyMembership = this.VerifyMembership.bind(this);
    }
    ClientState(request) {
        const data = exports.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data);
        return promise.then((data)=>exports.QueryClientStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    ClientStates(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data);
        return promise.then((data)=>exports.QueryClientStatesResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConsensusState(request) {
        const data = exports.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data);
        return promise.then((data)=>exports.QueryConsensusStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConsensusStates(request) {
        const data = exports.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data);
        return promise.then((data)=>exports.QueryConsensusStatesResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConsensusStateHeights(request) {
        const data = exports.QueryConsensusStateHeightsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", data);
        return promise.then((data)=>exports.QueryConsensusStateHeightsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ClientStatus(request) {
        const data = exports.QueryClientStatusRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", data);
        return promise.then((data)=>exports.QueryClientStatusResponse.decode(new binary_1.BinaryReader(data)));
    }
    ClientParams(request = {}) {
        const data = exports.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data);
        return promise.then((data)=>exports.QueryClientParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpgradedClientState(request = {}) {
        const data = exports.QueryUpgradedClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", data);
        return promise.then((data)=>exports.QueryUpgradedClientStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpgradedConsensusState(request = {}) {
        const data = exports.QueryUpgradedConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", data);
        return promise.then((data)=>exports.QueryUpgradedConsensusStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    VerifyMembership(request) {
        const data = exports.QueryVerifyMembershipRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "VerifyMembership", data);
        return promise.then((data)=>exports.QueryVerifyMembershipResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"aae4056f16958ff0":"43d5n","b3b08d6e633fb4e":"3w7CV","59c292dc21cc8ea2":"iMPyZ","3b80846fd9cfd79d":"56aJC","576ed9923ea5392a":"bi36x","1bf2a67cbf06e974":"eYjRL"}],"b4WB1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryConnectionParamsResponse = exports.QueryConnectionParamsRequest = exports.QueryConnectionConsensusStateResponse = exports.QueryConnectionConsensusStateRequest = exports.QueryConnectionClientStateResponse = exports.QueryConnectionClientStateRequest = exports.QueryClientConnectionsResponse = exports.QueryClientConnectionsRequest = exports.QueryConnectionsResponse = exports.QueryConnectionsRequest = exports.QueryConnectionResponse = exports.QueryConnectionRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("1e331700686e908b");
const connection_1 = require("3adfcdbdb315ba24");
const client_1 = require("ff72ed0738a70ec6");
const any_1 = require("606a39289d47b20f");
const binary_1 = require("f83cead5b8959ffa");
const helpers_1 = require("5b293826496a704a");
exports.protobufPackage = "ibc.core.connection.v1";
function createBaseQueryConnectionRequest() {
    return {
        connectionId: ""
    };
}
exports.QueryConnectionRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") writer.uint32(10).string(message.connectionId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionRequest();
        if ((0, helpers_1.isSet)(object.connectionId)) obj.connectionId = String(object.connectionId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
    }
};
function createBaseQueryConnectionResponse() {
    return {
        connection: undefined,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryConnectionResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== undefined) connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionResponse();
        if ((0, helpers_1.isSet)(object.connection)) obj.connection = connection_1.ConnectionEnd.fromJSON(object.connection);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connection !== undefined && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionResponse();
        if (object.connection !== undefined && object.connection !== null) message.connection = connection_1.ConnectionEnd.fromPartial(object.connection);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryConnectionsRequest() {
    return {
        pagination: undefined
    };
}
exports.QueryConnectionsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionsRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionsRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryConnectionsResponse() {
    return {
        connections: [],
        pagination: undefined,
        height: client_1.Height.fromPartial({})
    };
}
exports.QueryConnectionsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connections)connection_1.IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.height !== undefined) client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionsResponse();
        if (Array.isArray(object?.connections)) obj.connections = object.connections.map((e)=>connection_1.IdentifiedConnection.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height)) obj.height = client_1.Height.fromJSON(object.height);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.connections) obj.connections = message.connections.map((e)=>e ? connection_1.IdentifiedConnection.toJSON(e) : undefined);
        else obj.connections = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        message.height !== undefined && (obj.height = message.height ? client_1.Height.toJSON(message.height) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionsResponse();
        message.connections = object.connections?.map((e)=>connection_1.IdentifiedConnection.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        if (object.height !== undefined && object.height !== null) message.height = client_1.Height.fromPartial(object.height);
        return message;
    }
};
function createBaseQueryClientConnectionsRequest() {
    return {
        clientId: ""
    };
}
exports.QueryClientConnectionsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientConnectionsRequest();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientConnectionsRequest();
        message.clientId = object.clientId ?? "";
        return message;
    }
};
function createBaseQueryClientConnectionsResponse() {
    return {
        connectionPaths: [],
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryClientConnectionsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connectionPaths)writer.uint32(10).string(v);
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connectionPaths.push(reader.string());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryClientConnectionsResponse();
        if (Array.isArray(object?.connectionPaths)) obj.connectionPaths = object.connectionPaths.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.connectionPaths) obj.connectionPaths = message.connectionPaths.map((e)=>e);
        else obj.connectionPaths = [];
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryClientConnectionsResponse();
        message.connectionPaths = object.connectionPaths?.map((e)=>e) || [];
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryConnectionClientStateRequest() {
    return {
        connectionId: ""
    };
}
exports.QueryConnectionClientStateRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") writer.uint32(10).string(message.connectionId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionClientStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId)) obj.connectionId = String(object.connectionId);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionClientStateRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
    }
};
function createBaseQueryConnectionClientStateResponse() {
    return {
        identifiedClientState: undefined,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryConnectionClientStateResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== undefined) client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        if (message.proof.length !== 0) writer.uint32(18).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                case 3:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState)) obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.identifiedClientState !== undefined && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : undefined);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionClientStateResponse();
        if (object.identifiedClientState !== undefined && object.identifiedClientState !== null) message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryConnectionConsensusStateRequest() {
    return {
        connectionId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
    };
}
exports.QueryConnectionConsensusStateRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") writer.uint32(10).string(message.connectionId);
        if (message.revisionNumber !== BigInt(0)) writer.uint32(16).uint64(message.revisionNumber);
        if (message.revisionHeight !== BigInt(0)) writer.uint32(24).uint64(message.revisionHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.connectionId = reader.string();
                    break;
                case 2:
                    message.revisionNumber = reader.uint64();
                    break;
                case 3:
                    message.revisionHeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId)) obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.revisionNumber)) obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight)) obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        message.revisionNumber !== undefined && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== undefined && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionConsensusStateRequest();
        message.connectionId = object.connectionId ?? "";
        if (object.revisionNumber !== undefined && object.revisionNumber !== null) message.revisionNumber = BigInt(object.revisionNumber.toString());
        if (object.revisionHeight !== undefined && object.revisionHeight !== null) message.revisionHeight = BigInt(object.revisionHeight.toString());
        return message;
    }
};
function createBaseQueryConnectionConsensusStateResponse() {
    return {
        consensusState: undefined,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
    };
}
exports.QueryConnectionConsensusStateResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== undefined) any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        if (message.clientId !== "") writer.uint32(18).string(message.clientId);
        if (message.proof.length !== 0) writer.uint32(26).bytes(message.proof);
        if (message.proofHeight !== undefined) client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consensusState = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.clientId = reader.string();
                    break;
                case 3:
                    message.proof = reader.bytes();
                    break;
                case 4:
                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState)) obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight)) obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.proof !== undefined && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== undefined ? message.proof : new Uint8Array()));
        message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionConsensusStateResponse();
        if (object.consensusState !== undefined && object.consensusState !== null) message.consensusState = any_1.Any.fromPartial(object.consensusState);
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== undefined && object.proofHeight !== null) message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        return message;
    }
};
function createBaseQueryConnectionParamsRequest() {
    return {};
}
exports.QueryConnectionParamsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryConnectionParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryConnectionParamsRequest();
        return message;
    }
};
function createBaseQueryConnectionParamsResponse() {
    return {
        params: undefined
    };
}
exports.QueryConnectionParamsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryConnectionParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = client_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? client_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryConnectionParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = client_1.Params.fromPartial(object.params);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
        this.ConnectionParams = this.ConnectionParams.bind(this);
    }
    Connection(request) {
        const data = exports.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data);
        return promise.then((data)=>exports.QueryConnectionResponse.decode(new binary_1.BinaryReader(data)));
    }
    Connections(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data);
        return promise.then((data)=>exports.QueryConnectionsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ClientConnections(request) {
        const data = exports.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data);
        return promise.then((data)=>exports.QueryClientConnectionsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionClientState(request) {
        const data = exports.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data);
        return promise.then((data)=>exports.QueryConnectionClientStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionConsensusState(request) {
        const data = exports.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data);
        return promise.then((data)=>exports.QueryConnectionConsensusStateResponse.decode(new binary_1.BinaryReader(data)));
    }
    ConnectionParams(request = {}) {
        const data = exports.QueryConnectionParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", data);
        return promise.then((data)=>exports.QueryConnectionParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"1e331700686e908b":"43d5n","3adfcdbdb315ba24":"2q35I","ff72ed0738a70ec6":"3w7CV","606a39289d47b20f":"56aJC","f83cead5b8959ffa":"bi36x","5b293826496a704a":"eYjRL"}],"6thki":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Fraction = exports.Header = exports.Misbehaviour = exports.ConsensusState = exports.ClientState = exports.protobufPackage = void 0;
/* eslint-disable */ const duration_1 = require("bba7e60eafea3ae6");
const client_1 = require("8028f5d6520043aa");
const proofs_1 = require("b5115c9ff626603");
const timestamp_1 = require("60a00321dd28656a");
const commitment_1 = require("b4dfd7c6a9c0c822");
const types_1 = require("c0a124ef3f4bee5a");
const validator_1 = require("340f1adab8956153");
const binary_1 = require("9c7faa7d209947c7");
const helpers_1 = require("e4181dcba8da831c");
exports.protobufPackage = "ibc.lightclients.tendermint.v1";
function createBaseClientState() {
    return {
        chainId: "",
        trustLevel: exports.Fraction.fromPartial({}),
        trustingPeriod: duration_1.Duration.fromPartial({}),
        unbondingPeriod: duration_1.Duration.fromPartial({}),
        maxClockDrift: duration_1.Duration.fromPartial({}),
        frozenHeight: client_1.Height.fromPartial({}),
        latestHeight: client_1.Height.fromPartial({}),
        proofSpecs: [],
        upgradePath: [],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false
    };
}
exports.ClientState = {
    typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.chainId !== "") writer.uint32(10).string(message.chainId);
        if (message.trustLevel !== undefined) exports.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        if (message.trustingPeriod !== undefined) duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        if (message.unbondingPeriod !== undefined) duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        if (message.maxClockDrift !== undefined) duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        if (message.frozenHeight !== undefined) client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        if (message.latestHeight !== undefined) client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        for (const v of message.proofSpecs)proofs_1.ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
        for (const v of message.upgradePath)writer.uint32(74).string(v);
        if (message.allowUpdateAfterExpiry === true) writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        if (message.allowUpdateAfterMisbehaviour === true) writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.chainId = reader.string();
                    break;
                case 2:
                    message.trustLevel = exports.Fraction.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.latestHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.upgradePath.push(reader.string());
                    break;
                case 10:
                    message.allowUpdateAfterExpiry = reader.bool();
                    break;
                case 11:
                    message.allowUpdateAfterMisbehaviour = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseClientState();
        if ((0, helpers_1.isSet)(object.chainId)) obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.trustLevel)) obj.trustLevel = exports.Fraction.fromJSON(object.trustLevel);
        if ((0, helpers_1.isSet)(object.trustingPeriod)) obj.trustingPeriod = duration_1.Duration.fromJSON(object.trustingPeriod);
        if ((0, helpers_1.isSet)(object.unbondingPeriod)) obj.unbondingPeriod = duration_1.Duration.fromJSON(object.unbondingPeriod);
        if ((0, helpers_1.isSet)(object.maxClockDrift)) obj.maxClockDrift = duration_1.Duration.fromJSON(object.maxClockDrift);
        if ((0, helpers_1.isSet)(object.frozenHeight)) obj.frozenHeight = client_1.Height.fromJSON(object.frozenHeight);
        if ((0, helpers_1.isSet)(object.latestHeight)) obj.latestHeight = client_1.Height.fromJSON(object.latestHeight);
        if (Array.isArray(object?.proofSpecs)) obj.proofSpecs = object.proofSpecs.map((e)=>proofs_1.ProofSpec.fromJSON(e));
        if (Array.isArray(object?.upgradePath)) obj.upgradePath = object.upgradePath.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.allowUpdateAfterExpiry)) obj.allowUpdateAfterExpiry = Boolean(object.allowUpdateAfterExpiry);
        if ((0, helpers_1.isSet)(object.allowUpdateAfterMisbehaviour)) obj.allowUpdateAfterMisbehaviour = Boolean(object.allowUpdateAfterMisbehaviour);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.trustLevel !== undefined && (obj.trustLevel = message.trustLevel ? exports.Fraction.toJSON(message.trustLevel) : undefined);
        message.trustingPeriod !== undefined && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : undefined);
        message.unbondingPeriod !== undefined && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : undefined);
        message.maxClockDrift !== undefined && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : undefined);
        message.frozenHeight !== undefined && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : undefined);
        message.latestHeight !== undefined && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : undefined);
        if (message.proofSpecs) obj.proofSpecs = message.proofSpecs.map((e)=>e ? proofs_1.ProofSpec.toJSON(e) : undefined);
        else obj.proofSpecs = [];
        if (message.upgradePath) obj.upgradePath = message.upgradePath.map((e)=>e);
        else obj.upgradePath = [];
        message.allowUpdateAfterExpiry !== undefined && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== undefined && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseClientState();
        message.chainId = object.chainId ?? "";
        if (object.trustLevel !== undefined && object.trustLevel !== null) message.trustLevel = exports.Fraction.fromPartial(object.trustLevel);
        if (object.trustingPeriod !== undefined && object.trustingPeriod !== null) message.trustingPeriod = duration_1.Duration.fromPartial(object.trustingPeriod);
        if (object.unbondingPeriod !== undefined && object.unbondingPeriod !== null) message.unbondingPeriod = duration_1.Duration.fromPartial(object.unbondingPeriod);
        if (object.maxClockDrift !== undefined && object.maxClockDrift !== null) message.maxClockDrift = duration_1.Duration.fromPartial(object.maxClockDrift);
        if (object.frozenHeight !== undefined && object.frozenHeight !== null) message.frozenHeight = client_1.Height.fromPartial(object.frozenHeight);
        if (object.latestHeight !== undefined && object.latestHeight !== null) message.latestHeight = client_1.Height.fromPartial(object.latestHeight);
        message.proofSpecs = object.proofSpecs?.map((e)=>proofs_1.ProofSpec.fromPartial(e)) || [];
        message.upgradePath = object.upgradePath?.map((e)=>e) || [];
        message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
        message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
        return message;
    }
};
function createBaseConsensusState() {
    return {
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        root: commitment_1.MerkleRoot.fromPartial({}),
        nextValidatorsHash: new Uint8Array()
    };
}
exports.ConsensusState = {
    typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        if (message.root !== undefined) commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        if (message.nextValidatorsHash.length !== 0) writer.uint32(26).bytes(message.nextValidatorsHash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseConsensusState();
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.root)) obj.root = commitment_1.MerkleRoot.fromJSON(object.root);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash)) obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.root !== undefined && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : undefined);
        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseConsensusState();
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        if (object.root !== undefined && object.root !== null) message.root = commitment_1.MerkleRoot.fromPartial(object.root);
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        return message;
    }
};
function createBaseMisbehaviour() {
    return {
        clientId: "",
        header1: undefined,
        header2: undefined
    };
}
exports.Misbehaviour = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") writer.uint32(10).string(message.clientId);
        if (message.header1 !== undefined) exports.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        if (message.header2 !== undefined) exports.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMisbehaviour();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.header1 = exports.Header.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.header2 = exports.Header.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId)) obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.header1)) obj.header1 = exports.Header.fromJSON(object.header1);
        if ((0, helpers_1.isSet)(object.header2)) obj.header2 = exports.Header.fromJSON(object.header2);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.clientId !== undefined && (obj.clientId = message.clientId);
        message.header1 !== undefined && (obj.header1 = message.header1 ? exports.Header.toJSON(message.header1) : undefined);
        message.header2 !== undefined && (obj.header2 = message.header2 ? exports.Header.toJSON(message.header2) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.header1 !== undefined && object.header1 !== null) message.header1 = exports.Header.fromPartial(object.header1);
        if (object.header2 !== undefined && object.header2 !== null) message.header2 = exports.Header.fromPartial(object.header2);
        return message;
    }
};
function createBaseHeader() {
    return {
        signedHeader: undefined,
        validatorSet: undefined,
        trustedHeight: client_1.Height.fromPartial({}),
        trustedValidators: undefined
    };
}
exports.Header = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Header",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== undefined) types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        if (message.validatorSet !== undefined) validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        if (message.trustedHeight !== undefined) client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        if (message.trustedValidators !== undefined) validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.signedHeader)) obj.signedHeader = types_1.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet)) obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        if ((0, helpers_1.isSet)(object.trustedHeight)) obj.trustedHeight = client_1.Height.fromJSON(object.trustedHeight);
        if ((0, helpers_1.isSet)(object.trustedValidators)) obj.trustedValidators = validator_1.ValidatorSet.fromJSON(object.trustedValidators);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.signedHeader !== undefined && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : undefined);
        message.validatorSet !== undefined && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : undefined);
        message.trustedHeight !== undefined && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : undefined);
        message.trustedValidators !== undefined && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseHeader();
        if (object.signedHeader !== undefined && object.signedHeader !== null) message.signedHeader = types_1.SignedHeader.fromPartial(object.signedHeader);
        if (object.validatorSet !== undefined && object.validatorSet !== null) message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        if (object.trustedHeight !== undefined && object.trustedHeight !== null) message.trustedHeight = client_1.Height.fromPartial(object.trustedHeight);
        if (object.trustedValidators !== undefined && object.trustedValidators !== null) message.trustedValidators = validator_1.ValidatorSet.fromPartial(object.trustedValidators);
        return message;
    }
};
function createBaseFraction() {
    return {
        numerator: BigInt(0),
        denominator: BigInt(0)
    };
}
exports.Fraction = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.numerator !== BigInt(0)) writer.uint32(8).uint64(message.numerator);
        if (message.denominator !== BigInt(0)) writer.uint32(16).uint64(message.denominator);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFraction();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.numerator = reader.uint64();
                    break;
                case 2:
                    message.denominator = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseFraction();
        if ((0, helpers_1.isSet)(object.numerator)) obj.numerator = BigInt(object.numerator.toString());
        if ((0, helpers_1.isSet)(object.denominator)) obj.denominator = BigInt(object.denominator.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.numerator !== undefined && (obj.numerator = (message.numerator || BigInt(0)).toString());
        message.denominator !== undefined && (obj.denominator = (message.denominator || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseFraction();
        if (object.numerator !== undefined && object.numerator !== null) message.numerator = BigInt(object.numerator.toString());
        if (object.denominator !== undefined && object.denominator !== null) message.denominator = BigInt(object.denominator.toString());
        return message;
    }
};

},{"bba7e60eafea3ae6":"clU50","8028f5d6520043aa":"3w7CV","b5115c9ff626603":"3OFfD","60a00321dd28656a":"6J6bq","b4dfd7c6a9c0c822":"iMPyZ","c0a124ef3f4bee5a":"9y1Fs","340f1adab8956153":"5jJLR","9c7faa7d209947c7":"bi36x","e4181dcba8da831c":"eYjRL"}],"9y1Fs":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.ExtendedCommitSig = exports.ExtendedCommit = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgType = exports.protobufPackage = void 0;
/* eslint-disable */ const proof_1 = require("7969b49f8e4c033f");
const types_1 = require("6727ebd291d08881");
const timestamp_1 = require("db077be9a3499434");
const validator_1 = require("a30766dee47f25ef");
const binary_1 = require("e5148c5ff1aa4369");
const helpers_1 = require("6c437763502a0478");
exports.protobufPackage = "tendermint.types";
/** SignedMsgType is a type of signed message in the consensus. */ var SignedMsgType;
(function(SignedMsgType) {
    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
    /** SIGNED_MSG_TYPE_PREVOTE - Votes */ SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
    /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */ SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
    SignedMsgType[SignedMsgType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignedMsgType || (exports.SignedMsgType = SignedMsgType = {}));
function signedMsgTypeFromJSON(object) {
    switch(object){
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SignedMsgType.UNRECOGNIZED;
    }
}
exports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
function signedMsgTypeToJSON(object) {
    switch(object){
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
            return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
            return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
            return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
            return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.signedMsgTypeToJSON = signedMsgTypeToJSON;
function createBasePartSetHeader() {
    return {
        total: 0,
        hash: new Uint8Array()
    };
}
exports.PartSetHeader = {
    typeUrl: "/tendermint.types.PartSetHeader",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== 0) writer.uint32(8).uint32(message.total);
        if (message.hash.length !== 0) writer.uint32(18).bytes(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.total = reader.uint32();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePartSetHeader();
        if ((0, helpers_1.isSet)(object.total)) obj.total = Number(object.total);
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.total !== undefined && (obj.total = Math.round(message.total));
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBasePartSetHeader();
        message.total = object.total ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        return message;
    }
};
function createBasePart() {
    return {
        index: 0,
        bytes: new Uint8Array(),
        proof: proof_1.Proof.fromPartial({})
    };
}
exports.Part = {
    typeUrl: "/tendermint.types.Part",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) writer.uint32(8).uint32(message.index);
        if (message.bytes.length !== 0) writer.uint32(18).bytes(message.bytes);
        if (message.proof !== undefined) proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePart();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.index = reader.uint32();
                    break;
                case 2:
                    message.bytes = reader.bytes();
                    break;
                case 3:
                    message.proof = proof_1.Proof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePart();
        if ((0, helpers_1.isSet)(object.index)) obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.bytes)) obj.bytes = (0, helpers_1.bytesFromBase64)(object.bytes);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.bytes !== undefined && (obj.bytes = (0, helpers_1.base64FromBytes)(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        message.proof !== undefined && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePart();
        message.index = object.index ?? 0;
        message.bytes = object.bytes ?? new Uint8Array();
        if (object.proof !== undefined && object.proof !== null) message.proof = proof_1.Proof.fromPartial(object.proof);
        return message;
    }
};
function createBaseBlockID() {
    return {
        hash: new Uint8Array(),
        partSetHeader: exports.PartSetHeader.fromPartial({})
    };
}
exports.BlockID = {
    typeUrl: "/tendermint.types.BlockID",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) writer.uint32(10).bytes(message.hash);
        if (message.partSetHeader !== undefined) exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBlockID();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.partSetHeader)) obj.partSetHeader = exports.PartSetHeader.fromJSON(object.partSetHeader);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.partSetHeader !== undefined && (obj.partSetHeader = message.partSetHeader ? exports.PartSetHeader.toJSON(message.partSetHeader) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBlockID();
        message.hash = object.hash ?? new Uint8Array();
        if (object.partSetHeader !== undefined && object.partSetHeader !== null) message.partSetHeader = exports.PartSetHeader.fromPartial(object.partSetHeader);
        return message;
    }
};
function createBaseHeader() {
    return {
        version: types_1.Consensus.fromPartial({}),
        chainId: "",
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        lastBlockId: exports.BlockID.fromPartial({}),
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
    };
}
exports.Header = {
    typeUrl: "/tendermint.types.Header",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== undefined) types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        if (message.chainId !== "") writer.uint32(18).string(message.chainId);
        if (message.height !== BigInt(0)) writer.uint32(24).int64(message.height);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        if (message.lastBlockId !== undefined) exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        if (message.lastCommitHash.length !== 0) writer.uint32(50).bytes(message.lastCommitHash);
        if (message.dataHash.length !== 0) writer.uint32(58).bytes(message.dataHash);
        if (message.validatorsHash.length !== 0) writer.uint32(66).bytes(message.validatorsHash);
        if (message.nextValidatorsHash.length !== 0) writer.uint32(74).bytes(message.nextValidatorsHash);
        if (message.consensusHash.length !== 0) writer.uint32(82).bytes(message.consensusHash);
        if (message.appHash.length !== 0) writer.uint32(90).bytes(message.appHash);
        if (message.lastResultsHash.length !== 0) writer.uint32(98).bytes(message.lastResultsHash);
        if (message.evidenceHash.length !== 0) writer.uint32(106).bytes(message.evidenceHash);
        if (message.proposerAddress.length !== 0) writer.uint32(114).bytes(message.proposerAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.version = types_1.Consensus.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.height = reader.int64();
                    break;
                case 4:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.lastCommitHash = reader.bytes();
                    break;
                case 7:
                    message.dataHash = reader.bytes();
                    break;
                case 8:
                    message.validatorsHash = reader.bytes();
                    break;
                case 9:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case 10:
                    message.consensusHash = reader.bytes();
                    break;
                case 11:
                    message.appHash = reader.bytes();
                    break;
                case 12:
                    message.lastResultsHash = reader.bytes();
                    break;
                case 13:
                    message.evidenceHash = reader.bytes();
                    break;
                case 14:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.version)) obj.version = types_1.Consensus.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.chainId)) obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.lastBlockId)) obj.lastBlockId = exports.BlockID.fromJSON(object.lastBlockId);
        if ((0, helpers_1.isSet)(object.lastCommitHash)) obj.lastCommitHash = (0, helpers_1.bytesFromBase64)(object.lastCommitHash);
        if ((0, helpers_1.isSet)(object.dataHash)) obj.dataHash = (0, helpers_1.bytesFromBase64)(object.dataHash);
        if ((0, helpers_1.isSet)(object.validatorsHash)) obj.validatorsHash = (0, helpers_1.bytesFromBase64)(object.validatorsHash);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash)) obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.consensusHash)) obj.consensusHash = (0, helpers_1.bytesFromBase64)(object.consensusHash);
        if ((0, helpers_1.isSet)(object.appHash)) obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        if ((0, helpers_1.isSet)(object.lastResultsHash)) obj.lastResultsHash = (0, helpers_1.bytesFromBase64)(object.lastResultsHash);
        if ((0, helpers_1.isSet)(object.evidenceHash)) obj.evidenceHash = (0, helpers_1.bytesFromBase64)(object.evidenceHash);
        if ((0, helpers_1.isSet)(object.proposerAddress)) obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.version !== undefined && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : undefined);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.lastBlockId !== undefined && (obj.lastBlockId = message.lastBlockId ? exports.BlockID.toJSON(message.lastBlockId) : undefined);
        message.lastCommitHash !== undefined && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== undefined ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== undefined && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== undefined ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== undefined && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== undefined ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== undefined && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== undefined ? message.consensusHash : new Uint8Array()));
        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== undefined && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== undefined ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== undefined && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== undefined ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseHeader();
        if (object.version !== undefined && object.version !== null) message.version = types_1.Consensus.fromPartial(object.version);
        message.chainId = object.chainId ?? "";
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        if (object.lastBlockId !== undefined && object.lastBlockId !== null) message.lastBlockId = exports.BlockID.fromPartial(object.lastBlockId);
        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
        message.dataHash = object.dataHash ?? new Uint8Array();
        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.consensusHash = object.consensusHash ?? new Uint8Array();
        message.appHash = object.appHash ?? new Uint8Array();
        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
    }
};
function createBaseData() {
    return {
        txs: []
    };
}
exports.Data = {
    typeUrl: "/tendermint.types.Data",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseData();
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.txs) obj.txs = message.txs.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.txs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseData();
        message.txs = object.txs?.map((e)=>e) || [];
        return message;
    }
};
function createBaseVote() {
    return {
        type: 0,
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
    };
}
exports.Vote = {
    typeUrl: "/tendermint.types.Vote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) writer.uint32(8).int32(message.type);
        if (message.height !== BigInt(0)) writer.uint32(16).int64(message.height);
        if (message.round !== 0) writer.uint32(24).int32(message.round);
        if (message.blockId !== undefined) exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        if (message.validatorAddress.length !== 0) writer.uint32(50).bytes(message.validatorAddress);
        if (message.validatorIndex !== 0) writer.uint32(56).int32(message.validatorIndex);
        if (message.signature.length !== 0) writer.uint32(66).bytes(message.signature);
        if (message.extension.length !== 0) writer.uint32(74).bytes(message.extension);
        if (message.extensionSignature.length !== 0) writer.uint32(82).bytes(message.extensionSignature);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.height = reader.int64();
                    break;
                case 3:
                    message.round = reader.int32();
                    break;
                case 4:
                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.validatorAddress = reader.bytes();
                    break;
                case 7:
                    message.validatorIndex = reader.int32();
                    break;
                case 8:
                    message.signature = reader.bytes();
                    break;
                case 9:
                    message.extension = reader.bytes();
                    break;
                case 10:
                    message.extensionSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.type)) obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round)) obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId)) obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.validatorIndex)) obj.validatorIndex = Number(object.validatorIndex);
        if ((0, helpers_1.isSet)(object.signature)) obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension)) obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature)) obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== undefined && (obj.round = Math.round(message.round));
        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.validatorAddress !== undefined && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== undefined ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== undefined && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
        message.extension !== undefined && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== undefined ? message.extension : new Uint8Array()));
        message.extensionSignature !== undefined && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== undefined ? message.extensionSignature : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVote();
        message.type = object.type ?? 0;
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.round = object.round ?? 0;
        if (object.blockId !== undefined && object.blockId !== null) message.blockId = exports.BlockID.fromPartial(object.blockId);
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        message.validatorIndex = object.validatorIndex ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
    }
};
function createBaseCommit() {
    return {
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        signatures: []
    };
}
exports.Commit = {
    typeUrl: "/tendermint.types.Commit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).int64(message.height);
        if (message.round !== 0) writer.uint32(16).int32(message.round);
        if (message.blockId !== undefined) exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        for (const v of message.signatures)exports.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.int64();
                    break;
                case 2:
                    message.round = reader.int32();
                    break;
                case 3:
                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommit();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round)) obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId)) obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object?.signatures)) obj.signatures = object.signatures.map((e)=>exports.CommitSig.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== undefined && (obj.round = Math.round(message.round));
        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
        if (message.signatures) obj.signatures = message.signatures.map((e)=>e ? exports.CommitSig.toJSON(e) : undefined);
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommit();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.round = object.round ?? 0;
        if (object.blockId !== undefined && object.blockId !== null) message.blockId = exports.BlockID.fromPartial(object.blockId);
        message.signatures = object.signatures?.map((e)=>exports.CommitSig.fromPartial(e)) || [];
        return message;
    }
};
function createBaseCommitSig() {
    return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
    };
}
exports.CommitSig = {
    typeUrl: "/tendermint.types.CommitSig",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) writer.uint32(8).int32(message.blockIdFlag);
        if (message.validatorAddress.length !== 0) writer.uint32(18).bytes(message.validatorAddress);
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        if (message.signature.length !== 0) writer.uint32(34).bytes(message.signature);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.blockIdFlag = reader.int32();
                    break;
                case 2:
                    message.validatorAddress = reader.bytes();
                    break;
                case 3:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag)) obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature)) obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.blockIdFlag !== undefined && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== undefined && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== undefined ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        message.signature = object.signature ?? new Uint8Array();
        return message;
    }
};
function createBaseExtendedCommit() {
    return {
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        extendedSignatures: []
    };
}
exports.ExtendedCommit = {
    typeUrl: "/tendermint.types.ExtendedCommit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).int64(message.height);
        if (message.round !== 0) writer.uint32(16).int32(message.round);
        if (message.blockId !== undefined) exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        for (const v of message.extendedSignatures)exports.ExtendedCommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.int64();
                    break;
                case 2:
                    message.round = reader.int32();
                    break;
                case 3:
                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.extendedSignatures.push(exports.ExtendedCommitSig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseExtendedCommit();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round)) obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId)) obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object?.extendedSignatures)) obj.extendedSignatures = object.extendedSignatures.map((e)=>exports.ExtendedCommitSig.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== undefined && (obj.round = Math.round(message.round));
        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
        if (message.extendedSignatures) obj.extendedSignatures = message.extendedSignatures.map((e)=>e ? exports.ExtendedCommitSig.toJSON(e) : undefined);
        else obj.extendedSignatures = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseExtendedCommit();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.round = object.round ?? 0;
        if (object.blockId !== undefined && object.blockId !== null) message.blockId = exports.BlockID.fromPartial(object.blockId);
        message.extendedSignatures = object.extendedSignatures?.map((e)=>exports.ExtendedCommitSig.fromPartial(e)) || [];
        return message;
    }
};
function createBaseExtendedCommitSig() {
    return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
    };
}
exports.ExtendedCommitSig = {
    typeUrl: "/tendermint.types.ExtendedCommitSig",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) writer.uint32(8).int32(message.blockIdFlag);
        if (message.validatorAddress.length !== 0) writer.uint32(18).bytes(message.validatorAddress);
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        if (message.signature.length !== 0) writer.uint32(34).bytes(message.signature);
        if (message.extension.length !== 0) writer.uint32(42).bytes(message.extension);
        if (message.extensionSignature.length !== 0) writer.uint32(50).bytes(message.extensionSignature);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitSig();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.blockIdFlag = reader.int32();
                    break;
                case 2:
                    message.validatorAddress = reader.bytes();
                    break;
                case 3:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signature = reader.bytes();
                    break;
                case 5:
                    message.extension = reader.bytes();
                    break;
                case 6:
                    message.extensionSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseExtendedCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag)) obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature)) obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension)) obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature)) obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.blockIdFlag !== undefined && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== undefined && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== undefined ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
        message.extension !== undefined && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== undefined ? message.extension : new Uint8Array()));
        message.extensionSignature !== undefined && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== undefined ? message.extensionSignature : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseExtendedCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
    }
};
function createBaseProposal() {
    return {
        type: 0,
        height: BigInt(0),
        round: 0,
        polRound: 0,
        blockId: exports.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
    };
}
exports.Proposal = {
    typeUrl: "/tendermint.types.Proposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) writer.uint32(8).int32(message.type);
        if (message.height !== BigInt(0)) writer.uint32(16).int64(message.height);
        if (message.round !== 0) writer.uint32(24).int32(message.round);
        if (message.polRound !== 0) writer.uint32(32).int32(message.polRound);
        if (message.blockId !== undefined) exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        if (message.signature.length !== 0) writer.uint32(58).bytes(message.signature);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.height = reader.int64();
                    break;
                case 3:
                    message.round = reader.int32();
                    break;
                case 4:
                    message.polRound = reader.int32();
                    break;
                case 5:
                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.type)) obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round)) obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.polRound)) obj.polRound = Number(object.polRound);
        if ((0, helpers_1.isSet)(object.blockId)) obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature)) obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== undefined && (obj.round = Math.round(message.round));
        message.polRound !== undefined && (obj.polRound = Math.round(message.polRound));
        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== undefined && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProposal();
        message.type = object.type ?? 0;
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.round = object.round ?? 0;
        message.polRound = object.polRound ?? 0;
        if (object.blockId !== undefined && object.blockId !== null) message.blockId = exports.BlockID.fromPartial(object.blockId);
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        message.signature = object.signature ?? new Uint8Array();
        return message;
    }
};
function createBaseSignedHeader() {
    return {
        header: undefined,
        commit: undefined
    };
}
exports.SignedHeader = {
    typeUrl: "/tendermint.types.SignedHeader",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== undefined) exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        if (message.commit !== undefined) exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.header = exports.Header.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.commit = exports.Commit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSignedHeader();
        if ((0, helpers_1.isSet)(object.header)) obj.header = exports.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.commit)) obj.commit = exports.Commit.fromJSON(object.commit);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.header !== undefined && (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);
        message.commit !== undefined && (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignedHeader();
        if (object.header !== undefined && object.header !== null) message.header = exports.Header.fromPartial(object.header);
        if (object.commit !== undefined && object.commit !== null) message.commit = exports.Commit.fromPartial(object.commit);
        return message;
    }
};
function createBaseLightBlock() {
    return {
        signedHeader: undefined,
        validatorSet: undefined
    };
}
exports.LightBlock = {
    typeUrl: "/tendermint.types.LightBlock",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== undefined) exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        if (message.validatorSet !== undefined) validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseLightBlock();
        if ((0, helpers_1.isSet)(object.signedHeader)) obj.signedHeader = exports.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet)) obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.signedHeader !== undefined && (obj.signedHeader = message.signedHeader ? exports.SignedHeader.toJSON(message.signedHeader) : undefined);
        message.validatorSet !== undefined && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseLightBlock();
        if (object.signedHeader !== undefined && object.signedHeader !== null) message.signedHeader = exports.SignedHeader.fromPartial(object.signedHeader);
        if (object.validatorSet !== undefined && object.validatorSet !== null) message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        return message;
    }
};
function createBaseBlockMeta() {
    return {
        blockId: exports.BlockID.fromPartial({}),
        blockSize: BigInt(0),
        header: exports.Header.fromPartial({}),
        numTxs: BigInt(0)
    };
}
exports.BlockMeta = {
    typeUrl: "/tendermint.types.BlockMeta",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockId !== undefined) exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        if (message.blockSize !== BigInt(0)) writer.uint32(16).int64(message.blockSize);
        if (message.header !== undefined) exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        if (message.numTxs !== BigInt(0)) writer.uint32(32).int64(message.numTxs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.blockId = exports.BlockID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.blockSize = reader.int64();
                    break;
                case 3:
                    message.header = exports.Header.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.numTxs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBlockMeta();
        if ((0, helpers_1.isSet)(object.blockId)) obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.blockSize)) obj.blockSize = BigInt(object.blockSize.toString());
        if ((0, helpers_1.isSet)(object.header)) obj.header = exports.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.numTxs)) obj.numTxs = BigInt(object.numTxs.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.blockId !== undefined && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : undefined);
        message.blockSize !== undefined && (obj.blockSize = (message.blockSize || BigInt(0)).toString());
        message.header !== undefined && (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);
        message.numTxs !== undefined && (obj.numTxs = (message.numTxs || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBlockMeta();
        if (object.blockId !== undefined && object.blockId !== null) message.blockId = exports.BlockID.fromPartial(object.blockId);
        if (object.blockSize !== undefined && object.blockSize !== null) message.blockSize = BigInt(object.blockSize.toString());
        if (object.header !== undefined && object.header !== null) message.header = exports.Header.fromPartial(object.header);
        if (object.numTxs !== undefined && object.numTxs !== null) message.numTxs = BigInt(object.numTxs.toString());
        return message;
    }
};
function createBaseTxProof() {
    return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: undefined
    };
}
exports.TxProof = {
    typeUrl: "/tendermint.types.TxProof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.rootHash.length !== 0) writer.uint32(10).bytes(message.rootHash);
        if (message.data.length !== 0) writer.uint32(18).bytes(message.data);
        if (message.proof !== undefined) proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rootHash = reader.bytes();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.proof = proof_1.Proof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxProof();
        if ((0, helpers_1.isSet)(object.rootHash)) obj.rootHash = (0, helpers_1.bytesFromBase64)(object.rootHash);
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.rootHash !== undefined && (obj.rootHash = (0, helpers_1.base64FromBytes)(message.rootHash !== undefined ? message.rootHash : new Uint8Array()));
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.proof !== undefined && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxProof();
        message.rootHash = object.rootHash ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        if (object.proof !== undefined && object.proof !== null) message.proof = proof_1.Proof.fromPartial(object.proof);
        return message;
    }
};

},{"7969b49f8e4c033f":"2ydwn","6727ebd291d08881":"iMIIP","db077be9a3499434":"6J6bq","a30766dee47f25ef":"5jJLR","e5148c5ff1aa4369":"bi36x","6c437763502a0478":"eYjRL"}],"2ydwn":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("32e30cdbc93d9e3f");
const helpers_1 = require("cb22a9748bd1f1fd");
exports.protobufPackage = "tendermint.crypto";
function createBaseProof() {
    return {
        total: BigInt(0),
        index: BigInt(0),
        leafHash: new Uint8Array(),
        aunts: []
    };
}
exports.Proof = {
    typeUrl: "/tendermint.crypto.Proof",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== BigInt(0)) writer.uint32(8).int64(message.total);
        if (message.index !== BigInt(0)) writer.uint32(16).int64(message.index);
        if (message.leafHash.length !== 0) writer.uint32(26).bytes(message.leafHash);
        for (const v of message.aunts)writer.uint32(34).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.total = reader.int64();
                    break;
                case 2:
                    message.index = reader.int64();
                    break;
                case 3:
                    message.leafHash = reader.bytes();
                    break;
                case 4:
                    message.aunts.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProof();
        if ((0, helpers_1.isSet)(object.total)) obj.total = BigInt(object.total.toString());
        if ((0, helpers_1.isSet)(object.index)) obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.leafHash)) obj.leafHash = (0, helpers_1.bytesFromBase64)(object.leafHash);
        if (Array.isArray(object?.aunts)) obj.aunts = object.aunts.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.total !== undefined && (obj.total = (message.total || BigInt(0)).toString());
        message.index !== undefined && (obj.index = (message.index || BigInt(0)).toString());
        message.leafHash !== undefined && (obj.leafHash = (0, helpers_1.base64FromBytes)(message.leafHash !== undefined ? message.leafHash : new Uint8Array()));
        if (message.aunts) obj.aunts = message.aunts.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.aunts = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProof();
        if (object.total !== undefined && object.total !== null) message.total = BigInt(object.total.toString());
        if (object.index !== undefined && object.index !== null) message.index = BigInt(object.index.toString());
        message.leafHash = object.leafHash ?? new Uint8Array();
        message.aunts = object.aunts?.map((e)=>e) || [];
        return message;
    }
};
function createBaseValueOp() {
    return {
        key: new Uint8Array(),
        proof: undefined
    };
}
exports.ValueOp = {
    typeUrl: "/tendermint.crypto.ValueOp",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) writer.uint32(10).bytes(message.key);
        if (message.proof !== undefined) exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.proof = exports.Proof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValueOp();
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.proof)) obj.proof = exports.Proof.fromJSON(object.proof);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.proof !== undefined && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValueOp();
        message.key = object.key ?? new Uint8Array();
        if (object.proof !== undefined && object.proof !== null) message.proof = exports.Proof.fromPartial(object.proof);
        return message;
    }
};
function createBaseDominoOp() {
    return {
        key: "",
        input: "",
        output: ""
    };
}
exports.DominoOp = {
    typeUrl: "/tendermint.crypto.DominoOp",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.input !== "") writer.uint32(18).string(message.input);
        if (message.output !== "") writer.uint32(26).string(message.output);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.input = reader.string();
                    break;
                case 3:
                    message.output = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDominoOp();
        if ((0, helpers_1.isSet)(object.key)) obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.input)) obj.input = String(object.input);
        if ((0, helpers_1.isSet)(object.output)) obj.output = String(object.output);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.input !== undefined && (obj.input = message.input);
        message.output !== undefined && (obj.output = message.output);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDominoOp();
        message.key = object.key ?? "";
        message.input = object.input ?? "";
        message.output = object.output ?? "";
        return message;
    }
};
function createBaseProofOp() {
    return {
        type: "",
        key: new Uint8Array(),
        data: new Uint8Array()
    };
}
exports.ProofOp = {
    typeUrl: "/tendermint.crypto.ProofOp",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") writer.uint32(10).string(message.type);
        if (message.key.length !== 0) writer.uint32(18).bytes(message.key);
        if (message.data.length !== 0) writer.uint32(26).bytes(message.data);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProofOp();
        if ((0, helpers_1.isSet)(object.type)) obj.type = String(object.type);
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProofOp();
        message.type = object.type ?? "";
        message.key = object.key ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        return message;
    }
};
function createBaseProofOps() {
    return {
        ops: []
    };
}
exports.ProofOps = {
    typeUrl: "/tendermint.crypto.ProofOps",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.ops)exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseProofOps();
        if (Array.isArray(object?.ops)) obj.ops = object.ops.map((e)=>exports.ProofOp.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.ops) obj.ops = message.ops.map((e)=>e ? exports.ProofOp.toJSON(e) : undefined);
        else obj.ops = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseProofOps();
        message.ops = object.ops?.map((e)=>exports.ProofOp.fromPartial(e)) || [];
        return message;
    }
};

},{"32e30cdbc93d9e3f":"bi36x","cb22a9748bd1f1fd":"eYjRL"}],"iMIIP":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Consensus = exports.App = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("f3dcfd0559915084");
const helpers_1 = require("d8cf8cc226dbf22");
exports.protobufPackage = "tendermint.version";
function createBaseApp() {
    return {
        protocol: BigInt(0),
        software: ""
    };
}
exports.App = {
    typeUrl: "/tendermint.version.App",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.protocol !== BigInt(0)) writer.uint32(8).uint64(message.protocol);
        if (message.software !== "") writer.uint32(18).string(message.software);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.protocol = reader.uint64();
                    break;
                case 2:
                    message.software = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseApp();
        if ((0, helpers_1.isSet)(object.protocol)) obj.protocol = BigInt(object.protocol.toString());
        if ((0, helpers_1.isSet)(object.software)) obj.software = String(object.software);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.protocol !== undefined && (obj.protocol = (message.protocol || BigInt(0)).toString());
        message.software !== undefined && (obj.software = message.software);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseApp();
        if (object.protocol !== undefined && object.protocol !== null) message.protocol = BigInt(object.protocol.toString());
        message.software = object.software ?? "";
        return message;
    }
};
function createBaseConsensus() {
    return {
        block: BigInt(0),
        app: BigInt(0)
    };
}
exports.Consensus = {
    typeUrl: "/tendermint.version.Consensus",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== BigInt(0)) writer.uint32(8).uint64(message.block);
        if (message.app !== BigInt(0)) writer.uint32(16).uint64(message.app);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.block = reader.uint64();
                    break;
                case 2:
                    message.app = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseConsensus();
        if ((0, helpers_1.isSet)(object.block)) obj.block = BigInt(object.block.toString());
        if ((0, helpers_1.isSet)(object.app)) obj.app = BigInt(object.app.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.block !== undefined && (obj.block = (message.block || BigInt(0)).toString());
        message.app !== undefined && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseConsensus();
        if (object.block !== undefined && object.block !== null) message.block = BigInt(object.block.toString());
        if (object.app !== undefined && object.app !== null) message.app = BigInt(object.app.toString());
        return message;
    }
};

},{"f3dcfd0559915084":"bi36x","d8cf8cc226dbf22":"eYjRL"}],"5jJLR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlag = exports.protobufPackage = void 0;
/* eslint-disable */ const keys_1 = require("e28c2ed915e0901c");
const binary_1 = require("1217b0f6aec9986c");
const helpers_1 = require("65aaa9a17c202a57");
exports.protobufPackage = "tendermint.types";
/** BlockIdFlag indicates which BlockID the signature is for */ var BlockIDFlag;
(function(BlockIDFlag) {
    /** BLOCK_ID_FLAG_UNKNOWN - indicates an error condition */ BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
    /** BLOCK_ID_FLAG_ABSENT - the vote was not received */ BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
    /** BLOCK_ID_FLAG_NIL - voted for nil */ BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
    BlockIDFlag[BlockIDFlag["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockIDFlag || (exports.BlockIDFlag = BlockIDFlag = {}));
function blockIDFlagFromJSON(object) {
    switch(object){
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
            return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BlockIDFlag.UNRECOGNIZED;
    }
}
exports.blockIDFlagFromJSON = blockIDFlagFromJSON;
function blockIDFlagToJSON(object) {
    switch(object){
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
            return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
            return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
            return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
            return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.blockIDFlagToJSON = blockIDFlagToJSON;
function createBaseValidatorSet() {
    return {
        validators: [],
        proposer: undefined,
        totalVotingPower: BigInt(0)
    };
}
exports.ValidatorSet = {
    typeUrl: "/tendermint.types.ValidatorSet",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators)exports.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.proposer !== undefined) exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        if (message.totalVotingPower !== BigInt(0)) writer.uint32(24).int64(message.totalVotingPower);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validators.push(exports.Validator.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.proposer = exports.Validator.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.totalVotingPower = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorSet();
        if (Array.isArray(object?.validators)) obj.validators = object.validators.map((e)=>exports.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer)) obj.proposer = exports.Validator.fromJSON(object.proposer);
        if ((0, helpers_1.isSet)(object.totalVotingPower)) obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.validators) obj.validators = message.validators.map((e)=>e ? exports.Validator.toJSON(e) : undefined);
        else obj.validators = [];
        message.proposer !== undefined && (obj.proposer = message.proposer ? exports.Validator.toJSON(message.proposer) : undefined);
        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorSet();
        message.validators = object.validators?.map((e)=>exports.Validator.fromPartial(e)) || [];
        if (object.proposer !== undefined && object.proposer !== null) message.proposer = exports.Validator.fromPartial(object.proposer);
        if (object.totalVotingPower !== undefined && object.totalVotingPower !== null) message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return message;
    }
};
function createBaseValidator() {
    return {
        address: new Uint8Array(),
        pubKey: keys_1.PublicKey.fromPartial({}),
        votingPower: BigInt(0),
        proposerPriority: BigInt(0)
    };
}
exports.Validator = {
    typeUrl: "/tendermint.types.Validator",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) writer.uint32(10).bytes(message.address);
        if (message.pubKey !== undefined) keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        if (message.votingPower !== BigInt(0)) writer.uint32(24).int64(message.votingPower);
        if (message.proposerPriority !== BigInt(0)) writer.uint32(32).int64(message.proposerPriority);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.votingPower = reader.int64();
                    break;
                case 4:
                    message.proposerPriority = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address)) obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.pubKey)) obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower)) obj.votingPower = BigInt(object.votingPower.toString());
        if ((0, helpers_1.isSet)(object.proposerPriority)) obj.proposerPriority = BigInt(object.proposerPriority.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== undefined ? message.address : new Uint8Array()));
        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);
        message.votingPower !== undefined && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        message.proposerPriority !== undefined && (obj.proposerPriority = (message.proposerPriority || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.pubKey !== undefined && object.pubKey !== null) message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        if (object.votingPower !== undefined && object.votingPower !== null) message.votingPower = BigInt(object.votingPower.toString());
        if (object.proposerPriority !== undefined && object.proposerPriority !== null) message.proposerPriority = BigInt(object.proposerPriority.toString());
        return message;
    }
};
function createBaseSimpleValidator() {
    return {
        pubKey: undefined,
        votingPower: BigInt(0)
    };
}
exports.SimpleValidator = {
    typeUrl: "/tendermint.types.SimpleValidator",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== undefined) keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        if (message.votingPower !== BigInt(0)) writer.uint32(16).int64(message.votingPower);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.votingPower = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSimpleValidator();
        if ((0, helpers_1.isSet)(object.pubKey)) obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower)) obj.votingPower = BigInt(object.votingPower.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);
        message.votingPower !== undefined && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSimpleValidator();
        if (object.pubKey !== undefined && object.pubKey !== null) message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        if (object.votingPower !== undefined && object.votingPower !== null) message.votingPower = BigInt(object.votingPower.toString());
        return message;
    }
};

},{"e28c2ed915e0901c":"gKtAr","1217b0f6aec9986c":"bi36x","65aaa9a17c202a57":"eYjRL"}],"gKtAr":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PublicKey = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("2d366596d6e74b6d");
const helpers_1 = require("e6b49c8fed0043c");
exports.protobufPackage = "tendermint.crypto";
function createBasePublicKey() {
    return {
        ed25519: undefined,
        secp256k1: undefined
    };
}
exports.PublicKey = {
    typeUrl: "/tendermint.crypto.PublicKey",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.ed25519 !== undefined) writer.uint32(10).bytes(message.ed25519);
        if (message.secp256k1 !== undefined) writer.uint32(18).bytes(message.secp256k1);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                case 2:
                    message.secp256k1 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePublicKey();
        if ((0, helpers_1.isSet)(object.ed25519)) obj.ed25519 = (0, helpers_1.bytesFromBase64)(object.ed25519);
        if ((0, helpers_1.isSet)(object.secp256k1)) obj.secp256k1 = (0, helpers_1.bytesFromBase64)(object.secp256k1);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.ed25519 !== undefined && (obj.ed25519 = message.ed25519 !== undefined ? (0, helpers_1.base64FromBytes)(message.ed25519) : undefined);
        message.secp256k1 !== undefined && (obj.secp256k1 = message.secp256k1 !== undefined ? (0, helpers_1.base64FromBytes)(message.secp256k1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePublicKey();
        message.ed25519 = object.ed25519 ?? undefined;
        message.secp256k1 = object.secp256k1 ?? undefined;
        return message;
    }
};

},{"2d366596d6e74b6d":"bi36x","e6b49c8fed0043c":"eYjRL"}],"a3Cbf":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupMintExtension = setupMintExtension;
const utils_1 = require("ac66300abaaab2ab");
const query_1 = require("177dfab990600136");
const queryclient_1 = require("bcd4ec99970cac98");
function setupMintExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        mint: {
            params: async ()=>{
                const { params } = await queryService.Params({});
                (0, utils_1.assert)(params);
                return {
                    blocksPerYear: params.blocksPerYear,
                    goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
                    inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
                    inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
                    inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
                    mintDenom: params.mintDenom
                };
            },
            inflation: async ()=>{
                const { inflation } = await queryService.Inflation({});
                return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
            },
            annualProvisions: async ()=>{
                const { annualProvisions } = await queryService.AnnualProvisions({});
                return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
            }
        }
    };
}

},{"ac66300abaaab2ab":"3R4mb","177dfab990600136":"eUdoR","bcd4ec99970cac98":"cM4fi"}],"eUdoR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryAnnualProvisionsResponse = exports.QueryAnnualProvisionsRequest = exports.QueryInflationResponse = exports.QueryInflationRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const mint_1 = require("8f16cd047505ee4a");
const binary_1 = require("60d56d9ecfa12904");
const helpers_1 = require("fa547f1820d5d282");
exports.protobufPackage = "cosmos.mint.v1beta1";
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: mint_1.Params.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = mint_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = mint_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = mint_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQueryInflationRequest() {
    return {};
}
exports.QueryInflationRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryInflationRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryInflationRequest();
        return message;
    }
};
function createBaseQueryInflationResponse() {
    return {
        inflation: new Uint8Array()
    };
}
exports.QueryInflationResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation.length !== 0) writer.uint32(10).bytes(message.inflation);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inflation = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryInflationResponse();
        if ((0, helpers_1.isSet)(object.inflation)) obj.inflation = (0, helpers_1.bytesFromBase64)(object.inflation);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.inflation !== undefined && (obj.inflation = (0, helpers_1.base64FromBytes)(message.inflation !== undefined ? message.inflation : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryInflationResponse();
        message.inflation = object.inflation ?? new Uint8Array();
        return message;
    }
};
function createBaseQueryAnnualProvisionsRequest() {
    return {};
}
exports.QueryAnnualProvisionsRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryAnnualProvisionsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryAnnualProvisionsRequest();
        return message;
    }
};
function createBaseQueryAnnualProvisionsResponse() {
    return {
        annualProvisions: new Uint8Array()
    };
}
exports.QueryAnnualProvisionsResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.annualProvisions.length !== 0) writer.uint32(10).bytes(message.annualProvisions);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.annualProvisions = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryAnnualProvisionsResponse();
        if ((0, helpers_1.isSet)(object.annualProvisions)) obj.annualProvisions = (0, helpers_1.bytesFromBase64)(object.annualProvisions);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.annualProvisions !== undefined && (obj.annualProvisions = (0, helpers_1.base64FromBytes)(message.annualProvisions !== undefined ? message.annualProvisions : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryAnnualProvisionsResponse();
        message.annualProvisions = object.annualProvisions ?? new Uint8Array();
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Inflation(request = {}) {
        const data = exports.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data);
        return promise.then((data)=>exports.QueryInflationResponse.decode(new binary_1.BinaryReader(data)));
    }
    AnnualProvisions(request = {}) {
        const data = exports.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data);
        return promise.then((data)=>exports.QueryAnnualProvisionsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"8f16cd047505ee4a":"jQ0AR","60d56d9ecfa12904":"bi36x","fa547f1820d5d282":"eYjRL"}],"jQ0AR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.Minter = exports.protobufPackage = void 0;
/* eslint-disable */ const binary_1 = require("f454863831c70445");
const helpers_1 = require("f1efe0ac403040f4");
exports.protobufPackage = "cosmos.mint.v1beta1";
function createBaseMinter() {
    return {
        inflation: "",
        annualProvisions: ""
    };
}
exports.Minter = {
    typeUrl: "/cosmos.mint.v1beta1.Minter",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation !== "") writer.uint32(10).string(message.inflation);
        if (message.annualProvisions !== "") writer.uint32(18).string(message.annualProvisions);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMinter();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inflation = reader.string();
                    break;
                case 2:
                    message.annualProvisions = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMinter();
        if ((0, helpers_1.isSet)(object.inflation)) obj.inflation = String(object.inflation);
        if ((0, helpers_1.isSet)(object.annualProvisions)) obj.annualProvisions = String(object.annualProvisions);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.inflation !== undefined && (obj.inflation = message.inflation);
        message.annualProvisions !== undefined && (obj.annualProvisions = message.annualProvisions);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMinter();
        message.inflation = object.inflation ?? "";
        message.annualProvisions = object.annualProvisions ?? "";
        return message;
    }
};
function createBaseParams() {
    return {
        mintDenom: "",
        inflationRateChange: "",
        inflationMax: "",
        inflationMin: "",
        goalBonded: "",
        blocksPerYear: BigInt(0)
    };
}
exports.Params = {
    typeUrl: "/cosmos.mint.v1beta1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.mintDenom !== "") writer.uint32(10).string(message.mintDenom);
        if (message.inflationRateChange !== "") writer.uint32(18).string(message.inflationRateChange);
        if (message.inflationMax !== "") writer.uint32(26).string(message.inflationMax);
        if (message.inflationMin !== "") writer.uint32(34).string(message.inflationMin);
        if (message.goalBonded !== "") writer.uint32(42).string(message.goalBonded);
        if (message.blocksPerYear !== BigInt(0)) writer.uint32(48).uint64(message.blocksPerYear);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.mintDenom = reader.string();
                    break;
                case 2:
                    message.inflationRateChange = reader.string();
                    break;
                case 3:
                    message.inflationMax = reader.string();
                    break;
                case 4:
                    message.inflationMin = reader.string();
                    break;
                case 5:
                    message.goalBonded = reader.string();
                    break;
                case 6:
                    message.blocksPerYear = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.mintDenom)) obj.mintDenom = String(object.mintDenom);
        if ((0, helpers_1.isSet)(object.inflationRateChange)) obj.inflationRateChange = String(object.inflationRateChange);
        if ((0, helpers_1.isSet)(object.inflationMax)) obj.inflationMax = String(object.inflationMax);
        if ((0, helpers_1.isSet)(object.inflationMin)) obj.inflationMin = String(object.inflationMin);
        if ((0, helpers_1.isSet)(object.goalBonded)) obj.goalBonded = String(object.goalBonded);
        if ((0, helpers_1.isSet)(object.blocksPerYear)) obj.blocksPerYear = BigInt(object.blocksPerYear.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.mintDenom !== undefined && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== undefined && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== undefined && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== undefined && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== undefined && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== undefined && (obj.blocksPerYear = (message.blocksPerYear || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.mintDenom = object.mintDenom ?? "";
        message.inflationRateChange = object.inflationRateChange ?? "";
        message.inflationMax = object.inflationMax ?? "";
        message.inflationMin = object.inflationMin ?? "";
        message.goalBonded = object.goalBonded ?? "";
        if (object.blocksPerYear !== undefined && object.blocksPerYear !== null) message.blocksPerYear = BigInt(object.blocksPerYear.toString());
        return message;
    }
};

},{"f454863831c70445":"bi36x","f1efe0ac403040f4":"eYjRL"}],"9djfx":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgUnjail = isAminoMsgUnjail;
exports.createSlashingAminoConverters = createSlashingAminoConverters;
function isAminoMsgUnjail(msg) {
    return msg.type === "cosmos-sdk/MsgUnjail";
}
function createSlashingAminoConverters() {
    throw new Error("Not implemented");
}

},{}],"6sP0K":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupSlashingExtension = setupSlashingExtension;
const query_1 = require("980801d964ea3c0f");
const queryclient_1 = require("bf22401554c0397f");
function setupSlashingExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        slashing: {
            signingInfo: async (consAddress)=>{
                const response = await queryService.SigningInfo({
                    consAddress: consAddress
                });
                return response;
            },
            signingInfos: async (paginationKey)=>{
                const response = await queryService.SigningInfos({
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            params: async ()=>{
                const response = await queryService.Params({});
                return response;
            }
        }
    };
}

},{"980801d964ea3c0f":"b3Oxd","bf22401554c0397f":"cM4fi"}],"b3Oxd":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QuerySigningInfosResponse = exports.QuerySigningInfosRequest = exports.QuerySigningInfoResponse = exports.QuerySigningInfoRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("39cc8c3e465e34fc");
const slashing_1 = require("b5f94c5f98d68dcb");
const binary_1 = require("6ffeffffc128a21b");
const helpers_1 = require("f900118bd7ab7e97");
exports.protobufPackage = "cosmos.slashing.v1beta1";
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: slashing_1.Params.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) slashing_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = slashing_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = slashing_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? slashing_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = slashing_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseQuerySigningInfoRequest() {
    return {
        consAddress: ""
    };
}
exports.QuerySigningInfoRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.consAddress !== "") writer.uint32(10).string(message.consAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySigningInfoRequest();
        if ((0, helpers_1.isSet)(object.consAddress)) obj.consAddress = String(object.consAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.consAddress !== undefined && (obj.consAddress = message.consAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySigningInfoRequest();
        message.consAddress = object.consAddress ?? "";
        return message;
    }
};
function createBaseQuerySigningInfoResponse() {
    return {
        valSigningInfo: slashing_1.ValidatorSigningInfo.fromPartial({})
    };
}
exports.QuerySigningInfoResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.valSigningInfo !== undefined) slashing_1.ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.valSigningInfo = slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySigningInfoResponse();
        if ((0, helpers_1.isSet)(object.valSigningInfo)) obj.valSigningInfo = slashing_1.ValidatorSigningInfo.fromJSON(object.valSigningInfo);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.valSigningInfo !== undefined && (obj.valSigningInfo = message.valSigningInfo ? slashing_1.ValidatorSigningInfo.toJSON(message.valSigningInfo) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySigningInfoResponse();
        if (object.valSigningInfo !== undefined && object.valSigningInfo !== null) message.valSigningInfo = slashing_1.ValidatorSigningInfo.fromPartial(object.valSigningInfo);
        return message;
    }
};
function createBaseQuerySigningInfosRequest() {
    return {
        pagination: undefined
    };
}
exports.QuerySigningInfosRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySigningInfosRequest();
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySigningInfosRequest();
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQuerySigningInfosResponse() {
    return {
        info: [],
        pagination: undefined
    };
}
exports.QuerySigningInfosResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.info)slashing_1.ValidatorSigningInfo.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.info.push(slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQuerySigningInfosResponse();
        if (Array.isArray(object?.info)) obj.info = object.info.map((e)=>slashing_1.ValidatorSigningInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.info) obj.info = message.info.map((e)=>e ? slashing_1.ValidatorSigningInfo.toJSON(e) : undefined);
        else obj.info = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQuerySigningInfosResponse();
        message.info = object.info?.map((e)=>slashing_1.ValidatorSigningInfo.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
    SigningInfo(request) {
        const data = exports.QuerySigningInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", data);
        return promise.then((data)=>exports.QuerySigningInfoResponse.decode(new binary_1.BinaryReader(data)));
    }
    SigningInfos(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
    }) {
        const data = exports.QuerySigningInfosRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", data);
        return promise.then((data)=>exports.QuerySigningInfosResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"39cc8c3e465e34fc":"43d5n","b5f94c5f98d68dcb":"dKMp4","6ffeffffc128a21b":"bi36x","f900118bd7ab7e97":"eYjRL"}],"dKMp4":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.ValidatorSigningInfo = exports.protobufPackage = void 0;
/* eslint-disable */ const timestamp_1 = require("6320414397bc9654");
const duration_1 = require("14b2bab21b7a6f86");
const binary_1 = require("f7fde3f3d395db3b");
const helpers_1 = require("c936b815176ea520");
exports.protobufPackage = "cosmos.slashing.v1beta1";
function createBaseValidatorSigningInfo() {
    return {
        address: "",
        startHeight: BigInt(0),
        indexOffset: BigInt(0),
        jailedUntil: timestamp_1.Timestamp.fromPartial({}),
        tombstoned: false,
        missedBlocksCounter: BigInt(0)
    };
}
exports.ValidatorSigningInfo = {
    typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.startHeight !== BigInt(0)) writer.uint32(16).int64(message.startHeight);
        if (message.indexOffset !== BigInt(0)) writer.uint32(24).int64(message.indexOffset);
        if (message.jailedUntil !== undefined) timestamp_1.Timestamp.encode(message.jailedUntil, writer.uint32(34).fork()).ldelim();
        if (message.tombstoned === true) writer.uint32(40).bool(message.tombstoned);
        if (message.missedBlocksCounter !== BigInt(0)) writer.uint32(48).int64(message.missedBlocksCounter);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.startHeight = reader.int64();
                    break;
                case 3:
                    message.indexOffset = reader.int64();
                    break;
                case 4:
                    message.jailedUntil = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.tombstoned = reader.bool();
                    break;
                case 6:
                    message.missedBlocksCounter = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorSigningInfo();
        if ((0, helpers_1.isSet)(object.address)) obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.startHeight)) obj.startHeight = BigInt(object.startHeight.toString());
        if ((0, helpers_1.isSet)(object.indexOffset)) obj.indexOffset = BigInt(object.indexOffset.toString());
        if ((0, helpers_1.isSet)(object.jailedUntil)) obj.jailedUntil = (0, helpers_1.fromJsonTimestamp)(object.jailedUntil);
        if ((0, helpers_1.isSet)(object.tombstoned)) obj.tombstoned = Boolean(object.tombstoned);
        if ((0, helpers_1.isSet)(object.missedBlocksCounter)) obj.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.startHeight !== undefined && (obj.startHeight = (message.startHeight || BigInt(0)).toString());
        message.indexOffset !== undefined && (obj.indexOffset = (message.indexOffset || BigInt(0)).toString());
        message.jailedUntil !== undefined && (obj.jailedUntil = (0, helpers_1.fromTimestamp)(message.jailedUntil).toISOString());
        message.tombstoned !== undefined && (obj.tombstoned = message.tombstoned);
        message.missedBlocksCounter !== undefined && (obj.missedBlocksCounter = (message.missedBlocksCounter || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorSigningInfo();
        message.address = object.address ?? "";
        if (object.startHeight !== undefined && object.startHeight !== null) message.startHeight = BigInt(object.startHeight.toString());
        if (object.indexOffset !== undefined && object.indexOffset !== null) message.indexOffset = BigInt(object.indexOffset.toString());
        if (object.jailedUntil !== undefined && object.jailedUntil !== null) message.jailedUntil = timestamp_1.Timestamp.fromPartial(object.jailedUntil);
        message.tombstoned = object.tombstoned ?? false;
        if (object.missedBlocksCounter !== undefined && object.missedBlocksCounter !== null) message.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        return message;
    }
};
function createBaseParams() {
    return {
        signedBlocksWindow: BigInt(0),
        minSignedPerWindow: new Uint8Array(),
        downtimeJailDuration: duration_1.Duration.fromPartial({}),
        slashFractionDoubleSign: new Uint8Array(),
        slashFractionDowntime: new Uint8Array()
    };
}
exports.Params = {
    typeUrl: "/cosmos.slashing.v1beta1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedBlocksWindow !== BigInt(0)) writer.uint32(8).int64(message.signedBlocksWindow);
        if (message.minSignedPerWindow.length !== 0) writer.uint32(18).bytes(message.minSignedPerWindow);
        if (message.downtimeJailDuration !== undefined) duration_1.Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        if (message.slashFractionDoubleSign.length !== 0) writer.uint32(34).bytes(message.slashFractionDoubleSign);
        if (message.slashFractionDowntime.length !== 0) writer.uint32(42).bytes(message.slashFractionDowntime);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signedBlocksWindow = reader.int64();
                    break;
                case 2:
                    message.minSignedPerWindow = reader.bytes();
                    break;
                case 3:
                    message.downtimeJailDuration = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.slashFractionDoubleSign = reader.bytes();
                    break;
                case 5:
                    message.slashFractionDowntime = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.signedBlocksWindow)) obj.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        if ((0, helpers_1.isSet)(object.minSignedPerWindow)) obj.minSignedPerWindow = (0, helpers_1.bytesFromBase64)(object.minSignedPerWindow);
        if ((0, helpers_1.isSet)(object.downtimeJailDuration)) obj.downtimeJailDuration = duration_1.Duration.fromJSON(object.downtimeJailDuration);
        if ((0, helpers_1.isSet)(object.slashFractionDoubleSign)) obj.slashFractionDoubleSign = (0, helpers_1.bytesFromBase64)(object.slashFractionDoubleSign);
        if ((0, helpers_1.isSet)(object.slashFractionDowntime)) obj.slashFractionDowntime = (0, helpers_1.bytesFromBase64)(object.slashFractionDowntime);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.signedBlocksWindow !== undefined && (obj.signedBlocksWindow = (message.signedBlocksWindow || BigInt(0)).toString());
        message.minSignedPerWindow !== undefined && (obj.minSignedPerWindow = (0, helpers_1.base64FromBytes)(message.minSignedPerWindow !== undefined ? message.minSignedPerWindow : new Uint8Array()));
        message.downtimeJailDuration !== undefined && (obj.downtimeJailDuration = message.downtimeJailDuration ? duration_1.Duration.toJSON(message.downtimeJailDuration) : undefined);
        message.slashFractionDoubleSign !== undefined && (obj.slashFractionDoubleSign = (0, helpers_1.base64FromBytes)(message.slashFractionDoubleSign !== undefined ? message.slashFractionDoubleSign : new Uint8Array()));
        message.slashFractionDowntime !== undefined && (obj.slashFractionDowntime = (0, helpers_1.base64FromBytes)(message.slashFractionDowntime !== undefined ? message.slashFractionDowntime : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        if (object.signedBlocksWindow !== undefined && object.signedBlocksWindow !== null) message.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        message.minSignedPerWindow = object.minSignedPerWindow ?? new Uint8Array();
        if (object.downtimeJailDuration !== undefined && object.downtimeJailDuration !== null) message.downtimeJailDuration = duration_1.Duration.fromPartial(object.downtimeJailDuration);
        message.slashFractionDoubleSign = object.slashFractionDoubleSign ?? new Uint8Array();
        message.slashFractionDowntime = object.slashFractionDowntime ?? new Uint8Array();
        return message;
    }
};

},{"6320414397bc9654":"6J6bq","14b2bab21b7a6f86":"clU50","f7fde3f3d395db3b":"bi36x","c936b815176ea520":"eYjRL"}],"56AnK":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.protoDecimalToJson = protoDecimalToJson;
exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
exports.isAminoMsgDelegate = isAminoMsgDelegate;
exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
exports.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
exports.createStakingAminoConverters = createStakingAminoConverters;
const math_1 = require("b2e4c0337ed071e8");
const proto_signing_1 = require("f0a9e23a3e28b64c");
const utils_1 = require("86529beb6580e06d");
function protoDecimalToJson(decimal) {
    const parsed = math_1.Decimal.fromAtomics(decimal, 18);
    const [whole, fractional] = parsed.toString().split(".");
    return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
}
function jsonDecimalToProto(decimal) {
    const parsed = math_1.Decimal.fromUserInput(decimal, 18);
    return parsed.atomics;
}
function isAminoMsgCreateValidator(msg) {
    return msg.type === "cosmos-sdk/MsgCreateValidator";
}
function isAminoMsgEditValidator(msg) {
    return msg.type === "cosmos-sdk/MsgEditValidator";
}
function isAminoMsgDelegate(msg) {
    return msg.type === "cosmos-sdk/MsgDelegate";
}
function isAminoMsgBeginRedelegate(msg) {
    return msg.type === "cosmos-sdk/MsgBeginRedelegate";
}
function isAminoMsgUndelegate(msg) {
    return msg.type === "cosmos-sdk/MsgUndelegate";
}
function isAminoMsgCancelUnbondingDelegation(msg) {
    return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
}
function createStakingAminoConverters() {
    return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
            aminoType: "cosmos-sdk/MsgBeginRedelegate",
            toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_src_address: validatorSrcAddress,
                    validator_dst_address: validatorDstAddress,
                    amount: amount
                };
            },
            fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount })=>({
                    delegatorAddress: delegator_address,
                    validatorSrcAddress: validator_src_address,
                    validatorDstAddress: validator_dst_address,
                    amount: amount
                })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
            aminoType: "cosmos-sdk/MsgCreateValidator",
            toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value })=>{
                (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
                (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
                (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
                (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        security_contact: description.securityContact,
                        details: description.details
                    },
                    commission: {
                        rate: protoDecimalToJson(commission.rate),
                        max_rate: protoDecimalToJson(commission.maxRate),
                        max_change_rate: protoDecimalToJson(commission.maxChangeRate)
                    },
                    min_self_delegation: minSelfDelegation,
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
                    value: value
                };
            },
            fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value })=>{
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        securityContact: description.security_contact,
                        details: description.details
                    },
                    commission: {
                        rate: jsonDecimalToProto(commission.rate),
                        maxRate: jsonDecimalToProto(commission.max_rate),
                        maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
                    },
                    minSelfDelegation: min_self_delegation,
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
                    value: value
                };
            }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
            aminoType: "cosmos-sdk/MsgDelegate",
            toAmino: ({ delegatorAddress, validatorAddress, amount })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    amount: amount
                })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
            aminoType: "cosmos-sdk/MsgEditValidator",
            toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress })=>{
                (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        security_contact: description.securityContact,
                        details: description.details
                    },
                    // empty string in the protobuf document means "do not change"
                    commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : undefined,
                    // empty string in the protobuf document means "do not change"
                    min_self_delegation: minSelfDelegation ? minSelfDelegation : undefined,
                    validator_address: validatorAddress
                };
            },
            fromAmino: ({ description, commission_rate, min_self_delegation, validator_address })=>({
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        securityContact: description.security_contact,
                        details: description.details
                    },
                    // empty string in the protobuf document means "do not change"
                    commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
                    // empty string in the protobuf document means "do not change"
                    minSelfDelegation: min_self_delegation ?? "",
                    validatorAddress: validator_address
                })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
            aminoType: "cosmos-sdk/MsgUndelegate",
            toAmino: ({ delegatorAddress, validatorAddress, amount })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    amount: amount
                })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
            aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
            toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount,
                    creation_height: creationHeight.toString()
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount, creation_height })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    amount: amount,
                    creationHeight: BigInt(creation_height)
                })
        }
    };
}

},{"b2e4c0337ed071e8":"e8aug","f0a9e23a3e28b64c":"2gdyE","86529beb6580e06d":"3R4mb"}],"ilSKu":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stakingTypes = void 0;
exports.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
exports.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
exports.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
exports.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
const tx_1 = require("71c7661efeeeb78");
exports.stakingTypes = [
    [
        "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        tx_1.MsgBeginRedelegate
    ],
    [
        "/cosmos.staking.v1beta1.MsgCreateValidator",
        tx_1.MsgCreateValidator
    ],
    [
        "/cosmos.staking.v1beta1.MsgDelegate",
        tx_1.MsgDelegate
    ],
    [
        "/cosmos.staking.v1beta1.MsgEditValidator",
        tx_1.MsgEditValidator
    ],
    [
        "/cosmos.staking.v1beta1.MsgUndelegate",
        tx_1.MsgUndelegate
    ],
    [
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        tx_1.MsgCancelUnbondingDelegation
    ]
];
function isMsgBeginRedelegateEncodeObject(o) {
    return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}
function isMsgCreateValidatorEncodeObject(o) {
    return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
}
function isMsgDelegateEncodeObject(object) {
    return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
}
function isMsgEditValidatorEncodeObject(o) {
    return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
}
function isMsgUndelegateEncodeObject(object) {
    return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
}
function isMsgCancelUnbondingDelegationEncodeObject(object) {
    return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
}

},{"71c7661efeeeb78":"j0J9T"}],"j0J9T":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgCancelUnbondingDelegationResponse = exports.MsgCancelUnbondingDelegation = exports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;
/* eslint-disable */ const staking_1 = require("df746b240f417dff");
const any_1 = require("49a0808f5a6db622");
const coin_1 = require("53536314bf7fa63a");
const timestamp_1 = require("d6e7b64a6de897cf");
const binary_1 = require("95c42ea1785ebdb");
const helpers_1 = require("b3584c3df0b9d123");
exports.protobufPackage = "cosmos.staking.v1beta1";
function createBaseMsgCreateValidator() {
    return {
        description: staking_1.Description.fromPartial({}),
        commission: staking_1.CommissionRates.fromPartial({}),
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: undefined,
        value: coin_1.Coin.fromPartial({})
    };
}
exports.MsgCreateValidator = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== undefined) staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        if (message.commission !== undefined) staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        if (message.minSelfDelegation !== "") writer.uint32(26).string(message.minSelfDelegation);
        if (message.delegatorAddress !== "") writer.uint32(34).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(42).string(message.validatorAddress);
        if (message.pubkey !== undefined) any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        if (message.value !== undefined) coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.description = staking_1.Description.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.minSelfDelegation = reader.string();
                    break;
                case 4:
                    message.delegatorAddress = reader.string();
                    break;
                case 5:
                    message.validatorAddress = reader.string();
                    break;
                case 6:
                    message.pubkey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.value = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateValidator();
        if ((0, helpers_1.isSet)(object.description)) obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.commission)) obj.commission = staking_1.CommissionRates.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation)) obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.pubkey)) obj.pubkey = any_1.Any.fromJSON(object.pubkey);
        if ((0, helpers_1.isSet)(object.value)) obj.value = coin_1.Coin.fromJSON(object.value);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : undefined);
        message.commission !== undefined && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : undefined);
        message.minSelfDelegation !== undefined && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== undefined && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : undefined);
        message.value !== undefined && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateValidator();
        if (object.description !== undefined && object.description !== null) message.description = staking_1.Description.fromPartial(object.description);
        if (object.commission !== undefined && object.commission !== null) message.commission = staking_1.CommissionRates.fromPartial(object.commission);
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.pubkey !== undefined && object.pubkey !== null) message.pubkey = any_1.Any.fromPartial(object.pubkey);
        if (object.value !== undefined && object.value !== null) message.value = coin_1.Coin.fromPartial(object.value);
        return message;
    }
};
function createBaseMsgCreateValidatorResponse() {
    return {};
}
exports.MsgCreateValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCreateValidatorResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
    }
};
function createBaseMsgEditValidator() {
    return {
        description: staking_1.Description.fromPartial({}),
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
    };
}
exports.MsgEditValidator = {
    typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== undefined) staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        if (message.commissionRate !== "") writer.uint32(26).string(message.commissionRate);
        if (message.minSelfDelegation !== "") writer.uint32(34).string(message.minSelfDelegation);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.description = staking_1.Description.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.commissionRate = reader.string();
                    break;
                case 4:
                    message.minSelfDelegation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgEditValidator();
        if ((0, helpers_1.isSet)(object.description)) obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.commissionRate)) obj.commissionRate = String(object.commissionRate);
        if ((0, helpers_1.isSet)(object.minSelfDelegation)) obj.minSelfDelegation = String(object.minSelfDelegation);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.description !== undefined && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : undefined);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== undefined && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== undefined && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgEditValidator();
        if (object.description !== undefined && object.description !== null) message.description = staking_1.Description.fromPartial(object.description);
        message.validatorAddress = object.validatorAddress ?? "";
        message.commissionRate = object.commissionRate ?? "";
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
    }
};
function createBaseMsgEditValidatorResponse() {
    return {};
}
exports.MsgEditValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgEditValidatorResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
    }
};
function createBaseMsgDelegate() {
    return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
    };
}
exports.MsgDelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgDelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgDelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        return message;
    }
};
function createBaseMsgDelegateResponse() {
    return {};
}
exports.MsgDelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgDelegateResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgDelegateResponse();
        return message;
    }
};
function createBaseMsgBeginRedelegate() {
    return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: coin_1.Coin.fromPartial({})
    };
}
exports.MsgBeginRedelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorSrcAddress !== "") writer.uint32(18).string(message.validatorSrcAddress);
        if (message.validatorDstAddress !== "") writer.uint32(26).string(message.validatorDstAddress);
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorSrcAddress = reader.string();
                    break;
                case 3:
                    message.validatorDstAddress = reader.string();
                    break;
                case 4:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgBeginRedelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress)) obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress)) obj.validatorDstAddress = String(object.validatorDstAddress);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== undefined && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== undefined && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        return message;
    }
};
function createBaseMsgBeginRedelegateResponse() {
    return {
        completionTime: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.MsgBeginRedelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== undefined) timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgBeginRedelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime)) obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.completionTime !== undefined && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgBeginRedelegateResponse();
        if (object.completionTime !== undefined && object.completionTime !== null) message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        return message;
    }
};
function createBaseMsgUndelegate() {
    return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
    };
}
exports.MsgUndelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUndelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        return message;
    }
};
function createBaseMsgUndelegateResponse() {
    return {
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        amount: coin_1.Coin.fromPartial({})
    };
}
exports.MsgUndelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== undefined) timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUndelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime)) obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.completionTime !== undefined && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUndelegateResponse();
        if (object.completionTime !== undefined && object.completionTime !== null) message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        return message;
    }
};
function createBaseMsgCancelUnbondingDelegation() {
    return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({}),
        creationHeight: BigInt(0)
    };
}
exports.MsgCancelUnbondingDelegation = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        if (message.amount !== undefined) coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        if (message.creationHeight !== BigInt(0)) writer.uint32(32).int64(message.creationHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.amount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.creationHeight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCancelUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount)) obj.amount = coin_1.Coin.fromJSON(object.amount);
        if ((0, helpers_1.isSet)(object.creationHeight)) obj.creationHeight = BigInt(object.creationHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.amount !== undefined && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);
        message.creationHeight !== undefined && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCancelUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== undefined && object.amount !== null) message.amount = coin_1.Coin.fromPartial(object.amount);
        if (object.creationHeight !== undefined && object.creationHeight !== null) message.creationHeight = BigInt(object.creationHeight.toString());
        return message;
    }
};
function createBaseMsgCancelUnbondingDelegationResponse() {
    return {};
}
exports.MsgCancelUnbondingDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCancelUnbondingDelegationResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: staking_1.Params.fromPartial({})
    };
}
exports.MsgUpdateParams = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") writer.uint32(10).string(message.authority);
        if (message.params !== undefined) staking_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = staking_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority)) obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params)) obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== undefined && object.params !== null) message.params = staking_1.Params.fromPartial(object.params);
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
        this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
    }
    CreateValidator(request) {
        const data = exports.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data);
        return promise.then((data)=>exports.MsgCreateValidatorResponse.decode(new binary_1.BinaryReader(data)));
    }
    EditValidator(request) {
        const data = exports.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data);
        return promise.then((data)=>exports.MsgEditValidatorResponse.decode(new binary_1.BinaryReader(data)));
    }
    Delegate(request) {
        const data = exports.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data);
        return promise.then((data)=>exports.MsgDelegateResponse.decode(new binary_1.BinaryReader(data)));
    }
    BeginRedelegate(request) {
        const data = exports.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data);
        return promise.then((data)=>exports.MsgBeginRedelegateResponse.decode(new binary_1.BinaryReader(data)));
    }
    Undelegate(request) {
        const data = exports.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data);
        return promise.then((data)=>exports.MsgUndelegateResponse.decode(new binary_1.BinaryReader(data)));
    }
    CancelUnbondingDelegation(request) {
        const data = exports.MsgCancelUnbondingDelegation.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", data);
        return promise.then((data)=>exports.MsgCancelUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"df746b240f417dff":"gUdrn","49a0808f5a6db622":"56aJC","53536314bf7fa63a":"1ymyZ","d6e7b64a6de897cf":"6J6bq","95c42ea1785ebdb":"bi36x","b3584c3df0b9d123":"eYjRL"}],"gUdrn":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidatorUpdates = exports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.infractionToJSON = exports.infractionFromJSON = exports.Infraction = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;
/* eslint-disable */ const types_1 = require("a29b35cc5b42903b");
const timestamp_1 = require("531607033cf8cf2a");
const any_1 = require("f5ad4e66961f1148");
const duration_1 = require("64732a6c581bd824");
const coin_1 = require("ca2bc722a53c2ba7");
const types_2 = require("c2df9c8f9bfeb83");
const binary_1 = require("5a97514c26c40707");
const helpers_1 = require("acccabd011593d65");
exports.protobufPackage = "cosmos.staking.v1beta1";
/** BondStatus is the status of a validator. */ var BondStatus;
(function(BondStatus) {
    /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */ BondStatus[BondStatus["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
    /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */ BondStatus[BondStatus["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
    /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */ BondStatus[BondStatus["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
    /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */ BondStatus[BondStatus["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
    BondStatus[BondStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BondStatus || (exports.BondStatus = BondStatus = {}));
function bondStatusFromJSON(object) {
    switch(object){
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
            return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
            return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
            return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
            return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BondStatus.UNRECOGNIZED;
    }
}
exports.bondStatusFromJSON = bondStatusFromJSON;
function bondStatusToJSON(object) {
    switch(object){
        case BondStatus.BOND_STATUS_UNSPECIFIED:
            return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
            return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
            return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
            return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.bondStatusToJSON = bondStatusToJSON;
/** Infraction indicates the infraction a validator commited. */ var Infraction;
(function(Infraction) {
    /** INFRACTION_UNSPECIFIED - UNSPECIFIED defines an empty infraction. */ Infraction[Infraction["INFRACTION_UNSPECIFIED"] = 0] = "INFRACTION_UNSPECIFIED";
    /** INFRACTION_DOUBLE_SIGN - DOUBLE_SIGN defines a validator that double-signs a block. */ Infraction[Infraction["INFRACTION_DOUBLE_SIGN"] = 1] = "INFRACTION_DOUBLE_SIGN";
    /** INFRACTION_DOWNTIME - DOWNTIME defines a validator that missed signing too many blocks. */ Infraction[Infraction["INFRACTION_DOWNTIME"] = 2] = "INFRACTION_DOWNTIME";
    Infraction[Infraction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Infraction || (exports.Infraction = Infraction = {}));
function infractionFromJSON(object) {
    switch(object){
        case 0:
        case "INFRACTION_UNSPECIFIED":
            return Infraction.INFRACTION_UNSPECIFIED;
        case 1:
        case "INFRACTION_DOUBLE_SIGN":
            return Infraction.INFRACTION_DOUBLE_SIGN;
        case 2:
        case "INFRACTION_DOWNTIME":
            return Infraction.INFRACTION_DOWNTIME;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Infraction.UNRECOGNIZED;
    }
}
exports.infractionFromJSON = infractionFromJSON;
function infractionToJSON(object) {
    switch(object){
        case Infraction.INFRACTION_UNSPECIFIED:
            return "INFRACTION_UNSPECIFIED";
        case Infraction.INFRACTION_DOUBLE_SIGN:
            return "INFRACTION_DOUBLE_SIGN";
        case Infraction.INFRACTION_DOWNTIME:
            return "INFRACTION_DOWNTIME";
        case Infraction.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.infractionToJSON = infractionToJSON;
function createBaseHistoricalInfo() {
    return {
        header: types_1.Header.fromPartial({}),
        valset: []
    };
}
exports.HistoricalInfo = {
    typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== undefined) types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        for (const v of message.valset)exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.header = types_1.Header.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.valset.push(exports.Validator.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseHistoricalInfo();
        if ((0, helpers_1.isSet)(object.header)) obj.header = types_1.Header.fromJSON(object.header);
        if (Array.isArray(object?.valset)) obj.valset = object.valset.map((e)=>exports.Validator.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.header !== undefined && (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);
        if (message.valset) obj.valset = message.valset.map((e)=>e ? exports.Validator.toJSON(e) : undefined);
        else obj.valset = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseHistoricalInfo();
        if (object.header !== undefined && object.header !== null) message.header = types_1.Header.fromPartial(object.header);
        message.valset = object.valset?.map((e)=>exports.Validator.fromPartial(e)) || [];
        return message;
    }
};
function createBaseCommissionRates() {
    return {
        rate: "",
        maxRate: "",
        maxChangeRate: ""
    };
}
exports.CommissionRates = {
    typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.rate !== "") writer.uint32(10).string(message.rate);
        if (message.maxRate !== "") writer.uint32(18).string(message.maxRate);
        if (message.maxChangeRate !== "") writer.uint32(26).string(message.maxChangeRate);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.rate = reader.string();
                    break;
                case 2:
                    message.maxRate = reader.string();
                    break;
                case 3:
                    message.maxChangeRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommissionRates();
        if ((0, helpers_1.isSet)(object.rate)) obj.rate = String(object.rate);
        if ((0, helpers_1.isSet)(object.maxRate)) obj.maxRate = String(object.maxRate);
        if ((0, helpers_1.isSet)(object.maxChangeRate)) obj.maxChangeRate = String(object.maxChangeRate);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.rate !== undefined && (obj.rate = message.rate);
        message.maxRate !== undefined && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== undefined && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommissionRates();
        message.rate = object.rate ?? "";
        message.maxRate = object.maxRate ?? "";
        message.maxChangeRate = object.maxChangeRate ?? "";
        return message;
    }
};
function createBaseCommission() {
    return {
        commissionRates: exports.CommissionRates.fromPartial({}),
        updateTime: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.Commission = {
    typeUrl: "/cosmos.staking.v1beta1.Commission",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.commissionRates !== undefined) exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        if (message.updateTime !== undefined) timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommission();
        if ((0, helpers_1.isSet)(object.commissionRates)) obj.commissionRates = exports.CommissionRates.fromJSON(object.commissionRates);
        if ((0, helpers_1.isSet)(object.updateTime)) obj.updateTime = (0, helpers_1.fromJsonTimestamp)(object.updateTime);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.commissionRates !== undefined && (obj.commissionRates = message.commissionRates ? exports.CommissionRates.toJSON(message.commissionRates) : undefined);
        message.updateTime !== undefined && (obj.updateTime = (0, helpers_1.fromTimestamp)(message.updateTime).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommission();
        if (object.commissionRates !== undefined && object.commissionRates !== null) message.commissionRates = exports.CommissionRates.fromPartial(object.commissionRates);
        if (object.updateTime !== undefined && object.updateTime !== null) message.updateTime = timestamp_1.Timestamp.fromPartial(object.updateTime);
        return message;
    }
};
function createBaseDescription() {
    return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
    };
}
exports.Description = {
    typeUrl: "/cosmos.staking.v1beta1.Description",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.moniker !== "") writer.uint32(10).string(message.moniker);
        if (message.identity !== "") writer.uint32(18).string(message.identity);
        if (message.website !== "") writer.uint32(26).string(message.website);
        if (message.securityContact !== "") writer.uint32(34).string(message.securityContact);
        if (message.details !== "") writer.uint32(42).string(message.details);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.moniker = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.website = reader.string();
                    break;
                case 4:
                    message.securityContact = reader.string();
                    break;
                case 5:
                    message.details = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDescription();
        if ((0, helpers_1.isSet)(object.moniker)) obj.moniker = String(object.moniker);
        if ((0, helpers_1.isSet)(object.identity)) obj.identity = String(object.identity);
        if ((0, helpers_1.isSet)(object.website)) obj.website = String(object.website);
        if ((0, helpers_1.isSet)(object.securityContact)) obj.securityContact = String(object.securityContact);
        if ((0, helpers_1.isSet)(object.details)) obj.details = String(object.details);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.moniker !== undefined && (obj.moniker = message.moniker);
        message.identity !== undefined && (obj.identity = message.identity);
        message.website !== undefined && (obj.website = message.website);
        message.securityContact !== undefined && (obj.securityContact = message.securityContact);
        message.details !== undefined && (obj.details = message.details);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDescription();
        message.moniker = object.moniker ?? "";
        message.identity = object.identity ?? "";
        message.website = object.website ?? "";
        message.securityContact = object.securityContact ?? "";
        message.details = object.details ?? "";
        return message;
    }
};
function createBaseValidator() {
    return {
        operatorAddress: "",
        consensusPubkey: undefined,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: exports.Description.fromPartial({}),
        unbondingHeight: BigInt(0),
        unbondingTime: timestamp_1.Timestamp.fromPartial({}),
        commission: exports.Commission.fromPartial({}),
        minSelfDelegation: "",
        unbondingOnHoldRefCount: BigInt(0),
        unbondingIds: []
    };
}
exports.Validator = {
    typeUrl: "/cosmos.staking.v1beta1.Validator",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") writer.uint32(10).string(message.operatorAddress);
        if (message.consensusPubkey !== undefined) any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        if (message.jailed === true) writer.uint32(24).bool(message.jailed);
        if (message.status !== 0) writer.uint32(32).int32(message.status);
        if (message.tokens !== "") writer.uint32(42).string(message.tokens);
        if (message.delegatorShares !== "") writer.uint32(50).string(message.delegatorShares);
        if (message.description !== undefined) exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        if (message.unbondingHeight !== BigInt(0)) writer.uint32(64).int64(message.unbondingHeight);
        if (message.unbondingTime !== undefined) timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        if (message.commission !== undefined) exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        if (message.minSelfDelegation !== "") writer.uint32(90).string(message.minSelfDelegation);
        if (message.unbondingOnHoldRefCount !== BigInt(0)) writer.uint32(96).int64(message.unbondingOnHoldRefCount);
        writer.uint32(106).fork();
        for (const v of message.unbondingIds)writer.uint64(v);
        writer.ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.operatorAddress = reader.string();
                    break;
                case 2:
                    message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.jailed = reader.bool();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.tokens = reader.string();
                    break;
                case 6:
                    message.delegatorShares = reader.string();
                    break;
                case 7:
                    message.description = exports.Description.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.unbondingHeight = reader.int64();
                    break;
                case 9:
                    message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.commission = exports.Commission.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.minSelfDelegation = reader.string();
                    break;
                case 12:
                    message.unbondingOnHoldRefCount = reader.int64();
                    break;
                case 13:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.unbondingIds.push(reader.uint64());
                    } else message.unbondingIds.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.operatorAddress)) obj.operatorAddress = String(object.operatorAddress);
        if ((0, helpers_1.isSet)(object.consensusPubkey)) obj.consensusPubkey = any_1.Any.fromJSON(object.consensusPubkey);
        if ((0, helpers_1.isSet)(object.jailed)) obj.jailed = Boolean(object.jailed);
        if ((0, helpers_1.isSet)(object.status)) obj.status = bondStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.tokens)) obj.tokens = String(object.tokens);
        if ((0, helpers_1.isSet)(object.delegatorShares)) obj.delegatorShares = String(object.delegatorShares);
        if ((0, helpers_1.isSet)(object.description)) obj.description = exports.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.unbondingHeight)) obj.unbondingHeight = BigInt(object.unbondingHeight.toString());
        if ((0, helpers_1.isSet)(object.unbondingTime)) obj.unbondingTime = (0, helpers_1.fromJsonTimestamp)(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.commission)) obj.commission = exports.Commission.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation)) obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount)) obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        if (Array.isArray(object?.unbondingIds)) obj.unbondingIds = object.unbondingIds.map((e)=>BigInt(e.toString()));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== undefined && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : undefined);
        message.jailed !== undefined && (obj.jailed = message.jailed);
        message.status !== undefined && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== undefined && (obj.tokens = message.tokens);
        message.delegatorShares !== undefined && (obj.delegatorShares = message.delegatorShares);
        message.description !== undefined && (obj.description = message.description ? exports.Description.toJSON(message.description) : undefined);
        message.unbondingHeight !== undefined && (obj.unbondingHeight = (message.unbondingHeight || BigInt(0)).toString());
        message.unbondingTime !== undefined && (obj.unbondingTime = (0, helpers_1.fromTimestamp)(message.unbondingTime).toISOString());
        message.commission !== undefined && (obj.commission = message.commission ? exports.Commission.toJSON(message.commission) : undefined);
        message.minSelfDelegation !== undefined && (obj.minSelfDelegation = message.minSelfDelegation);
        message.unbondingOnHoldRefCount !== undefined && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        if (message.unbondingIds) obj.unbondingIds = message.unbondingIds.map((e)=>(e || BigInt(0)).toString());
        else obj.unbondingIds = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidator();
        message.operatorAddress = object.operatorAddress ?? "";
        if (object.consensusPubkey !== undefined && object.consensusPubkey !== null) message.consensusPubkey = any_1.Any.fromPartial(object.consensusPubkey);
        message.jailed = object.jailed ?? false;
        message.status = object.status ?? 0;
        message.tokens = object.tokens ?? "";
        message.delegatorShares = object.delegatorShares ?? "";
        if (object.description !== undefined && object.description !== null) message.description = exports.Description.fromPartial(object.description);
        if (object.unbondingHeight !== undefined && object.unbondingHeight !== null) message.unbondingHeight = BigInt(object.unbondingHeight.toString());
        if (object.unbondingTime !== undefined && object.unbondingTime !== null) message.unbondingTime = timestamp_1.Timestamp.fromPartial(object.unbondingTime);
        if (object.commission !== undefined && object.commission !== null) message.commission = exports.Commission.fromPartial(object.commission);
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        if (object.unbondingOnHoldRefCount !== undefined && object.unbondingOnHoldRefCount !== null) message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        message.unbondingIds = object.unbondingIds?.map((e)=>BigInt(e.toString())) || [];
        return message;
    }
};
function createBaseValAddresses() {
    return {
        addresses: []
    };
}
exports.ValAddresses = {
    typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.addresses)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValAddresses();
        if (Array.isArray(object?.addresses)) obj.addresses = object.addresses.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.addresses) obj.addresses = message.addresses.map((e)=>e);
        else obj.addresses = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValAddresses();
        message.addresses = object.addresses?.map((e)=>e) || [];
        return message;
    }
};
function createBaseDVPair() {
    return {
        delegatorAddress: "",
        validatorAddress: ""
    };
}
exports.DVPair = {
    typeUrl: "/cosmos.staking.v1beta1.DVPair",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDVPair();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDVPair();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    }
};
function createBaseDVPairs() {
    return {
        pairs: []
    };
}
exports.DVPairs = {
    typeUrl: "/cosmos.staking.v1beta1.DVPairs",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pairs)exports.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDVPairs();
        if (Array.isArray(object?.pairs)) obj.pairs = object.pairs.map((e)=>exports.DVPair.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.pairs) obj.pairs = message.pairs.map((e)=>e ? exports.DVPair.toJSON(e) : undefined);
        else obj.pairs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDVPairs();
        message.pairs = object.pairs?.map((e)=>exports.DVPair.fromPartial(e)) || [];
        return message;
    }
};
function createBaseDVVTriplet() {
    return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
    };
}
exports.DVVTriplet = {
    typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorSrcAddress !== "") writer.uint32(18).string(message.validatorSrcAddress);
        if (message.validatorDstAddress !== "") writer.uint32(26).string(message.validatorDstAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorSrcAddress = reader.string();
                    break;
                case 3:
                    message.validatorDstAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDVVTriplet();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress)) obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress)) obj.validatorDstAddress = String(object.validatorDstAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== undefined && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== undefined && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDVVTriplet();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        return message;
    }
};
function createBaseDVVTriplets() {
    return {
        triplets: []
    };
}
exports.DVVTriplets = {
    typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.triplets)exports.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDVVTriplets();
        if (Array.isArray(object?.triplets)) obj.triplets = object.triplets.map((e)=>exports.DVVTriplet.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.triplets) obj.triplets = message.triplets.map((e)=>e ? exports.DVVTriplet.toJSON(e) : undefined);
        else obj.triplets = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDVVTriplets();
        message.triplets = object.triplets?.map((e)=>exports.DVVTriplet.fromPartial(e)) || [];
        return message;
    }
};
function createBaseDelegation() {
    return {
        delegatorAddress: "",
        validatorAddress: "",
        shares: ""
    };
}
exports.Delegation = {
    typeUrl: "/cosmos.staking.v1beta1.Delegation",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        if (message.shares !== "") writer.uint32(26).string(message.shares);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.shares = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.shares)) obj.shares = String(object.shares);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.shares !== undefined && (obj.shares = message.shares);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.shares = object.shares ?? "";
        return message;
    }
};
function createBaseUnbondingDelegation() {
    return {
        delegatorAddress: "",
        validatorAddress: "",
        entries: []
    };
}
exports.UnbondingDelegation = {
    typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorAddress !== "") writer.uint32(18).string(message.validatorAddress);
        for (const v of message.entries)exports.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.entries)) obj.entries = object.entries.map((e)=>exports.UnbondingDelegationEntry.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) obj.entries = message.entries.map((e)=>e ? exports.UnbondingDelegationEntry.toJSON(e) : undefined);
        else obj.entries = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.entries = object.entries?.map((e)=>exports.UnbondingDelegationEntry.fromPartial(e)) || [];
        return message;
    }
};
function createBaseUnbondingDelegationEntry() {
    return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        balance: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
    };
}
exports.UnbondingDelegationEntry = {
    typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) writer.uint32(8).int64(message.creationHeight);
        if (message.completionTime !== undefined) timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        if (message.initialBalance !== "") writer.uint32(26).string(message.initialBalance);
        if (message.balance !== "") writer.uint32(34).string(message.balance);
        if (message.unbondingId !== BigInt(0)) writer.uint32(40).uint64(message.unbondingId);
        if (message.unbondingOnHoldRefCount !== BigInt(0)) writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.creationHeight = reader.int64();
                    break;
                case 2:
                    message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.initialBalance = reader.string();
                    break;
                case 4:
                    message.balance = reader.string();
                    break;
                case 5:
                    message.unbondingId = reader.uint64();
                    break;
                case 6:
                    message.unbondingOnHoldRefCount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseUnbondingDelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight)) obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime)) obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance)) obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.balance)) obj.balance = String(object.balance);
        if ((0, helpers_1.isSet)(object.unbondingId)) obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount)) obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.creationHeight !== undefined && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== undefined && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== undefined && (obj.initialBalance = message.initialBalance);
        message.balance !== undefined && (obj.balance = message.balance);
        message.unbondingId !== undefined && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== undefined && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUnbondingDelegationEntry();
        if (object.creationHeight !== undefined && object.creationHeight !== null) message.creationHeight = BigInt(object.creationHeight.toString());
        if (object.completionTime !== undefined && object.completionTime !== null) message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        message.initialBalance = object.initialBalance ?? "";
        message.balance = object.balance ?? "";
        if (object.unbondingId !== undefined && object.unbondingId !== null) message.unbondingId = BigInt(object.unbondingId.toString());
        if (object.unbondingOnHoldRefCount !== undefined && object.unbondingOnHoldRefCount !== null) message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return message;
    }
};
function createBaseRedelegationEntry() {
    return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        sharesDst: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
    };
}
exports.RedelegationEntry = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) writer.uint32(8).int64(message.creationHeight);
        if (message.completionTime !== undefined) timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        if (message.initialBalance !== "") writer.uint32(26).string(message.initialBalance);
        if (message.sharesDst !== "") writer.uint32(34).string(message.sharesDst);
        if (message.unbondingId !== BigInt(0)) writer.uint32(40).uint64(message.unbondingId);
        if (message.unbondingOnHoldRefCount !== BigInt(0)) writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.creationHeight = reader.int64();
                    break;
                case 2:
                    message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.initialBalance = reader.string();
                    break;
                case 4:
                    message.sharesDst = reader.string();
                    break;
                case 5:
                    message.unbondingId = reader.uint64();
                    break;
                case 6:
                    message.unbondingOnHoldRefCount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRedelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight)) obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime)) obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance)) obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.sharesDst)) obj.sharesDst = String(object.sharesDst);
        if ((0, helpers_1.isSet)(object.unbondingId)) obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount)) obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.creationHeight !== undefined && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== undefined && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== undefined && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== undefined && (obj.sharesDst = message.sharesDst);
        message.unbondingId !== undefined && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== undefined && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRedelegationEntry();
        if (object.creationHeight !== undefined && object.creationHeight !== null) message.creationHeight = BigInt(object.creationHeight.toString());
        if (object.completionTime !== undefined && object.completionTime !== null) message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        message.initialBalance = object.initialBalance ?? "";
        message.sharesDst = object.sharesDst ?? "";
        if (object.unbondingId !== undefined && object.unbondingId !== null) message.unbondingId = BigInt(object.unbondingId.toString());
        if (object.unbondingOnHoldRefCount !== undefined && object.unbondingOnHoldRefCount !== null) message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return message;
    }
};
function createBaseRedelegation() {
    return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
    };
}
exports.Redelegation = {
    typeUrl: "/cosmos.staking.v1beta1.Redelegation",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") writer.uint32(10).string(message.delegatorAddress);
        if (message.validatorSrcAddress !== "") writer.uint32(18).string(message.validatorSrcAddress);
        if (message.validatorDstAddress !== "") writer.uint32(26).string(message.validatorDstAddress);
        for (const v of message.entries)exports.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorSrcAddress = reader.string();
                    break;
                case 3:
                    message.validatorDstAddress = reader.string();
                    break;
                case 4:
                    message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRedelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress)) obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress)) obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress)) obj.validatorDstAddress = String(object.validatorDstAddress);
        if (Array.isArray(object?.entries)) obj.entries = object.entries.map((e)=>exports.RedelegationEntry.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== undefined && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== undefined && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) obj.entries = message.entries.map((e)=>e ? exports.RedelegationEntry.toJSON(e) : undefined);
        else obj.entries = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRedelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.entries = object.entries?.map((e)=>exports.RedelegationEntry.fromPartial(e)) || [];
        return message;
    }
};
function createBaseParams() {
    return {
        unbondingTime: duration_1.Duration.fromPartial({}),
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: "",
        minCommissionRate: ""
    };
}
exports.Params = {
    typeUrl: "/cosmos.staking.v1beta1.Params",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbondingTime !== undefined) duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        if (message.maxValidators !== 0) writer.uint32(16).uint32(message.maxValidators);
        if (message.maxEntries !== 0) writer.uint32(24).uint32(message.maxEntries);
        if (message.historicalEntries !== 0) writer.uint32(32).uint32(message.historicalEntries);
        if (message.bondDenom !== "") writer.uint32(42).string(message.bondDenom);
        if (message.minCommissionRate !== "") writer.uint32(50).string(message.minCommissionRate);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxValidators = reader.uint32();
                    break;
                case 3:
                    message.maxEntries = reader.uint32();
                    break;
                case 4:
                    message.historicalEntries = reader.uint32();
                    break;
                case 5:
                    message.bondDenom = reader.string();
                    break;
                case 6:
                    message.minCommissionRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.unbondingTime)) obj.unbondingTime = duration_1.Duration.fromJSON(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.maxValidators)) obj.maxValidators = Number(object.maxValidators);
        if ((0, helpers_1.isSet)(object.maxEntries)) obj.maxEntries = Number(object.maxEntries);
        if ((0, helpers_1.isSet)(object.historicalEntries)) obj.historicalEntries = Number(object.historicalEntries);
        if ((0, helpers_1.isSet)(object.bondDenom)) obj.bondDenom = String(object.bondDenom);
        if ((0, helpers_1.isSet)(object.minCommissionRate)) obj.minCommissionRate = String(object.minCommissionRate);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.unbondingTime !== undefined && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : undefined);
        message.maxValidators !== undefined && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== undefined && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== undefined && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== undefined && (obj.bondDenom = message.bondDenom);
        message.minCommissionRate !== undefined && (obj.minCommissionRate = message.minCommissionRate);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseParams();
        if (object.unbondingTime !== undefined && object.unbondingTime !== null) message.unbondingTime = duration_1.Duration.fromPartial(object.unbondingTime);
        message.maxValidators = object.maxValidators ?? 0;
        message.maxEntries = object.maxEntries ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.bondDenom = object.bondDenom ?? "";
        message.minCommissionRate = object.minCommissionRate ?? "";
        return message;
    }
};
function createBaseDelegationResponse() {
    return {
        delegation: exports.Delegation.fromPartial({}),
        balance: coin_1.Coin.fromPartial({})
    };
}
exports.DelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegation !== undefined) exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        if (message.balance !== undefined) coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegation = exports.Delegation.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegation)) obj.delegation = exports.Delegation.fromJSON(object.delegation);
        if ((0, helpers_1.isSet)(object.balance)) obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegation !== undefined && (obj.delegation = message.delegation ? exports.Delegation.toJSON(message.delegation) : undefined);
        message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDelegationResponse();
        if (object.delegation !== undefined && object.delegation !== null) message.delegation = exports.Delegation.fromPartial(object.delegation);
        if (object.balance !== undefined && object.balance !== null) message.balance = coin_1.Coin.fromPartial(object.balance);
        return message;
    }
};
function createBaseRedelegationEntryResponse() {
    return {
        redelegationEntry: exports.RedelegationEntry.fromPartial({}),
        balance: ""
    };
}
exports.RedelegationEntryResponse = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegationEntry !== undefined) exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        if (message.balance !== "") writer.uint32(34).string(message.balance);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.balance = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRedelegationEntryResponse();
        if ((0, helpers_1.isSet)(object.redelegationEntry)) obj.redelegationEntry = exports.RedelegationEntry.fromJSON(object.redelegationEntry);
        if ((0, helpers_1.isSet)(object.balance)) obj.balance = String(object.balance);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.redelegationEntry !== undefined && (obj.redelegationEntry = message.redelegationEntry ? exports.RedelegationEntry.toJSON(message.redelegationEntry) : undefined);
        message.balance !== undefined && (obj.balance = message.balance);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRedelegationEntryResponse();
        if (object.redelegationEntry !== undefined && object.redelegationEntry !== null) message.redelegationEntry = exports.RedelegationEntry.fromPartial(object.redelegationEntry);
        message.balance = object.balance ?? "";
        return message;
    }
};
function createBaseRedelegationResponse() {
    return {
        redelegation: exports.Redelegation.fromPartial({}),
        entries: []
    };
}
exports.RedelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegation !== undefined) exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        for (const v of message.entries)exports.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.redelegation = exports.Redelegation.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRedelegationResponse();
        if ((0, helpers_1.isSet)(object.redelegation)) obj.redelegation = exports.Redelegation.fromJSON(object.redelegation);
        if (Array.isArray(object?.entries)) obj.entries = object.entries.map((e)=>exports.RedelegationEntryResponse.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.redelegation !== undefined && (obj.redelegation = message.redelegation ? exports.Redelegation.toJSON(message.redelegation) : undefined);
        if (message.entries) obj.entries = message.entries.map((e)=>e ? exports.RedelegationEntryResponse.toJSON(e) : undefined);
        else obj.entries = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRedelegationResponse();
        if (object.redelegation !== undefined && object.redelegation !== null) message.redelegation = exports.Redelegation.fromPartial(object.redelegation);
        message.entries = object.entries?.map((e)=>exports.RedelegationEntryResponse.fromPartial(e)) || [];
        return message;
    }
};
function createBasePool() {
    return {
        notBondedTokens: "",
        bondedTokens: ""
    };
}
exports.Pool = {
    typeUrl: "/cosmos.staking.v1beta1.Pool",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.notBondedTokens !== "") writer.uint32(10).string(message.notBondedTokens);
        if (message.bondedTokens !== "") writer.uint32(18).string(message.bondedTokens);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePool();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.notBondedTokens = reader.string();
                    break;
                case 2:
                    message.bondedTokens = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBasePool();
        if ((0, helpers_1.isSet)(object.notBondedTokens)) obj.notBondedTokens = String(object.notBondedTokens);
        if ((0, helpers_1.isSet)(object.bondedTokens)) obj.bondedTokens = String(object.bondedTokens);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.notBondedTokens !== undefined && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== undefined && (obj.bondedTokens = message.bondedTokens);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePool();
        message.notBondedTokens = object.notBondedTokens ?? "";
        message.bondedTokens = object.bondedTokens ?? "";
        return message;
    }
};
function createBaseValidatorUpdates() {
    return {
        updates: []
    };
}
exports.ValidatorUpdates = {
    typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.updates)types_2.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.updates.push(types_2.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorUpdates();
        if (Array.isArray(object?.updates)) obj.updates = object.updates.map((e)=>types_2.ValidatorUpdate.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.updates) obj.updates = message.updates.map((e)=>e ? types_2.ValidatorUpdate.toJSON(e) : undefined);
        else obj.updates = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorUpdates();
        message.updates = object.updates?.map((e)=>types_2.ValidatorUpdate.fromPartial(e)) || [];
        return message;
    }
};

},{"a29b35cc5b42903b":"9y1Fs","531607033cf8cf2a":"6J6bq","f5ad4e66961f1148":"56aJC","64732a6c581bd824":"clU50","ca2bc722a53c2ba7":"1ymyZ","c2df9c8f9bfeb83":"7FclI","5a97514c26c40707":"bi36x","acccabd011593d65":"eYjRL"}],"7FclI":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResponsePrepareProposal = exports.ResponseApplySnapshotChunk = exports.ResponseLoadSnapshotChunk = exports.ResponseOfferSnapshot = exports.ResponseListSnapshots = exports.ResponseCommit = exports.ResponseCheckTx = exports.ResponseQuery = exports.ResponseInitChain = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseEcho = exports.ResponseException = exports.Response = exports.RequestFinalizeBlock = exports.RequestVerifyVoteExtension = exports.RequestExtendVote = exports.RequestProcessProposal = exports.RequestPrepareProposal = exports.RequestApplySnapshotChunk = exports.RequestLoadSnapshotChunk = exports.RequestOfferSnapshot = exports.RequestListSnapshots = exports.RequestCommit = exports.RequestCheckTx = exports.RequestQuery = exports.RequestInitChain = exports.RequestInfo = exports.RequestFlush = exports.RequestEcho = exports.Request = exports.misbehaviorTypeToJSON = exports.misbehaviorTypeFromJSON = exports.MisbehaviorType = exports.responseVerifyVoteExtension_VerifyStatusToJSON = exports.responseVerifyVoteExtension_VerifyStatusFromJSON = exports.ResponseVerifyVoteExtension_VerifyStatus = exports.responseProcessProposal_ProposalStatusToJSON = exports.responseProcessProposal_ProposalStatusFromJSON = exports.ResponseProcessProposal_ProposalStatus = exports.responseApplySnapshotChunk_ResultToJSON = exports.responseApplySnapshotChunk_ResultFromJSON = exports.ResponseApplySnapshotChunk_Result = exports.responseOfferSnapshot_ResultToJSON = exports.responseOfferSnapshot_ResultFromJSON = exports.ResponseOfferSnapshot_Result = exports.checkTxTypeToJSON = exports.checkTxTypeFromJSON = exports.CheckTxType = exports.protobufPackage = void 0;
exports.Snapshot = exports.Misbehavior = exports.ExtendedVoteInfo = exports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.ExecTxResult = exports.EventAttribute = exports.Event = exports.ExtendedCommitInfo = exports.CommitInfo = exports.ResponseFinalizeBlock = exports.ResponseVerifyVoteExtension = exports.ResponseExtendVote = exports.ResponseProcessProposal = void 0;
/* eslint-disable */ const timestamp_1 = require("46314a12c3292c36");
const params_1 = require("f0d323fdef968b6e");
const proof_1 = require("261e881c6aa55142");
const keys_1 = require("fc97a8a8eda4d345");
const validator_1 = require("3d45ec18aba95bc0");
const binary_1 = require("f4f6d86527d72e00");
const helpers_1 = require("6c1a81a3d284ff16");
exports.protobufPackage = "tendermint.abci";
var CheckTxType;
(function(CheckTxType) {
    CheckTxType[CheckTxType["NEW"] = 0] = "NEW";
    CheckTxType[CheckTxType["RECHECK"] = 1] = "RECHECK";
    CheckTxType[CheckTxType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CheckTxType || (exports.CheckTxType = CheckTxType = {}));
function checkTxTypeFromJSON(object) {
    switch(object){
        case 0:
        case "NEW":
            return CheckTxType.NEW;
        case 1:
        case "RECHECK":
            return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CheckTxType.UNRECOGNIZED;
    }
}
exports.checkTxTypeFromJSON = checkTxTypeFromJSON;
function checkTxTypeToJSON(object) {
    switch(object){
        case CheckTxType.NEW:
            return "NEW";
        case CheckTxType.RECHECK:
            return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.checkTxTypeToJSON = checkTxTypeToJSON;
var ResponseOfferSnapshot_Result;
(function(ResponseOfferSnapshot_Result) {
    /** UNKNOWN - Unknown result, abort all snapshot restoration */ ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNKNOWN"] = 0] = "UNKNOWN";
    /** ACCEPT - Snapshot accepted, apply chunks */ ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ACCEPT"] = 1] = "ACCEPT";
    /** ABORT - Abort all snapshot restoration */ ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ABORT"] = 2] = "ABORT";
    /** REJECT - Reject this specific snapshot, try others */ ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT"] = 3] = "REJECT";
    /** REJECT_FORMAT - Reject all snapshots of this format, try others */ ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
    /** REJECT_SENDER - Reject all snapshots from the sender(s), try others */ ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_SENDER"] = 5] = "REJECT_SENDER";
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result = {}));
function responseOfferSnapshot_ResultFromJSON(object) {
    switch(object){
        case 0:
        case "UNKNOWN":
            return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
            return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
            return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
            return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
            return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
            return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseOfferSnapshot_Result.UNRECOGNIZED;
    }
}
exports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
function responseOfferSnapshot_ResultToJSON(object) {
    switch(object){
        case ResponseOfferSnapshot_Result.UNKNOWN:
            return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
            return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
            return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
            return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
            return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
            return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
var ResponseApplySnapshotChunk_Result;
(function(ResponseApplySnapshotChunk_Result) {
    /** UNKNOWN - Unknown result, abort all snapshot restoration */ ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNKNOWN"] = 0] = "UNKNOWN";
    /** ACCEPT - Chunk successfully accepted */ ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ACCEPT"] = 1] = "ACCEPT";
    /** ABORT - Abort all snapshot restoration */ ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ABORT"] = 2] = "ABORT";
    /** RETRY - Retry chunk (combine with refetch and reject) */ ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY"] = 3] = "RETRY";
    /** RETRY_SNAPSHOT - Retry snapshot (combine with refetch and reject) */ ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
    /** REJECT_SNAPSHOT - Reject this snapshot, try others */ ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result = {}));
function responseApplySnapshotChunk_ResultFromJSON(object) {
    switch(object){
        case 0:
        case "UNKNOWN":
            return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
            return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
            return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
            return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
            return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
            return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
    }
}
exports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
function responseApplySnapshotChunk_ResultToJSON(object) {
    switch(object){
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
            return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
            return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
            return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
            return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
            return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
            return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
var ResponseProcessProposal_ProposalStatus;
(function(ResponseProcessProposal_ProposalStatus) {
    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["UNKNOWN"] = 0] = "UNKNOWN";
    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["ACCEPT"] = 1] = "ACCEPT";
    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["REJECT"] = 2] = "REJECT";
    ResponseProcessProposal_ProposalStatus[ResponseProcessProposal_ProposalStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseProcessProposal_ProposalStatus || (exports.ResponseProcessProposal_ProposalStatus = ResponseProcessProposal_ProposalStatus = {}));
function responseProcessProposal_ProposalStatusFromJSON(object) {
    switch(object){
        case 0:
        case "UNKNOWN":
            return ResponseProcessProposal_ProposalStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
            return ResponseProcessProposal_ProposalStatus.ACCEPT;
        case 2:
        case "REJECT":
            return ResponseProcessProposal_ProposalStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseProcessProposal_ProposalStatus.UNRECOGNIZED;
    }
}
exports.responseProcessProposal_ProposalStatusFromJSON = responseProcessProposal_ProposalStatusFromJSON;
function responseProcessProposal_ProposalStatusToJSON(object) {
    switch(object){
        case ResponseProcessProposal_ProposalStatus.UNKNOWN:
            return "UNKNOWN";
        case ResponseProcessProposal_ProposalStatus.ACCEPT:
            return "ACCEPT";
        case ResponseProcessProposal_ProposalStatus.REJECT:
            return "REJECT";
        case ResponseProcessProposal_ProposalStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.responseProcessProposal_ProposalStatusToJSON = responseProcessProposal_ProposalStatusToJSON;
var ResponseVerifyVoteExtension_VerifyStatus;
(function(ResponseVerifyVoteExtension_VerifyStatus) {
    ResponseVerifyVoteExtension_VerifyStatus[ResponseVerifyVoteExtension_VerifyStatus["UNKNOWN"] = 0] = "UNKNOWN";
    ResponseVerifyVoteExtension_VerifyStatus[ResponseVerifyVoteExtension_VerifyStatus["ACCEPT"] = 1] = "ACCEPT";
    /**
     * REJECT - Rejecting the vote extension will reject the entire precommit by the sender.
     * Incorrectly implementing this thus has liveness implications as it may affect
     * CometBFT's ability to receive 2/3+ valid votes to finalize the block.
     * Honest nodes should never be rejected.
     */ ResponseVerifyVoteExtension_VerifyStatus[ResponseVerifyVoteExtension_VerifyStatus["REJECT"] = 2] = "REJECT";
    ResponseVerifyVoteExtension_VerifyStatus[ResponseVerifyVoteExtension_VerifyStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseVerifyVoteExtension_VerifyStatus || (exports.ResponseVerifyVoteExtension_VerifyStatus = ResponseVerifyVoteExtension_VerifyStatus = {}));
function responseVerifyVoteExtension_VerifyStatusFromJSON(object) {
    switch(object){
        case 0:
        case "UNKNOWN":
            return ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
            return ResponseVerifyVoteExtension_VerifyStatus.ACCEPT;
        case 2:
        case "REJECT":
            return ResponseVerifyVoteExtension_VerifyStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED;
    }
}
exports.responseVerifyVoteExtension_VerifyStatusFromJSON = responseVerifyVoteExtension_VerifyStatusFromJSON;
function responseVerifyVoteExtension_VerifyStatusToJSON(object) {
    switch(object){
        case ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN:
            return "UNKNOWN";
        case ResponseVerifyVoteExtension_VerifyStatus.ACCEPT:
            return "ACCEPT";
        case ResponseVerifyVoteExtension_VerifyStatus.REJECT:
            return "REJECT";
        case ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.responseVerifyVoteExtension_VerifyStatusToJSON = responseVerifyVoteExtension_VerifyStatusToJSON;
var MisbehaviorType;
(function(MisbehaviorType) {
    MisbehaviorType[MisbehaviorType["UNKNOWN"] = 0] = "UNKNOWN";
    MisbehaviorType[MisbehaviorType["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
    MisbehaviorType[MisbehaviorType["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
    MisbehaviorType[MisbehaviorType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MisbehaviorType || (exports.MisbehaviorType = MisbehaviorType = {}));
function misbehaviorTypeFromJSON(object) {
    switch(object){
        case 0:
        case "UNKNOWN":
            return MisbehaviorType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
            return MisbehaviorType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
            return MisbehaviorType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return MisbehaviorType.UNRECOGNIZED;
    }
}
exports.misbehaviorTypeFromJSON = misbehaviorTypeFromJSON;
function misbehaviorTypeToJSON(object) {
    switch(object){
        case MisbehaviorType.UNKNOWN:
            return "UNKNOWN";
        case MisbehaviorType.DUPLICATE_VOTE:
            return "DUPLICATE_VOTE";
        case MisbehaviorType.LIGHT_CLIENT_ATTACK:
            return "LIGHT_CLIENT_ATTACK";
        case MisbehaviorType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.misbehaviorTypeToJSON = misbehaviorTypeToJSON;
function createBaseRequest() {
    return {
        echo: undefined,
        flush: undefined,
        info: undefined,
        initChain: undefined,
        query: undefined,
        checkTx: undefined,
        commit: undefined,
        listSnapshots: undefined,
        offerSnapshot: undefined,
        loadSnapshotChunk: undefined,
        applySnapshotChunk: undefined,
        prepareProposal: undefined,
        processProposal: undefined,
        extendVote: undefined,
        verifyVoteExtension: undefined,
        finalizeBlock: undefined
    };
}
exports.Request = {
    typeUrl: "/tendermint.abci.Request",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.echo !== undefined) exports.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        if (message.flush !== undefined) exports.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        if (message.info !== undefined) exports.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        if (message.initChain !== undefined) exports.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        if (message.query !== undefined) exports.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        if (message.checkTx !== undefined) exports.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        if (message.commit !== undefined) exports.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        if (message.listSnapshots !== undefined) exports.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        if (message.offerSnapshot !== undefined) exports.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        if (message.loadSnapshotChunk !== undefined) exports.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        if (message.applySnapshotChunk !== undefined) exports.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        if (message.prepareProposal !== undefined) exports.RequestPrepareProposal.encode(message.prepareProposal, writer.uint32(130).fork()).ldelim();
        if (message.processProposal !== undefined) exports.RequestProcessProposal.encode(message.processProposal, writer.uint32(138).fork()).ldelim();
        if (message.extendVote !== undefined) exports.RequestExtendVote.encode(message.extendVote, writer.uint32(146).fork()).ldelim();
        if (message.verifyVoteExtension !== undefined) exports.RequestVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(154).fork()).ldelim();
        if (message.finalizeBlock !== undefined) exports.RequestFinalizeBlock.encode(message.finalizeBlock, writer.uint32(162).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.echo = exports.RequestEcho.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.flush = exports.RequestFlush.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.info = exports.RequestInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.initChain = exports.RequestInitChain.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.query = exports.RequestQuery.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.checkTx = exports.RequestCheckTx.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.commit = exports.RequestCommit.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.listSnapshots = exports.RequestListSnapshots.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.offerSnapshot = exports.RequestOfferSnapshot.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.applySnapshotChunk = exports.RequestApplySnapshotChunk.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.prepareProposal = exports.RequestPrepareProposal.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.processProposal = exports.RequestProcessProposal.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.extendVote = exports.RequestExtendVote.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.verifyVoteExtension = exports.RequestVerifyVoteExtension.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.finalizeBlock = exports.RequestFinalizeBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequest();
        if ((0, helpers_1.isSet)(object.echo)) obj.echo = exports.RequestEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush)) obj.flush = exports.RequestFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info)) obj.info = exports.RequestInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain)) obj.initChain = exports.RequestInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query)) obj.query = exports.RequestQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx)) obj.checkTx = exports.RequestCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit)) obj.commit = exports.RequestCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots)) obj.listSnapshots = exports.RequestListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot)) obj.offerSnapshot = exports.RequestOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk)) obj.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk)) obj.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal)) obj.prepareProposal = exports.RequestPrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal)) obj.processProposal = exports.RequestProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote)) obj.extendVote = exports.RequestExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension)) obj.verifyVoteExtension = exports.RequestVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock)) obj.finalizeBlock = exports.RequestFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.echo !== undefined && (obj.echo = message.echo ? exports.RequestEcho.toJSON(message.echo) : undefined);
        message.flush !== undefined && (obj.flush = message.flush ? exports.RequestFlush.toJSON(message.flush) : undefined);
        message.info !== undefined && (obj.info = message.info ? exports.RequestInfo.toJSON(message.info) : undefined);
        message.initChain !== undefined && (obj.initChain = message.initChain ? exports.RequestInitChain.toJSON(message.initChain) : undefined);
        message.query !== undefined && (obj.query = message.query ? exports.RequestQuery.toJSON(message.query) : undefined);
        message.checkTx !== undefined && (obj.checkTx = message.checkTx ? exports.RequestCheckTx.toJSON(message.checkTx) : undefined);
        message.commit !== undefined && (obj.commit = message.commit ? exports.RequestCommit.toJSON(message.commit) : undefined);
        message.listSnapshots !== undefined && (obj.listSnapshots = message.listSnapshots ? exports.RequestListSnapshots.toJSON(message.listSnapshots) : undefined);
        message.offerSnapshot !== undefined && (obj.offerSnapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toJSON(message.offerSnapshot) : undefined);
        message.loadSnapshotChunk !== undefined && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : undefined);
        message.applySnapshotChunk !== undefined && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : undefined);
        message.prepareProposal !== undefined && (obj.prepareProposal = message.prepareProposal ? exports.RequestPrepareProposal.toJSON(message.prepareProposal) : undefined);
        message.processProposal !== undefined && (obj.processProposal = message.processProposal ? exports.RequestProcessProposal.toJSON(message.processProposal) : undefined);
        message.extendVote !== undefined && (obj.extendVote = message.extendVote ? exports.RequestExtendVote.toJSON(message.extendVote) : undefined);
        message.verifyVoteExtension !== undefined && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports.RequestVerifyVoteExtension.toJSON(message.verifyVoteExtension) : undefined);
        message.finalizeBlock !== undefined && (obj.finalizeBlock = message.finalizeBlock ? exports.RequestFinalizeBlock.toJSON(message.finalizeBlock) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequest();
        if (object.echo !== undefined && object.echo !== null) message.echo = exports.RequestEcho.fromPartial(object.echo);
        if (object.flush !== undefined && object.flush !== null) message.flush = exports.RequestFlush.fromPartial(object.flush);
        if (object.info !== undefined && object.info !== null) message.info = exports.RequestInfo.fromPartial(object.info);
        if (object.initChain !== undefined && object.initChain !== null) message.initChain = exports.RequestInitChain.fromPartial(object.initChain);
        if (object.query !== undefined && object.query !== null) message.query = exports.RequestQuery.fromPartial(object.query);
        if (object.checkTx !== undefined && object.checkTx !== null) message.checkTx = exports.RequestCheckTx.fromPartial(object.checkTx);
        if (object.commit !== undefined && object.commit !== null) message.commit = exports.RequestCommit.fromPartial(object.commit);
        if (object.listSnapshots !== undefined && object.listSnapshots !== null) message.listSnapshots = exports.RequestListSnapshots.fromPartial(object.listSnapshots);
        if (object.offerSnapshot !== undefined && object.offerSnapshot !== null) message.offerSnapshot = exports.RequestOfferSnapshot.fromPartial(object.offerSnapshot);
        if (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null) message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        if (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null) message.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        if (object.prepareProposal !== undefined && object.prepareProposal !== null) message.prepareProposal = exports.RequestPrepareProposal.fromPartial(object.prepareProposal);
        if (object.processProposal !== undefined && object.processProposal !== null) message.processProposal = exports.RequestProcessProposal.fromPartial(object.processProposal);
        if (object.extendVote !== undefined && object.extendVote !== null) message.extendVote = exports.RequestExtendVote.fromPartial(object.extendVote);
        if (object.verifyVoteExtension !== undefined && object.verifyVoteExtension !== null) message.verifyVoteExtension = exports.RequestVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        if (object.finalizeBlock !== undefined && object.finalizeBlock !== null) message.finalizeBlock = exports.RequestFinalizeBlock.fromPartial(object.finalizeBlock);
        return message;
    }
};
function createBaseRequestEcho() {
    return {
        message: ""
    };
}
exports.RequestEcho = {
    typeUrl: "/tendermint.abci.RequestEcho",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") writer.uint32(10).string(message.message);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestEcho();
        if ((0, helpers_1.isSet)(object.message)) obj.message = String(object.message);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestEcho();
        message.message = object.message ?? "";
        return message;
    }
};
function createBaseRequestFlush() {
    return {};
}
exports.RequestFlush = {
    typeUrl: "/tendermint.abci.RequestFlush",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseRequestFlush();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseRequestFlush();
        return message;
    }
};
function createBaseRequestInfo() {
    return {
        version: "",
        blockVersion: BigInt(0),
        p2pVersion: BigInt(0),
        abciVersion: ""
    };
}
exports.RequestInfo = {
    typeUrl: "/tendermint.abci.RequestInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") writer.uint32(10).string(message.version);
        if (message.blockVersion !== BigInt(0)) writer.uint32(16).uint64(message.blockVersion);
        if (message.p2pVersion !== BigInt(0)) writer.uint32(24).uint64(message.p2pVersion);
        if (message.abciVersion !== "") writer.uint32(34).string(message.abciVersion);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.blockVersion = reader.uint64();
                    break;
                case 3:
                    message.p2pVersion = reader.uint64();
                    break;
                case 4:
                    message.abciVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestInfo();
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.blockVersion)) obj.blockVersion = BigInt(object.blockVersion.toString());
        if ((0, helpers_1.isSet)(object.p2pVersion)) obj.p2pVersion = BigInt(object.p2pVersion.toString());
        if ((0, helpers_1.isSet)(object.abciVersion)) obj.abciVersion = String(object.abciVersion);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.version !== undefined && (obj.version = message.version);
        message.blockVersion !== undefined && (obj.blockVersion = (message.blockVersion || BigInt(0)).toString());
        message.p2pVersion !== undefined && (obj.p2pVersion = (message.p2pVersion || BigInt(0)).toString());
        message.abciVersion !== undefined && (obj.abciVersion = message.abciVersion);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestInfo();
        message.version = object.version ?? "";
        if (object.blockVersion !== undefined && object.blockVersion !== null) message.blockVersion = BigInt(object.blockVersion.toString());
        if (object.p2pVersion !== undefined && object.p2pVersion !== null) message.p2pVersion = BigInt(object.p2pVersion.toString());
        message.abciVersion = object.abciVersion ?? "";
        return message;
    }
};
function createBaseRequestInitChain() {
    return {
        time: timestamp_1.Timestamp.fromPartial({}),
        chainId: "",
        consensusParams: undefined,
        validators: [],
        appStateBytes: new Uint8Array(),
        initialHeight: BigInt(0)
    };
}
exports.RequestInitChain = {
    typeUrl: "/tendermint.abci.RequestInitChain",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        if (message.chainId !== "") writer.uint32(18).string(message.chainId);
        if (message.consensusParams !== undefined) params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        for (const v of message.validators)exports.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        if (message.appStateBytes.length !== 0) writer.uint32(42).bytes(message.appStateBytes);
        if (message.initialHeight !== BigInt(0)) writer.uint32(48).int64(message.initialHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.appStateBytes = reader.bytes();
                    break;
                case 6:
                    message.initialHeight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestInitChain();
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.chainId)) obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.consensusParams)) obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object?.validators)) obj.validators = object.validators.map((e)=>exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appStateBytes)) obj.appStateBytes = (0, helpers_1.bytesFromBase64)(object.appStateBytes);
        if ((0, helpers_1.isSet)(object.initialHeight)) obj.initialHeight = BigInt(object.initialHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.consensusParams !== undefined && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : undefined);
        if (message.validators) obj.validators = message.validators.map((e)=>e ? exports.ValidatorUpdate.toJSON(e) : undefined);
        else obj.validators = [];
        message.appStateBytes !== undefined && (obj.appStateBytes = (0, helpers_1.base64FromBytes)(message.appStateBytes !== undefined ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== undefined && (obj.initialHeight = (message.initialHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestInitChain();
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        message.chainId = object.chainId ?? "";
        if (object.consensusParams !== undefined && object.consensusParams !== null) message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        message.validators = object.validators?.map((e)=>exports.ValidatorUpdate.fromPartial(e)) || [];
        message.appStateBytes = object.appStateBytes ?? new Uint8Array();
        if (object.initialHeight !== undefined && object.initialHeight !== null) message.initialHeight = BigInt(object.initialHeight.toString());
        return message;
    }
};
function createBaseRequestQuery() {
    return {
        data: new Uint8Array(),
        path: "",
        height: BigInt(0),
        prove: false
    };
}
exports.RequestQuery = {
    typeUrl: "/tendermint.abci.RequestQuery",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) writer.uint32(10).bytes(message.data);
        if (message.path !== "") writer.uint32(18).string(message.path);
        if (message.height !== BigInt(0)) writer.uint32(24).int64(message.height);
        if (message.prove === true) writer.uint32(32).bool(message.prove);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.height = reader.int64();
                    break;
                case 4:
                    message.prove = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestQuery();
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.path)) obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.prove)) obj.prove = Boolean(object.prove);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.path !== undefined && (obj.path = message.path);
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.prove !== undefined && (obj.prove = message.prove);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestQuery();
        message.data = object.data ?? new Uint8Array();
        message.path = object.path ?? "";
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.prove = object.prove ?? false;
        return message;
    }
};
function createBaseRequestCheckTx() {
    return {
        tx: new Uint8Array(),
        type: 0
    };
}
exports.RequestCheckTx = {
    typeUrl: "/tendermint.abci.RequestCheckTx",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx.length !== 0) writer.uint32(10).bytes(message.tx);
        if (message.type !== 0) writer.uint32(16).int32(message.type);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.tx = reader.bytes();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestCheckTx();
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.type)) obj.type = checkTxTypeFromJSON(object.type);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.tx !== undefined && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== undefined ? message.tx : new Uint8Array()));
        message.type !== undefined && (obj.type = checkTxTypeToJSON(message.type));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestCheckTx();
        message.tx = object.tx ?? new Uint8Array();
        message.type = object.type ?? 0;
        return message;
    }
};
function createBaseRequestCommit() {
    return {};
}
exports.RequestCommit = {
    typeUrl: "/tendermint.abci.RequestCommit",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseRequestCommit();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseRequestCommit();
        return message;
    }
};
function createBaseRequestListSnapshots() {
    return {};
}
exports.RequestListSnapshots = {
    typeUrl: "/tendermint.abci.RequestListSnapshots",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseRequestListSnapshots();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseRequestListSnapshots();
        return message;
    }
};
function createBaseRequestOfferSnapshot() {
    return {
        snapshot: undefined,
        appHash: new Uint8Array()
    };
}
exports.RequestOfferSnapshot = {
    typeUrl: "/tendermint.abci.RequestOfferSnapshot",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.snapshot !== undefined) exports.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        if (message.appHash.length !== 0) writer.uint32(18).bytes(message.appHash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.snapshot = exports.Snapshot.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.appHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestOfferSnapshot();
        if ((0, helpers_1.isSet)(object.snapshot)) obj.snapshot = exports.Snapshot.fromJSON(object.snapshot);
        if ((0, helpers_1.isSet)(object.appHash)) obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.snapshot !== undefined && (obj.snapshot = message.snapshot ? exports.Snapshot.toJSON(message.snapshot) : undefined);
        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestOfferSnapshot();
        if (object.snapshot !== undefined && object.snapshot !== null) message.snapshot = exports.Snapshot.fromPartial(object.snapshot);
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
    }
};
function createBaseRequestLoadSnapshotChunk() {
    return {
        height: BigInt(0),
        format: 0,
        chunk: 0
    };
}
exports.RequestLoadSnapshotChunk = {
    typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).uint64(message.height);
        if (message.format !== 0) writer.uint32(16).uint32(message.format);
        if (message.chunk !== 0) writer.uint32(24).uint32(message.chunk);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.uint64();
                    break;
                case 2:
                    message.format = reader.uint32();
                    break;
                case 3:
                    message.chunk = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format)) obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunk)) obj.chunk = Number(object.chunk);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== undefined && (obj.format = Math.round(message.format));
        message.chunk !== undefined && (obj.chunk = Math.round(message.chunk));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestLoadSnapshotChunk();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.format = object.format ?? 0;
        message.chunk = object.chunk ?? 0;
        return message;
    }
};
function createBaseRequestApplySnapshotChunk() {
    return {
        index: 0,
        chunk: new Uint8Array(),
        sender: ""
    };
}
exports.RequestApplySnapshotChunk = {
    typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) writer.uint32(8).uint32(message.index);
        if (message.chunk.length !== 0) writer.uint32(18).bytes(message.chunk);
        if (message.sender !== "") writer.uint32(26).string(message.sender);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.index = reader.uint32();
                    break;
                case 2:
                    message.chunk = reader.bytes();
                    break;
                case 3:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.index)) obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.chunk)) obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        if ((0, helpers_1.isSet)(object.sender)) obj.sender = String(object.sender);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.chunk !== undefined && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== undefined ? message.chunk : new Uint8Array()));
        message.sender !== undefined && (obj.sender = message.sender);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestApplySnapshotChunk();
        message.index = object.index ?? 0;
        message.chunk = object.chunk ?? new Uint8Array();
        message.sender = object.sender ?? "";
        return message;
    }
};
function createBaseRequestPrepareProposal() {
    return {
        maxTxBytes: BigInt(0),
        txs: [],
        localLastCommit: exports.ExtendedCommitInfo.fromPartial({}),
        misbehavior: [],
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
    };
}
exports.RequestPrepareProposal = {
    typeUrl: "/tendermint.abci.RequestPrepareProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxTxBytes !== BigInt(0)) writer.uint32(8).int64(message.maxTxBytes);
        for (const v of message.txs)writer.uint32(18).bytes(v);
        if (message.localLastCommit !== undefined) exports.ExtendedCommitInfo.encode(message.localLastCommit, writer.uint32(26).fork()).ldelim();
        for (const v of message.misbehavior)exports.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
        if (message.height !== BigInt(0)) writer.uint32(40).int64(message.height);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        if (message.nextValidatorsHash.length !== 0) writer.uint32(58).bytes(message.nextValidatorsHash);
        if (message.proposerAddress.length !== 0) writer.uint32(66).bytes(message.proposerAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestPrepareProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.maxTxBytes = reader.int64();
                    break;
                case 2:
                    message.txs.push(reader.bytes());
                    break;
                case 3:
                    message.localLastCommit = exports.ExtendedCommitInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.height = reader.int64();
                    break;
                case 6:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestPrepareProposal();
        if ((0, helpers_1.isSet)(object.maxTxBytes)) obj.maxTxBytes = BigInt(object.maxTxBytes.toString());
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.localLastCommit)) obj.localLastCommit = exports.ExtendedCommitInfo.fromJSON(object.localLastCommit);
        if (Array.isArray(object?.misbehavior)) obj.misbehavior = object.misbehavior.map((e)=>exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash)) obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress)) obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.maxTxBytes !== undefined && (obj.maxTxBytes = (message.maxTxBytes || BigInt(0)).toString());
        if (message.txs) obj.txs = message.txs.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.txs = [];
        message.localLastCommit !== undefined && (obj.localLastCommit = message.localLastCommit ? exports.ExtendedCommitInfo.toJSON(message.localLastCommit) : undefined);
        if (message.misbehavior) obj.misbehavior = message.misbehavior.map((e)=>e ? exports.Misbehavior.toJSON(e) : undefined);
        else obj.misbehavior = [];
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestPrepareProposal();
        if (object.maxTxBytes !== undefined && object.maxTxBytes !== null) message.maxTxBytes = BigInt(object.maxTxBytes.toString());
        message.txs = object.txs?.map((e)=>e) || [];
        if (object.localLastCommit !== undefined && object.localLastCommit !== null) message.localLastCommit = exports.ExtendedCommitInfo.fromPartial(object.localLastCommit);
        message.misbehavior = object.misbehavior?.map((e)=>exports.Misbehavior.fromPartial(e)) || [];
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
    }
};
function createBaseRequestProcessProposal() {
    return {
        txs: [],
        proposedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
    };
}
exports.RequestProcessProposal = {
    typeUrl: "/tendermint.abci.RequestProcessProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs)writer.uint32(10).bytes(v);
        if (message.proposedLastCommit !== undefined) exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(18).fork()).ldelim();
        for (const v of message.misbehavior)exports.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.hash.length !== 0) writer.uint32(34).bytes(message.hash);
        if (message.height !== BigInt(0)) writer.uint32(40).int64(message.height);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        if (message.nextValidatorsHash.length !== 0) writer.uint32(58).bytes(message.nextValidatorsHash);
        if (message.proposerAddress.length !== 0) writer.uint32(66).bytes(message.proposerAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestProcessProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txs.push(reader.bytes());
                    break;
                case 2:
                    message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.hash = reader.bytes();
                    break;
                case 5:
                    message.height = reader.int64();
                    break;
                case 6:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestProcessProposal();
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit)) obj.proposedLastCommit = exports.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object?.misbehavior)) obj.misbehavior = object.misbehavior.map((e)=>exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash)) obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress)) obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.txs) obj.txs = message.txs.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.txs = [];
        message.proposedLastCommit !== undefined && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : undefined);
        if (message.misbehavior) obj.misbehavior = message.misbehavior.map((e)=>e ? exports.Misbehavior.toJSON(e) : undefined);
        else obj.misbehavior = [];
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestProcessProposal();
        message.txs = object.txs?.map((e)=>e) || [];
        if (object.proposedLastCommit !== undefined && object.proposedLastCommit !== null) message.proposedLastCommit = exports.CommitInfo.fromPartial(object.proposedLastCommit);
        message.misbehavior = object.misbehavior?.map((e)=>exports.Misbehavior.fromPartial(e)) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
    }
};
function createBaseRequestExtendVote() {
    return {
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        txs: [],
        proposedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
    };
}
exports.RequestExtendVote = {
    typeUrl: "/tendermint.abci.RequestExtendVote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) writer.uint32(10).bytes(message.hash);
        if (message.height !== BigInt(0)) writer.uint32(16).int64(message.height);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(26).fork()).ldelim();
        for (const v of message.txs)writer.uint32(34).bytes(v);
        if (message.proposedLastCommit !== undefined) exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(42).fork()).ldelim();
        for (const v of message.misbehavior)exports.Misbehavior.encode(v, writer.uint32(50).fork()).ldelim();
        if (message.nextValidatorsHash.length !== 0) writer.uint32(58).bytes(message.nextValidatorsHash);
        if (message.proposerAddress.length !== 0) writer.uint32(66).bytes(message.proposerAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestExtendVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.height = reader.int64();
                    break;
                case 3:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.txs.push(reader.bytes());
                    break;
                case 5:
                    message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestExtendVote();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit)) obj.proposedLastCommit = exports.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object?.misbehavior)) obj.misbehavior = object.misbehavior.map((e)=>exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.nextValidatorsHash)) obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress)) obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        if (message.txs) obj.txs = message.txs.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.txs = [];
        message.proposedLastCommit !== undefined && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : undefined);
        if (message.misbehavior) obj.misbehavior = message.misbehavior.map((e)=>e ? exports.Misbehavior.toJSON(e) : undefined);
        else obj.misbehavior = [];
        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestExtendVote();
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        message.txs = object.txs?.map((e)=>e) || [];
        if (object.proposedLastCommit !== undefined && object.proposedLastCommit !== null) message.proposedLastCommit = exports.CommitInfo.fromPartial(object.proposedLastCommit);
        message.misbehavior = object.misbehavior?.map((e)=>exports.Misbehavior.fromPartial(e)) || [];
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
    }
};
function createBaseRequestVerifyVoteExtension() {
    return {
        hash: new Uint8Array(),
        validatorAddress: new Uint8Array(),
        height: BigInt(0),
        voteExtension: new Uint8Array()
    };
}
exports.RequestVerifyVoteExtension = {
    typeUrl: "/tendermint.abci.RequestVerifyVoteExtension",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) writer.uint32(10).bytes(message.hash);
        if (message.validatorAddress.length !== 0) writer.uint32(18).bytes(message.validatorAddress);
        if (message.height !== BigInt(0)) writer.uint32(24).int64(message.height);
        if (message.voteExtension.length !== 0) writer.uint32(34).bytes(message.voteExtension);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestVerifyVoteExtension();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.validatorAddress = reader.bytes();
                    break;
                case 3:
                    message.height = reader.int64();
                    break;
                case 4:
                    message.voteExtension = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestVerifyVoteExtension();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.validatorAddress)) obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.voteExtension)) obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.validatorAddress !== undefined && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== undefined ? message.validatorAddress : new Uint8Array()));
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.voteExtension !== undefined && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== undefined ? message.voteExtension : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestVerifyVoteExtension();
        message.hash = object.hash ?? new Uint8Array();
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
    }
};
function createBaseRequestFinalizeBlock() {
    return {
        txs: [],
        decidedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
    };
}
exports.RequestFinalizeBlock = {
    typeUrl: "/tendermint.abci.RequestFinalizeBlock",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs)writer.uint32(10).bytes(v);
        if (message.decidedLastCommit !== undefined) exports.CommitInfo.encode(message.decidedLastCommit, writer.uint32(18).fork()).ldelim();
        for (const v of message.misbehavior)exports.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.hash.length !== 0) writer.uint32(34).bytes(message.hash);
        if (message.height !== BigInt(0)) writer.uint32(40).int64(message.height);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        if (message.nextValidatorsHash.length !== 0) writer.uint32(58).bytes(message.nextValidatorsHash);
        if (message.proposerAddress.length !== 0) writer.uint32(66).bytes(message.proposerAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestFinalizeBlock();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txs.push(reader.bytes());
                    break;
                case 2:
                    message.decidedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.hash = reader.bytes();
                    break;
                case 5:
                    message.height = reader.int64();
                    break;
                case 6:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.nextValidatorsHash = reader.bytes();
                    break;
                case 8:
                    message.proposerAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseRequestFinalizeBlock();
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.decidedLastCommit)) obj.decidedLastCommit = exports.CommitInfo.fromJSON(object.decidedLastCommit);
        if (Array.isArray(object?.misbehavior)) obj.misbehavior = object.misbehavior.map((e)=>exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash)) obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress)) obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.txs) obj.txs = message.txs.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.txs = [];
        message.decidedLastCommit !== undefined && (obj.decidedLastCommit = message.decidedLastCommit ? exports.CommitInfo.toJSON(message.decidedLastCommit) : undefined);
        if (message.misbehavior) obj.misbehavior = message.misbehavior.map((e)=>e ? exports.Misbehavior.toJSON(e) : undefined);
        else obj.misbehavior = [];
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== undefined && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== undefined ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== undefined && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== undefined ? message.proposerAddress : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRequestFinalizeBlock();
        message.txs = object.txs?.map((e)=>e) || [];
        if (object.decidedLastCommit !== undefined && object.decidedLastCommit !== null) message.decidedLastCommit = exports.CommitInfo.fromPartial(object.decidedLastCommit);
        message.misbehavior = object.misbehavior?.map((e)=>exports.Misbehavior.fromPartial(e)) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
    }
};
function createBaseResponse() {
    return {
        exception: undefined,
        echo: undefined,
        flush: undefined,
        info: undefined,
        initChain: undefined,
        query: undefined,
        checkTx: undefined,
        commit: undefined,
        listSnapshots: undefined,
        offerSnapshot: undefined,
        loadSnapshotChunk: undefined,
        applySnapshotChunk: undefined,
        prepareProposal: undefined,
        processProposal: undefined,
        extendVote: undefined,
        verifyVoteExtension: undefined,
        finalizeBlock: undefined
    };
}
exports.Response = {
    typeUrl: "/tendermint.abci.Response",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.exception !== undefined) exports.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        if (message.echo !== undefined) exports.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        if (message.flush !== undefined) exports.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        if (message.info !== undefined) exports.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        if (message.initChain !== undefined) exports.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        if (message.query !== undefined) exports.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        if (message.checkTx !== undefined) exports.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        if (message.commit !== undefined) exports.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        if (message.listSnapshots !== undefined) exports.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        if (message.offerSnapshot !== undefined) exports.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        if (message.loadSnapshotChunk !== undefined) exports.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        if (message.applySnapshotChunk !== undefined) exports.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        if (message.prepareProposal !== undefined) exports.ResponsePrepareProposal.encode(message.prepareProposal, writer.uint32(138).fork()).ldelim();
        if (message.processProposal !== undefined) exports.ResponseProcessProposal.encode(message.processProposal, writer.uint32(146).fork()).ldelim();
        if (message.extendVote !== undefined) exports.ResponseExtendVote.encode(message.extendVote, writer.uint32(154).fork()).ldelim();
        if (message.verifyVoteExtension !== undefined) exports.ResponseVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(162).fork()).ldelim();
        if (message.finalizeBlock !== undefined) exports.ResponseFinalizeBlock.encode(message.finalizeBlock, writer.uint32(170).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.exception = exports.ResponseException.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.echo = exports.ResponseEcho.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.flush = exports.ResponseFlush.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.info = exports.ResponseInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.initChain = exports.ResponseInitChain.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.query = exports.ResponseQuery.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.checkTx = exports.ResponseCheckTx.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.commit = exports.ResponseCommit.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.listSnapshots = exports.ResponseListSnapshots.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.offerSnapshot = exports.ResponseOfferSnapshot.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.prepareProposal = exports.ResponsePrepareProposal.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.processProposal = exports.ResponseProcessProposal.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.extendVote = exports.ResponseExtendVote.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.verifyVoteExtension = exports.ResponseVerifyVoteExtension.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.finalizeBlock = exports.ResponseFinalizeBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponse();
        if ((0, helpers_1.isSet)(object.exception)) obj.exception = exports.ResponseException.fromJSON(object.exception);
        if ((0, helpers_1.isSet)(object.echo)) obj.echo = exports.ResponseEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush)) obj.flush = exports.ResponseFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info)) obj.info = exports.ResponseInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain)) obj.initChain = exports.ResponseInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query)) obj.query = exports.ResponseQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx)) obj.checkTx = exports.ResponseCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit)) obj.commit = exports.ResponseCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots)) obj.listSnapshots = exports.ResponseListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot)) obj.offerSnapshot = exports.ResponseOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk)) obj.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk)) obj.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal)) obj.prepareProposal = exports.ResponsePrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal)) obj.processProposal = exports.ResponseProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote)) obj.extendVote = exports.ResponseExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension)) obj.verifyVoteExtension = exports.ResponseVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock)) obj.finalizeBlock = exports.ResponseFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.exception !== undefined && (obj.exception = message.exception ? exports.ResponseException.toJSON(message.exception) : undefined);
        message.echo !== undefined && (obj.echo = message.echo ? exports.ResponseEcho.toJSON(message.echo) : undefined);
        message.flush !== undefined && (obj.flush = message.flush ? exports.ResponseFlush.toJSON(message.flush) : undefined);
        message.info !== undefined && (obj.info = message.info ? exports.ResponseInfo.toJSON(message.info) : undefined);
        message.initChain !== undefined && (obj.initChain = message.initChain ? exports.ResponseInitChain.toJSON(message.initChain) : undefined);
        message.query !== undefined && (obj.query = message.query ? exports.ResponseQuery.toJSON(message.query) : undefined);
        message.checkTx !== undefined && (obj.checkTx = message.checkTx ? exports.ResponseCheckTx.toJSON(message.checkTx) : undefined);
        message.commit !== undefined && (obj.commit = message.commit ? exports.ResponseCommit.toJSON(message.commit) : undefined);
        message.listSnapshots !== undefined && (obj.listSnapshots = message.listSnapshots ? exports.ResponseListSnapshots.toJSON(message.listSnapshots) : undefined);
        message.offerSnapshot !== undefined && (obj.offerSnapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : undefined);
        message.loadSnapshotChunk !== undefined && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : undefined);
        message.applySnapshotChunk !== undefined && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : undefined);
        message.prepareProposal !== undefined && (obj.prepareProposal = message.prepareProposal ? exports.ResponsePrepareProposal.toJSON(message.prepareProposal) : undefined);
        message.processProposal !== undefined && (obj.processProposal = message.processProposal ? exports.ResponseProcessProposal.toJSON(message.processProposal) : undefined);
        message.extendVote !== undefined && (obj.extendVote = message.extendVote ? exports.ResponseExtendVote.toJSON(message.extendVote) : undefined);
        message.verifyVoteExtension !== undefined && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports.ResponseVerifyVoteExtension.toJSON(message.verifyVoteExtension) : undefined);
        message.finalizeBlock !== undefined && (obj.finalizeBlock = message.finalizeBlock ? exports.ResponseFinalizeBlock.toJSON(message.finalizeBlock) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponse();
        if (object.exception !== undefined && object.exception !== null) message.exception = exports.ResponseException.fromPartial(object.exception);
        if (object.echo !== undefined && object.echo !== null) message.echo = exports.ResponseEcho.fromPartial(object.echo);
        if (object.flush !== undefined && object.flush !== null) message.flush = exports.ResponseFlush.fromPartial(object.flush);
        if (object.info !== undefined && object.info !== null) message.info = exports.ResponseInfo.fromPartial(object.info);
        if (object.initChain !== undefined && object.initChain !== null) message.initChain = exports.ResponseInitChain.fromPartial(object.initChain);
        if (object.query !== undefined && object.query !== null) message.query = exports.ResponseQuery.fromPartial(object.query);
        if (object.checkTx !== undefined && object.checkTx !== null) message.checkTx = exports.ResponseCheckTx.fromPartial(object.checkTx);
        if (object.commit !== undefined && object.commit !== null) message.commit = exports.ResponseCommit.fromPartial(object.commit);
        if (object.listSnapshots !== undefined && object.listSnapshots !== null) message.listSnapshots = exports.ResponseListSnapshots.fromPartial(object.listSnapshots);
        if (object.offerSnapshot !== undefined && object.offerSnapshot !== null) message.offerSnapshot = exports.ResponseOfferSnapshot.fromPartial(object.offerSnapshot);
        if (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null) message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        if (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null) message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        if (object.prepareProposal !== undefined && object.prepareProposal !== null) message.prepareProposal = exports.ResponsePrepareProposal.fromPartial(object.prepareProposal);
        if (object.processProposal !== undefined && object.processProposal !== null) message.processProposal = exports.ResponseProcessProposal.fromPartial(object.processProposal);
        if (object.extendVote !== undefined && object.extendVote !== null) message.extendVote = exports.ResponseExtendVote.fromPartial(object.extendVote);
        if (object.verifyVoteExtension !== undefined && object.verifyVoteExtension !== null) message.verifyVoteExtension = exports.ResponseVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        if (object.finalizeBlock !== undefined && object.finalizeBlock !== null) message.finalizeBlock = exports.ResponseFinalizeBlock.fromPartial(object.finalizeBlock);
        return message;
    }
};
function createBaseResponseException() {
    return {
        error: ""
    };
}
exports.ResponseException = {
    typeUrl: "/tendermint.abci.ResponseException",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.error !== "") writer.uint32(10).string(message.error);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseException();
        if ((0, helpers_1.isSet)(object.error)) obj.error = String(object.error);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.error !== undefined && (obj.error = message.error);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseException();
        message.error = object.error ?? "";
        return message;
    }
};
function createBaseResponseEcho() {
    return {
        message: ""
    };
}
exports.ResponseEcho = {
    typeUrl: "/tendermint.abci.ResponseEcho",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") writer.uint32(10).string(message.message);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseEcho();
        if ((0, helpers_1.isSet)(object.message)) obj.message = String(object.message);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseEcho();
        message.message = object.message ?? "";
        return message;
    }
};
function createBaseResponseFlush() {
    return {};
}
exports.ResponseFlush = {
    typeUrl: "/tendermint.abci.ResponseFlush",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseResponseFlush();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseResponseFlush();
        return message;
    }
};
function createBaseResponseInfo() {
    return {
        data: "",
        version: "",
        appVersion: BigInt(0),
        lastBlockHeight: BigInt(0),
        lastBlockAppHash: new Uint8Array()
    };
}
exports.ResponseInfo = {
    typeUrl: "/tendermint.abci.ResponseInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.data !== "") writer.uint32(10).string(message.data);
        if (message.version !== "") writer.uint32(18).string(message.version);
        if (message.appVersion !== BigInt(0)) writer.uint32(24).uint64(message.appVersion);
        if (message.lastBlockHeight !== BigInt(0)) writer.uint32(32).int64(message.lastBlockHeight);
        if (message.lastBlockAppHash.length !== 0) writer.uint32(42).bytes(message.lastBlockAppHash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.data = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                case 3:
                    message.appVersion = reader.uint64();
                    break;
                case 4:
                    message.lastBlockHeight = reader.int64();
                    break;
                case 5:
                    message.lastBlockAppHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseInfo();
        if ((0, helpers_1.isSet)(object.data)) obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.version)) obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.appVersion)) obj.appVersion = BigInt(object.appVersion.toString());
        if ((0, helpers_1.isSet)(object.lastBlockHeight)) obj.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        if ((0, helpers_1.isSet)(object.lastBlockAppHash)) obj.lastBlockAppHash = (0, helpers_1.bytesFromBase64)(object.lastBlockAppHash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.data !== undefined && (obj.data = message.data);
        message.version !== undefined && (obj.version = message.version);
        message.appVersion !== undefined && (obj.appVersion = (message.appVersion || BigInt(0)).toString());
        message.lastBlockHeight !== undefined && (obj.lastBlockHeight = (message.lastBlockHeight || BigInt(0)).toString());
        message.lastBlockAppHash !== undefined && (obj.lastBlockAppHash = (0, helpers_1.base64FromBytes)(message.lastBlockAppHash !== undefined ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseInfo();
        message.data = object.data ?? "";
        message.version = object.version ?? "";
        if (object.appVersion !== undefined && object.appVersion !== null) message.appVersion = BigInt(object.appVersion.toString());
        if (object.lastBlockHeight !== undefined && object.lastBlockHeight !== null) message.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array();
        return message;
    }
};
function createBaseResponseInitChain() {
    return {
        consensusParams: undefined,
        validators: [],
        appHash: new Uint8Array()
    };
}
exports.ResponseInitChain = {
    typeUrl: "/tendermint.abci.ResponseInitChain",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusParams !== undefined) params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        for (const v of message.validators)exports.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.appHash.length !== 0) writer.uint32(26).bytes(message.appHash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.appHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseInitChain();
        if ((0, helpers_1.isSet)(object.consensusParams)) obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object?.validators)) obj.validators = object.validators.map((e)=>exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appHash)) obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.consensusParams !== undefined && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : undefined);
        if (message.validators) obj.validators = message.validators.map((e)=>e ? exports.ValidatorUpdate.toJSON(e) : undefined);
        else obj.validators = [];
        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseInitChain();
        if (object.consensusParams !== undefined && object.consensusParams !== null) message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        message.validators = object.validators?.map((e)=>exports.ValidatorUpdate.fromPartial(e)) || [];
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
    }
};
function createBaseResponseQuery() {
    return {
        code: 0,
        log: "",
        info: "",
        index: BigInt(0),
        key: new Uint8Array(),
        value: new Uint8Array(),
        proofOps: undefined,
        height: BigInt(0),
        codespace: ""
    };
}
exports.ResponseQuery = {
    typeUrl: "/tendermint.abci.ResponseQuery",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) writer.uint32(8).uint32(message.code);
        if (message.log !== "") writer.uint32(26).string(message.log);
        if (message.info !== "") writer.uint32(34).string(message.info);
        if (message.index !== BigInt(0)) writer.uint32(40).int64(message.index);
        if (message.key.length !== 0) writer.uint32(50).bytes(message.key);
        if (message.value.length !== 0) writer.uint32(58).bytes(message.value);
        if (message.proofOps !== undefined) proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        if (message.height !== BigInt(0)) writer.uint32(72).int64(message.height);
        if (message.codespace !== "") writer.uint32(82).string(message.codespace);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.code = reader.uint32();
                    break;
                case 3:
                    message.log = reader.string();
                    break;
                case 4:
                    message.info = reader.string();
                    break;
                case 5:
                    message.index = reader.int64();
                    break;
                case 6:
                    message.key = reader.bytes();
                    break;
                case 7:
                    message.value = reader.bytes();
                    break;
                case 8:
                    message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.height = reader.int64();
                    break;
                case 10:
                    message.codespace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseQuery();
        if ((0, helpers_1.isSet)(object.code)) obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.log)) obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info)) obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.index)) obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.key)) obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value)) obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.proofOps)) obj.proofOps = proof_1.ProofOps.fromJSON(object.proofOps);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.codespace)) obj.codespace = String(object.codespace);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.code !== undefined && (obj.code = Math.round(message.code));
        message.log !== undefined && (obj.log = message.log);
        message.info !== undefined && (obj.info = message.info);
        message.index !== undefined && (obj.index = (message.index || BigInt(0)).toString());
        message.key !== undefined && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));
        message.value !== undefined && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));
        message.proofOps !== undefined && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : undefined);
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.codespace !== undefined && (obj.codespace = message.codespace);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseQuery();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.index !== undefined && object.index !== null) message.index = BigInt(object.index.toString());
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.proofOps !== undefined && object.proofOps !== null) message.proofOps = proof_1.ProofOps.fromPartial(object.proofOps);
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.codespace = object.codespace ?? "";
        return message;
    }
};
function createBaseResponseCheckTx() {
    return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
    };
}
exports.ResponseCheckTx = {
    typeUrl: "/tendermint.abci.ResponseCheckTx",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) writer.uint32(8).uint32(message.code);
        if (message.data.length !== 0) writer.uint32(18).bytes(message.data);
        if (message.log !== "") writer.uint32(26).string(message.log);
        if (message.info !== "") writer.uint32(34).string(message.info);
        if (message.gasWanted !== BigInt(0)) writer.uint32(40).int64(message.gasWanted);
        if (message.gasUsed !== BigInt(0)) writer.uint32(48).int64(message.gasUsed);
        for (const v of message.events)exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
        if (message.codespace !== "") writer.uint32(66).string(message.codespace);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.log = reader.string();
                    break;
                case 4:
                    message.info = reader.string();
                    break;
                case 5:
                    message.gasWanted = reader.int64();
                    break;
                case 6:
                    message.gasUsed = reader.int64();
                    break;
                case 7:
                    message.events.push(exports.Event.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.codespace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseCheckTx();
        if ((0, helpers_1.isSet)(object.code)) obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log)) obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info)) obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted)) obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used)) obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>exports.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace)) obj.codespace = String(object.codespace);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.code !== undefined && (obj.code = Math.round(message.code));
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.log !== undefined && (obj.log = message.log);
        message.info !== undefined && (obj.info = message.info);
        message.gasWanted !== undefined && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== undefined && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) obj.events = message.events.map((e)=>e ? exports.Event.toJSON(e) : undefined);
        else obj.events = [];
        message.codespace !== undefined && (obj.codespace = message.codespace);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseCheckTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== undefined && object.gasWanted !== null) message.gasWanted = BigInt(object.gasWanted.toString());
        if (object.gasUsed !== undefined && object.gasUsed !== null) message.gasUsed = BigInt(object.gasUsed.toString());
        message.events = object.events?.map((e)=>exports.Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
    }
};
function createBaseResponseCommit() {
    return {
        retainHeight: BigInt(0)
    };
}
exports.ResponseCommit = {
    typeUrl: "/tendermint.abci.ResponseCommit",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.retainHeight !== BigInt(0)) writer.uint32(24).int64(message.retainHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 3:
                    message.retainHeight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseCommit();
        if ((0, helpers_1.isSet)(object.retainHeight)) obj.retainHeight = BigInt(object.retainHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.retainHeight !== undefined && (obj.retainHeight = (message.retainHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseCommit();
        if (object.retainHeight !== undefined && object.retainHeight !== null) message.retainHeight = BigInt(object.retainHeight.toString());
        return message;
    }
};
function createBaseResponseListSnapshots() {
    return {
        snapshots: []
    };
}
exports.ResponseListSnapshots = {
    typeUrl: "/tendermint.abci.ResponseListSnapshots",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.snapshots)exports.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.snapshots.push(exports.Snapshot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseListSnapshots();
        if (Array.isArray(object?.snapshots)) obj.snapshots = object.snapshots.map((e)=>exports.Snapshot.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.snapshots) obj.snapshots = message.snapshots.map((e)=>e ? exports.Snapshot.toJSON(e) : undefined);
        else obj.snapshots = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseListSnapshots();
        message.snapshots = object.snapshots?.map((e)=>exports.Snapshot.fromPartial(e)) || [];
        return message;
    }
};
function createBaseResponseOfferSnapshot() {
    return {
        result: 0
    };
}
exports.ResponseOfferSnapshot = {
    typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseOfferSnapshot();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseOfferSnapshot_ResultFromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseOfferSnapshot();
        message.result = object.result ?? 0;
        return message;
    }
};
function createBaseResponseLoadSnapshotChunk() {
    return {
        chunk: new Uint8Array()
    };
}
exports.ResponseLoadSnapshotChunk = {
    typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.chunk.length !== 0) writer.uint32(10).bytes(message.chunk);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.chunk = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.chunk)) obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.chunk !== undefined && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== undefined ? message.chunk : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseLoadSnapshotChunk();
        message.chunk = object.chunk ?? new Uint8Array();
        return message;
    }
};
function createBaseResponseApplySnapshotChunk() {
    return {
        result: 0,
        refetchChunks: [],
        rejectSenders: []
    };
}
exports.ResponseApplySnapshotChunk = {
    typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) writer.uint32(8).int32(message.result);
        writer.uint32(18).fork();
        for (const v of message.refetchChunks)writer.uint32(v);
        writer.ldelim();
        for (const v of message.rejectSenders)writer.uint32(26).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while(reader.pos < end2)message.refetchChunks.push(reader.uint32());
                    } else message.refetchChunks.push(reader.uint32());
                    break;
                case 3:
                    message.rejectSenders.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.result)) obj.result = responseApplySnapshotChunk_ResultFromJSON(object.result);
        if (Array.isArray(object?.refetchChunks)) obj.refetchChunks = object.refetchChunks.map((e)=>Number(e));
        if (Array.isArray(object?.rejectSenders)) obj.rejectSenders = object.rejectSenders.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
        if (message.refetchChunks) obj.refetchChunks = message.refetchChunks.map((e)=>Math.round(e));
        else obj.refetchChunks = [];
        if (message.rejectSenders) obj.rejectSenders = message.rejectSenders.map((e)=>e);
        else obj.rejectSenders = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseApplySnapshotChunk();
        message.result = object.result ?? 0;
        message.refetchChunks = object.refetchChunks?.map((e)=>e) || [];
        message.rejectSenders = object.rejectSenders?.map((e)=>e) || [];
        return message;
    }
};
function createBaseResponsePrepareProposal() {
    return {
        txs: []
    };
}
exports.ResponsePrepareProposal = {
    typeUrl: "/tendermint.abci.ResponsePrepareProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponsePrepareProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponsePrepareProposal();
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>(0, helpers_1.bytesFromBase64)(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.txs) obj.txs = message.txs.map((e)=>(0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));
        else obj.txs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponsePrepareProposal();
        message.txs = object.txs?.map((e)=>e) || [];
        return message;
    }
};
function createBaseResponseProcessProposal() {
    return {
        status: 0
    };
}
exports.ResponseProcessProposal = {
    typeUrl: "/tendermint.abci.ResponseProcessProposal",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) writer.uint32(8).int32(message.status);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseProcessProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseProcessProposal();
        if ((0, helpers_1.isSet)(object.status)) obj.status = responseProcessProposal_ProposalStatusFromJSON(object.status);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.status !== undefined && (obj.status = responseProcessProposal_ProposalStatusToJSON(message.status));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseProcessProposal();
        message.status = object.status ?? 0;
        return message;
    }
};
function createBaseResponseExtendVote() {
    return {
        voteExtension: new Uint8Array()
    };
}
exports.ResponseExtendVote = {
    typeUrl: "/tendermint.abci.ResponseExtendVote",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtension.length !== 0) writer.uint32(10).bytes(message.voteExtension);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseExtendVote();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.voteExtension = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseExtendVote();
        if ((0, helpers_1.isSet)(object.voteExtension)) obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.voteExtension !== undefined && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== undefined ? message.voteExtension : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseExtendVote();
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
    }
};
function createBaseResponseVerifyVoteExtension() {
    return {
        status: 0
    };
}
exports.ResponseVerifyVoteExtension = {
    typeUrl: "/tendermint.abci.ResponseVerifyVoteExtension",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) writer.uint32(8).int32(message.status);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseVerifyVoteExtension();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseVerifyVoteExtension();
        if ((0, helpers_1.isSet)(object.status)) obj.status = responseVerifyVoteExtension_VerifyStatusFromJSON(object.status);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.status !== undefined && (obj.status = responseVerifyVoteExtension_VerifyStatusToJSON(message.status));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseVerifyVoteExtension();
        message.status = object.status ?? 0;
        return message;
    }
};
function createBaseResponseFinalizeBlock() {
    return {
        events: [],
        txResults: [],
        validatorUpdates: [],
        consensusParamUpdates: undefined,
        appHash: new Uint8Array()
    };
}
exports.ResponseFinalizeBlock = {
    typeUrl: "/tendermint.abci.ResponseFinalizeBlock",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events)exports.Event.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.txResults)exports.ExecTxResult.encode(v, writer.uint32(18).fork()).ldelim();
        for (const v of message.validatorUpdates)exports.ValidatorUpdate.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.consensusParamUpdates !== undefined) params_1.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(34).fork()).ldelim();
        if (message.appHash.length !== 0) writer.uint32(42).bytes(message.appHash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseFinalizeBlock();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.events.push(exports.Event.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.txResults.push(exports.ExecTxResult.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.validatorUpdates.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.consensusParamUpdates = params_1.ConsensusParams.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.appHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResponseFinalizeBlock();
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>exports.Event.fromJSON(e));
        if (Array.isArray(object?.txResults)) obj.txResults = object.txResults.map((e)=>exports.ExecTxResult.fromJSON(e));
        if (Array.isArray(object?.validatorUpdates)) obj.validatorUpdates = object.validatorUpdates.map((e)=>exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.consensusParamUpdates)) obj.consensusParamUpdates = params_1.ConsensusParams.fromJSON(object.consensusParamUpdates);
        if ((0, helpers_1.isSet)(object.appHash)) obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.events) obj.events = message.events.map((e)=>e ? exports.Event.toJSON(e) : undefined);
        else obj.events = [];
        if (message.txResults) obj.txResults = message.txResults.map((e)=>e ? exports.ExecTxResult.toJSON(e) : undefined);
        else obj.txResults = [];
        if (message.validatorUpdates) obj.validatorUpdates = message.validatorUpdates.map((e)=>e ? exports.ValidatorUpdate.toJSON(e) : undefined);
        else obj.validatorUpdates = [];
        message.consensusParamUpdates !== undefined && (obj.consensusParamUpdates = message.consensusParamUpdates ? params_1.ConsensusParams.toJSON(message.consensusParamUpdates) : undefined);
        message.appHash !== undefined && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== undefined ? message.appHash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResponseFinalizeBlock();
        message.events = object.events?.map((e)=>exports.Event.fromPartial(e)) || [];
        message.txResults = object.txResults?.map((e)=>exports.ExecTxResult.fromPartial(e)) || [];
        message.validatorUpdates = object.validatorUpdates?.map((e)=>exports.ValidatorUpdate.fromPartial(e)) || [];
        if (object.consensusParamUpdates !== undefined && object.consensusParamUpdates !== null) message.consensusParamUpdates = params_1.ConsensusParams.fromPartial(object.consensusParamUpdates);
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
    }
};
function createBaseCommitInfo() {
    return {
        round: 0,
        votes: []
    };
}
exports.CommitInfo = {
    typeUrl: "/tendermint.abci.CommitInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) writer.uint32(8).int32(message.round);
        for (const v of message.votes)exports.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommitInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.round = reader.int32();
                    break;
                case 2:
                    message.votes.push(exports.VoteInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseCommitInfo();
        if ((0, helpers_1.isSet)(object.round)) obj.round = Number(object.round);
        if (Array.isArray(object?.votes)) obj.votes = object.votes.map((e)=>exports.VoteInfo.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.round !== undefined && (obj.round = Math.round(message.round));
        if (message.votes) obj.votes = message.votes.map((e)=>e ? exports.VoteInfo.toJSON(e) : undefined);
        else obj.votes = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCommitInfo();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e)=>exports.VoteInfo.fromPartial(e)) || [];
        return message;
    }
};
function createBaseExtendedCommitInfo() {
    return {
        round: 0,
        votes: []
    };
}
exports.ExtendedCommitInfo = {
    typeUrl: "/tendermint.abci.ExtendedCommitInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) writer.uint32(8).int32(message.round);
        for (const v of message.votes)exports.ExtendedVoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.round = reader.int32();
                    break;
                case 2:
                    message.votes.push(exports.ExtendedVoteInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseExtendedCommitInfo();
        if ((0, helpers_1.isSet)(object.round)) obj.round = Number(object.round);
        if (Array.isArray(object?.votes)) obj.votes = object.votes.map((e)=>exports.ExtendedVoteInfo.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.round !== undefined && (obj.round = Math.round(message.round));
        if (message.votes) obj.votes = message.votes.map((e)=>e ? exports.ExtendedVoteInfo.toJSON(e) : undefined);
        else obj.votes = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseExtendedCommitInfo();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e)=>exports.ExtendedVoteInfo.fromPartial(e)) || [];
        return message;
    }
};
function createBaseEvent() {
    return {
        type: "",
        attributes: []
    };
}
exports.Event = {
    typeUrl: "/tendermint.abci.Event",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") writer.uint32(10).string(message.type);
        for (const v of message.attributes)exports.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.attributes.push(exports.EventAttribute.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseEvent();
        if ((0, helpers_1.isSet)(object.type)) obj.type = String(object.type);
        if (Array.isArray(object?.attributes)) obj.attributes = object.attributes.map((e)=>exports.EventAttribute.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        if (message.attributes) obj.attributes = message.attributes.map((e)=>e ? exports.EventAttribute.toJSON(e) : undefined);
        else obj.attributes = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEvent();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e)=>exports.EventAttribute.fromPartial(e)) || [];
        return message;
    }
};
function createBaseEventAttribute() {
    return {
        key: "",
        value: "",
        index: false
    };
}
exports.EventAttribute = {
    typeUrl: "/tendermint.abci.EventAttribute",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== "") writer.uint32(18).string(message.value);
        if (message.index === true) writer.uint32(24).bool(message.index);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                case 3:
                    message.index = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseEventAttribute();
        if ((0, helpers_1.isSet)(object.key)) obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value)) obj.value = String(object.value);
        if ((0, helpers_1.isSet)(object.index)) obj.index = Boolean(object.index);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        message.index !== undefined && (obj.index = message.index);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEventAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.index = object.index ?? false;
        return message;
    }
};
function createBaseExecTxResult() {
    return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
    };
}
exports.ExecTxResult = {
    typeUrl: "/tendermint.abci.ExecTxResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) writer.uint32(8).uint32(message.code);
        if (message.data.length !== 0) writer.uint32(18).bytes(message.data);
        if (message.log !== "") writer.uint32(26).string(message.log);
        if (message.info !== "") writer.uint32(34).string(message.info);
        if (message.gasWanted !== BigInt(0)) writer.uint32(40).int64(message.gasWanted);
        if (message.gasUsed !== BigInt(0)) writer.uint32(48).int64(message.gasUsed);
        for (const v of message.events)exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
        if (message.codespace !== "") writer.uint32(66).string(message.codespace);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExecTxResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.log = reader.string();
                    break;
                case 4:
                    message.info = reader.string();
                    break;
                case 5:
                    message.gasWanted = reader.int64();
                    break;
                case 6:
                    message.gasUsed = reader.int64();
                    break;
                case 7:
                    message.events.push(exports.Event.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.codespace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseExecTxResult();
        if ((0, helpers_1.isSet)(object.code)) obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log)) obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info)) obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted)) obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used)) obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>exports.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace)) obj.codespace = String(object.codespace);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.code !== undefined && (obj.code = Math.round(message.code));
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.log !== undefined && (obj.log = message.log);
        message.info !== undefined && (obj.info = message.info);
        message.gasWanted !== undefined && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== undefined && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) obj.events = message.events.map((e)=>e ? exports.Event.toJSON(e) : undefined);
        else obj.events = [];
        message.codespace !== undefined && (obj.codespace = message.codespace);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseExecTxResult();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== undefined && object.gasWanted !== null) message.gasWanted = BigInt(object.gasWanted.toString());
        if (object.gasUsed !== undefined && object.gasUsed !== null) message.gasUsed = BigInt(object.gasUsed.toString());
        message.events = object.events?.map((e)=>exports.Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
    }
};
function createBaseTxResult() {
    return {
        height: BigInt(0),
        index: 0,
        tx: new Uint8Array(),
        result: exports.ExecTxResult.fromPartial({})
    };
}
exports.TxResult = {
    typeUrl: "/tendermint.abci.TxResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).int64(message.height);
        if (message.index !== 0) writer.uint32(16).uint32(message.index);
        if (message.tx.length !== 0) writer.uint32(26).bytes(message.tx);
        if (message.result !== undefined) exports.ExecTxResult.encode(message.result, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.int64();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 3:
                    message.tx = reader.bytes();
                    break;
                case 4:
                    message.result = exports.ExecTxResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxResult();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.index)) obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.result)) obj.result = exports.ExecTxResult.fromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.tx !== undefined && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== undefined ? message.tx : new Uint8Array()));
        message.result !== undefined && (obj.result = message.result ? exports.ExecTxResult.toJSON(message.result) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxResult();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.index = object.index ?? 0;
        message.tx = object.tx ?? new Uint8Array();
        if (object.result !== undefined && object.result !== null) message.result = exports.ExecTxResult.fromPartial(object.result);
        return message;
    }
};
function createBaseValidator() {
    return {
        address: new Uint8Array(),
        power: BigInt(0)
    };
}
exports.Validator = {
    typeUrl: "/tendermint.abci.Validator",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) writer.uint32(10).bytes(message.address);
        if (message.power !== BigInt(0)) writer.uint32(24).int64(message.power);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.bytes();
                    break;
                case 3:
                    message.power = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address)) obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.power)) obj.power = BigInt(object.power.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== undefined ? message.address : new Uint8Array()));
        message.power !== undefined && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.power !== undefined && object.power !== null) message.power = BigInt(object.power.toString());
        return message;
    }
};
function createBaseValidatorUpdate() {
    return {
        pubKey: keys_1.PublicKey.fromPartial({}),
        power: BigInt(0)
    };
}
exports.ValidatorUpdate = {
    typeUrl: "/tendermint.abci.ValidatorUpdate",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== undefined) keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        if (message.power !== BigInt(0)) writer.uint32(16).int64(message.power);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.power = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorUpdate();
        if ((0, helpers_1.isSet)(object.pubKey)) obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.power)) obj.power = BigInt(object.power.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);
        message.power !== undefined && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorUpdate();
        if (object.pubKey !== undefined && object.pubKey !== null) message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        if (object.power !== undefined && object.power !== null) message.power = BigInt(object.power.toString());
        return message;
    }
};
function createBaseVoteInfo() {
    return {
        validator: exports.Validator.fromPartial({}),
        blockIdFlag: 0
    };
}
exports.VoteInfo = {
    typeUrl: "/tendermint.abci.VoteInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== undefined) exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        if (message.blockIdFlag !== 0) writer.uint32(24).int32(message.blockIdFlag);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validator = exports.Validator.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.blockIdFlag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVoteInfo();
        if ((0, helpers_1.isSet)(object.validator)) obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.blockIdFlag)) obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);
        message.blockIdFlag !== undefined && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVoteInfo();
        if (object.validator !== undefined && object.validator !== null) message.validator = exports.Validator.fromPartial(object.validator);
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
    }
};
function createBaseExtendedVoteInfo() {
    return {
        validator: exports.Validator.fromPartial({}),
        voteExtension: new Uint8Array(),
        extensionSignature: new Uint8Array(),
        blockIdFlag: 0
    };
}
exports.ExtendedVoteInfo = {
    typeUrl: "/tendermint.abci.ExtendedVoteInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== undefined) exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        if (message.voteExtension.length !== 0) writer.uint32(26).bytes(message.voteExtension);
        if (message.extensionSignature.length !== 0) writer.uint32(34).bytes(message.extensionSignature);
        if (message.blockIdFlag !== 0) writer.uint32(40).int32(message.blockIdFlag);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendedVoteInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validator = exports.Validator.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.voteExtension = reader.bytes();
                    break;
                case 4:
                    message.extensionSignature = reader.bytes();
                    break;
                case 5:
                    message.blockIdFlag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseExtendedVoteInfo();
        if ((0, helpers_1.isSet)(object.validator)) obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.voteExtension)) obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        if ((0, helpers_1.isSet)(object.extensionSignature)) obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        if ((0, helpers_1.isSet)(object.blockIdFlag)) obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);
        message.voteExtension !== undefined && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== undefined ? message.voteExtension : new Uint8Array()));
        message.extensionSignature !== undefined && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== undefined ? message.extensionSignature : new Uint8Array()));
        message.blockIdFlag !== undefined && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseExtendedVoteInfo();
        if (object.validator !== undefined && object.validator !== null) message.validator = exports.Validator.fromPartial(object.validator);
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
    }
};
function createBaseMisbehavior() {
    return {
        type: 0,
        validator: exports.Validator.fromPartial({}),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        totalVotingPower: BigInt(0)
    };
}
exports.Misbehavior = {
    typeUrl: "/tendermint.abci.Misbehavior",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) writer.uint32(8).int32(message.type);
        if (message.validator !== undefined) exports.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        if (message.height !== BigInt(0)) writer.uint32(24).int64(message.height);
        if (message.time !== undefined) timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        if (message.totalVotingPower !== BigInt(0)) writer.uint32(40).int64(message.totalVotingPower);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMisbehavior();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.validator = exports.Validator.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = reader.int64();
                    break;
                case 4:
                    message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.totalVotingPower = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMisbehavior();
        if ((0, helpers_1.isSet)(object.type)) obj.type = misbehaviorTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.validator)) obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time)) obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.totalVotingPower)) obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = misbehaviorTypeToJSON(message.type));
        message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== undefined && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMisbehavior();
        message.type = object.type ?? 0;
        if (object.validator !== undefined && object.validator !== null) message.validator = exports.Validator.fromPartial(object.validator);
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.time !== undefined && object.time !== null) message.time = timestamp_1.Timestamp.fromPartial(object.time);
        if (object.totalVotingPower !== undefined && object.totalVotingPower !== null) message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return message;
    }
};
function createBaseSnapshot() {
    return {
        height: BigInt(0),
        format: 0,
        chunks: 0,
        hash: new Uint8Array(),
        metadata: new Uint8Array()
    };
}
exports.Snapshot = {
    typeUrl: "/tendermint.abci.Snapshot",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).uint64(message.height);
        if (message.format !== 0) writer.uint32(16).uint32(message.format);
        if (message.chunks !== 0) writer.uint32(24).uint32(message.chunks);
        if (message.hash.length !== 0) writer.uint32(34).bytes(message.hash);
        if (message.metadata.length !== 0) writer.uint32(42).bytes(message.metadata);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.uint64();
                    break;
                case 2:
                    message.format = reader.uint32();
                    break;
                case 3:
                    message.chunks = reader.uint32();
                    break;
                case 4:
                    message.hash = reader.bytes();
                    break;
                case 5:
                    message.metadata = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSnapshot();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format)) obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunks)) obj.chunks = Number(object.chunks);
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.metadata)) obj.metadata = (0, helpers_1.bytesFromBase64)(object.metadata);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== undefined && (obj.format = Math.round(message.format));
        message.chunks !== undefined && (obj.chunks = Math.round(message.chunks));
        message.hash !== undefined && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.metadata !== undefined && (obj.metadata = (0, helpers_1.base64FromBytes)(message.metadata !== undefined ? message.metadata : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSnapshot();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.format = object.format ?? 0;
        message.chunks = object.chunks ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        message.metadata = object.metadata ?? new Uint8Array();
        return message;
    }
};

},{"46314a12c3292c36":"6J6bq","f0d323fdef968b6e":"k4OVm","261e881c6aa55142":"2ydwn","fc97a8a8eda4d345":"gKtAr","3d45ec18aba95bc0":"5jJLR","f4f6d86527d72e00":"bi36x","6c1a81a3d284ff16":"eYjRL"}],"k4OVm":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ABCIParams = exports.HashedParams = exports.VersionParams = exports.ValidatorParams = exports.EvidenceParams = exports.BlockParams = exports.ConsensusParams = exports.protobufPackage = void 0;
/* eslint-disable */ const duration_1 = require("313430d25772ceed");
const binary_1 = require("209b2e59671f9eae");
const helpers_1 = require("fc9d9d72a50e0375");
exports.protobufPackage = "tendermint.types";
function createBaseConsensusParams() {
    return {
        block: undefined,
        evidence: undefined,
        validator: undefined,
        version: undefined,
        abci: undefined
    };
}
exports.ConsensusParams = {
    typeUrl: "/tendermint.types.ConsensusParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== undefined) exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        if (message.evidence !== undefined) exports.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        if (message.validator !== undefined) exports.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        if (message.version !== undefined) exports.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        if (message.abci !== undefined) exports.ABCIParams.encode(message.abci, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.block = exports.BlockParams.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.evidence = exports.EvidenceParams.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.validator = exports.ValidatorParams.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.version = exports.VersionParams.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.abci = exports.ABCIParams.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseConsensusParams();
        if ((0, helpers_1.isSet)(object.block)) obj.block = exports.BlockParams.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.evidence)) obj.evidence = exports.EvidenceParams.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.validator)) obj.validator = exports.ValidatorParams.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.version)) obj.version = exports.VersionParams.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.abci)) obj.abci = exports.ABCIParams.fromJSON(object.abci);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.block !== undefined && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : undefined);
        message.evidence !== undefined && (obj.evidence = message.evidence ? exports.EvidenceParams.toJSON(message.evidence) : undefined);
        message.validator !== undefined && (obj.validator = message.validator ? exports.ValidatorParams.toJSON(message.validator) : undefined);
        message.version !== undefined && (obj.version = message.version ? exports.VersionParams.toJSON(message.version) : undefined);
        message.abci !== undefined && (obj.abci = message.abci ? exports.ABCIParams.toJSON(message.abci) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseConsensusParams();
        if (object.block !== undefined && object.block !== null) message.block = exports.BlockParams.fromPartial(object.block);
        if (object.evidence !== undefined && object.evidence !== null) message.evidence = exports.EvidenceParams.fromPartial(object.evidence);
        if (object.validator !== undefined && object.validator !== null) message.validator = exports.ValidatorParams.fromPartial(object.validator);
        if (object.version !== undefined && object.version !== null) message.version = exports.VersionParams.fromPartial(object.version);
        if (object.abci !== undefined && object.abci !== null) message.abci = exports.ABCIParams.fromPartial(object.abci);
        return message;
    }
};
function createBaseBlockParams() {
    return {
        maxBytes: BigInt(0),
        maxGas: BigInt(0)
    };
}
exports.BlockParams = {
    typeUrl: "/tendermint.types.BlockParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxBytes !== BigInt(0)) writer.uint32(8).int64(message.maxBytes);
        if (message.maxGas !== BigInt(0)) writer.uint32(16).int64(message.maxGas);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.maxBytes = reader.int64();
                    break;
                case 2:
                    message.maxGas = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBlockParams();
        if ((0, helpers_1.isSet)(object.maxBytes)) obj.maxBytes = BigInt(object.maxBytes.toString());
        if ((0, helpers_1.isSet)(object.maxGas)) obj.maxGas = BigInt(object.maxGas.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.maxBytes !== undefined && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        message.maxGas !== undefined && (obj.maxGas = (message.maxGas || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBlockParams();
        if (object.maxBytes !== undefined && object.maxBytes !== null) message.maxBytes = BigInt(object.maxBytes.toString());
        if (object.maxGas !== undefined && object.maxGas !== null) message.maxGas = BigInt(object.maxGas.toString());
        return message;
    }
};
function createBaseEvidenceParams() {
    return {
        maxAgeNumBlocks: BigInt(0),
        maxAgeDuration: duration_1.Duration.fromPartial({}),
        maxBytes: BigInt(0)
    };
}
exports.EvidenceParams = {
    typeUrl: "/tendermint.types.EvidenceParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxAgeNumBlocks !== BigInt(0)) writer.uint32(8).int64(message.maxAgeNumBlocks);
        if (message.maxAgeDuration !== undefined) duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        if (message.maxBytes !== BigInt(0)) writer.uint32(24).int64(message.maxBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.maxAgeNumBlocks = reader.int64();
                    break;
                case 2:
                    message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.maxBytes = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseEvidenceParams();
        if ((0, helpers_1.isSet)(object.maxAgeNumBlocks)) obj.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        if ((0, helpers_1.isSet)(object.maxAgeDuration)) obj.maxAgeDuration = duration_1.Duration.fromJSON(object.maxAgeDuration);
        if ((0, helpers_1.isSet)(object.maxBytes)) obj.maxBytes = BigInt(object.maxBytes.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.maxAgeNumBlocks !== undefined && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || BigInt(0)).toString());
        message.maxAgeDuration !== undefined && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : undefined);
        message.maxBytes !== undefined && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEvidenceParams();
        if (object.maxAgeNumBlocks !== undefined && object.maxAgeNumBlocks !== null) message.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        if (object.maxAgeDuration !== undefined && object.maxAgeDuration !== null) message.maxAgeDuration = duration_1.Duration.fromPartial(object.maxAgeDuration);
        if (object.maxBytes !== undefined && object.maxBytes !== null) message.maxBytes = BigInt(object.maxBytes.toString());
        return message;
    }
};
function createBaseValidatorParams() {
    return {
        pubKeyTypes: []
    };
}
exports.ValidatorParams = {
    typeUrl: "/tendermint.types.ValidatorParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pubKeyTypes)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pubKeyTypes.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseValidatorParams();
        if (Array.isArray(object?.pubKeyTypes)) obj.pubKeyTypes = object.pubKeyTypes.map((e)=>String(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.pubKeyTypes) obj.pubKeyTypes = message.pubKeyTypes.map((e)=>e);
        else obj.pubKeyTypes = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseValidatorParams();
        message.pubKeyTypes = object.pubKeyTypes?.map((e)=>e) || [];
        return message;
    }
};
function createBaseVersionParams() {
    return {
        app: BigInt(0)
    };
}
exports.VersionParams = {
    typeUrl: "/tendermint.types.VersionParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.app !== BigInt(0)) writer.uint32(8).uint64(message.app);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVersionParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.app = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseVersionParams();
        if ((0, helpers_1.isSet)(object.app)) obj.app = BigInt(object.app.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.app !== undefined && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseVersionParams();
        if (object.app !== undefined && object.app !== null) message.app = BigInt(object.app.toString());
        return message;
    }
};
function createBaseHashedParams() {
    return {
        blockMaxBytes: BigInt(0),
        blockMaxGas: BigInt(0)
    };
}
exports.HashedParams = {
    typeUrl: "/tendermint.types.HashedParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockMaxBytes !== BigInt(0)) writer.uint32(8).int64(message.blockMaxBytes);
        if (message.blockMaxGas !== BigInt(0)) writer.uint32(16).int64(message.blockMaxGas);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.blockMaxBytes = reader.int64();
                    break;
                case 2:
                    message.blockMaxGas = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseHashedParams();
        if ((0, helpers_1.isSet)(object.blockMaxBytes)) obj.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        if ((0, helpers_1.isSet)(object.blockMaxGas)) obj.blockMaxGas = BigInt(object.blockMaxGas.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.blockMaxBytes !== undefined && (obj.blockMaxBytes = (message.blockMaxBytes || BigInt(0)).toString());
        message.blockMaxGas !== undefined && (obj.blockMaxGas = (message.blockMaxGas || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseHashedParams();
        if (object.blockMaxBytes !== undefined && object.blockMaxBytes !== null) message.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        if (object.blockMaxGas !== undefined && object.blockMaxGas !== null) message.blockMaxGas = BigInt(object.blockMaxGas.toString());
        return message;
    }
};
function createBaseABCIParams() {
    return {
        voteExtensionsEnableHeight: BigInt(0)
    };
}
exports.ABCIParams = {
    typeUrl: "/tendermint.types.ABCIParams",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtensionsEnableHeight !== BigInt(0)) writer.uint32(8).int64(message.voteExtensionsEnableHeight);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseABCIParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.voteExtensionsEnableHeight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseABCIParams();
        if ((0, helpers_1.isSet)(object.voteExtensionsEnableHeight)) obj.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.voteExtensionsEnableHeight !== undefined && (obj.voteExtensionsEnableHeight = (message.voteExtensionsEnableHeight || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseABCIParams();
        if (object.voteExtensionsEnableHeight !== undefined && object.voteExtensionsEnableHeight !== null) message.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        return message;
    }
};

},{"313430d25772ceed":"clU50","209b2e59671f9eae":"bi36x","fc9d9d72a50e0375":"eYjRL"}],"bGgqD":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupStakingExtension = setupStakingExtension;
const query_1 = require("860a39cd3358bcd1");
const queryclient_1 = require("1fdf1158772c3d16");
function setupStakingExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        staking: {
            delegation: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.Delegation({
                    delegatorAddr: delegatorAddress,
                    validatorAddr: validatorAddress
                });
                return response;
            },
            delegatorDelegations: async (delegatorAddress, paginationKey)=>{
                const response = await queryService.DelegatorDelegations({
                    delegatorAddr: delegatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            delegatorUnbondingDelegations: async (delegatorAddress, paginationKey)=>{
                const response = await queryService.DelegatorUnbondingDelegations({
                    delegatorAddr: delegatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            delegatorValidator: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.DelegatorValidator({
                    delegatorAddr: delegatorAddress,
                    validatorAddr: validatorAddress
                });
                return response;
            },
            delegatorValidators: async (delegatorAddress, paginationKey)=>{
                const response = await queryService.DelegatorValidators({
                    delegatorAddr: delegatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            historicalInfo: async (height)=>{
                const response = await queryService.HistoricalInfo({
                    height: BigInt(height)
                });
                return response;
            },
            params: async ()=>{
                const response = await queryService.Params({});
                return response;
            },
            pool: async ()=>{
                const response = await queryService.Pool({});
                return response;
            },
            redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey)=>{
                const response = await queryService.Redelegations({
                    delegatorAddr: delegatorAddress,
                    srcValidatorAddr: sourceValidatorAddress,
                    dstValidatorAddr: destinationValidatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            unbondingDelegation: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.UnbondingDelegation({
                    delegatorAddr: delegatorAddress,
                    validatorAddr: validatorAddress
                });
                return response;
            },
            validator: async (validatorAddress)=>{
                const response = await queryService.Validator({
                    validatorAddr: validatorAddress
                });
                return response;
            },
            validatorDelegations: async (validatorAddress, paginationKey)=>{
                const response = await queryService.ValidatorDelegations({
                    validatorAddr: validatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            validators: async (status, paginationKey)=>{
                const response = await queryService.Validators({
                    status: status,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            validatorUnbondingDelegations: async (validatorAddress, paginationKey)=>{
                const response = await queryService.ValidatorUnbondingDelegations({
                    validatorAddr: validatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            }
        }
    };
}

},{"860a39cd3358bcd1":"jWOP1","1fdf1158772c3d16":"cM4fi"}],"jWOP1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryPoolResponse = exports.QueryPoolRequest = exports.QueryHistoricalInfoResponse = exports.QueryHistoricalInfoRequest = exports.QueryDelegatorValidatorResponse = exports.QueryDelegatorValidatorRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryRedelegationsResponse = exports.QueryRedelegationsRequest = exports.QueryDelegatorUnbondingDelegationsResponse = exports.QueryDelegatorUnbondingDelegationsRequest = exports.QueryDelegatorDelegationsResponse = exports.QueryDelegatorDelegationsRequest = exports.QueryUnbondingDelegationResponse = exports.QueryUnbondingDelegationRequest = exports.QueryDelegationResponse = exports.QueryDelegationRequest = exports.QueryValidatorUnbondingDelegationsResponse = exports.QueryValidatorUnbondingDelegationsRequest = exports.QueryValidatorDelegationsResponse = exports.QueryValidatorDelegationsRequest = exports.QueryValidatorResponse = exports.QueryValidatorRequest = exports.QueryValidatorsResponse = exports.QueryValidatorsRequest = exports.protobufPackage = void 0;
/* eslint-disable */ const pagination_1 = require("6a8ecb902f51cd3f");
const staking_1 = require("acbb772c93efb1e");
const binary_1 = require("b3ec7922c3f539f4");
const helpers_1 = require("11ac1cfb8c4794c6");
exports.protobufPackage = "cosmos.staking.v1beta1";
function createBaseQueryValidatorsRequest() {
    return {
        status: "",
        pagination: undefined
    };
}
exports.QueryValidatorsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") writer.uint32(10).string(message.status);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.status = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorsRequest();
        if ((0, helpers_1.isSet)(object.status)) obj.status = String(object.status);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.status !== undefined && (obj.status = message.status);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorsRequest();
        message.status = object.status ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryValidatorsResponse() {
    return {
        validators: [],
        pagination: undefined
    };
}
exports.QueryValidatorsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators)staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorsResponse();
        if (Array.isArray(object?.validators)) obj.validators = object.validators.map((e)=>staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.validators) obj.validators = message.validators.map((e)=>e ? staking_1.Validator.toJSON(e) : undefined);
        else obj.validators = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorsResponse();
        message.validators = object.validators?.map((e)=>staking_1.Validator.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryValidatorRequest() {
    return {
        validatorAddr: ""
    };
}
exports.QueryValidatorRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") writer.uint32(10).string(message.validatorAddr);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr)) obj.validatorAddr = String(object.validatorAddr);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    }
};
function createBaseQueryValidatorResponse() {
    return {
        validator: staking_1.Validator.fromPartial({})
    };
}
exports.QueryValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== undefined) staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validator = staking_1.Validator.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator)) obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validator !== undefined && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorResponse();
        if (object.validator !== undefined && object.validator !== null) message.validator = staking_1.Validator.fromPartial(object.validator);
        return message;
    }
};
function createBaseQueryValidatorDelegationsRequest() {
    return {
        validatorAddr: "",
        pagination: undefined
    };
}
exports.QueryValidatorDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") writer.uint32(10).string(message.validatorAddr);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr)) obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryValidatorDelegationsResponse() {
    return {
        delegationResponses: [],
        pagination: undefined
    };
}
exports.QueryValidatorDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses)staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorDelegationsResponse();
        if (Array.isArray(object?.delegationResponses)) obj.delegationResponses = object.delegationResponses.map((e)=>staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.delegationResponses) obj.delegationResponses = message.delegationResponses.map((e)=>e ? staking_1.DelegationResponse.toJSON(e) : undefined);
        else obj.delegationResponses = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorDelegationsResponse();
        message.delegationResponses = object.delegationResponses?.map((e)=>staking_1.DelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryValidatorUnbondingDelegationsRequest() {
    return {
        validatorAddr: "",
        pagination: undefined
    };
}
exports.QueryValidatorUnbondingDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") writer.uint32(10).string(message.validatorAddr);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr)) obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryValidatorUnbondingDelegationsResponse() {
    return {
        unbondingResponses: [],
        pagination: undefined
    };
}
exports.QueryValidatorUnbondingDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses)staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsResponse();
        if (Array.isArray(object?.unbondingResponses)) obj.unbondingResponses = object.unbondingResponses.map((e)=>staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.unbondingResponses) obj.unbondingResponses = message.unbondingResponses.map((e)=>e ? staking_1.UnbondingDelegation.toJSON(e) : undefined);
        else obj.unbondingResponses = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        message.unbondingResponses = object.unbondingResponses?.map((e)=>staking_1.UnbondingDelegation.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegationRequest() {
    return {
        delegatorAddr: "",
        validatorAddr: ""
    };
}
exports.QueryDelegationRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.validatorAddr !== "") writer.uint32(18).string(message.validatorAddr);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr)) obj.validatorAddr = String(object.validatorAddr);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    }
};
function createBaseQueryDelegationResponse() {
    return {
        delegationResponse: undefined
    };
}
exports.QueryDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegationResponse !== undefined) staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegationResponse)) obj.delegationResponse = staking_1.DelegationResponse.fromJSON(object.delegationResponse);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegationResponse !== undefined && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegationResponse();
        if (object.delegationResponse !== undefined && object.delegationResponse !== null) message.delegationResponse = staking_1.DelegationResponse.fromPartial(object.delegationResponse);
        return message;
    }
};
function createBaseQueryUnbondingDelegationRequest() {
    return {
        delegatorAddr: "",
        validatorAddr: ""
    };
}
exports.QueryUnbondingDelegationRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.validatorAddr !== "") writer.uint32(18).string(message.validatorAddr);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUnbondingDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr)) obj.validatorAddr = String(object.validatorAddr);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUnbondingDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    }
};
function createBaseQueryUnbondingDelegationResponse() {
    return {
        unbond: staking_1.UnbondingDelegation.fromPartial({})
    };
}
exports.QueryUnbondingDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbond !== undefined) staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryUnbondingDelegationResponse();
        if ((0, helpers_1.isSet)(object.unbond)) obj.unbond = staking_1.UnbondingDelegation.fromJSON(object.unbond);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.unbond !== undefined && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryUnbondingDelegationResponse();
        if (object.unbond !== undefined && object.unbond !== null) message.unbond = staking_1.UnbondingDelegation.fromPartial(object.unbond);
        return message;
    }
};
function createBaseQueryDelegatorDelegationsRequest() {
    return {
        delegatorAddr: "",
        pagination: undefined
    };
}
exports.QueryDelegatorDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegatorDelegationsResponse() {
    return {
        delegationResponses: [],
        pagination: undefined
    };
}
exports.QueryDelegatorDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses)staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorDelegationsResponse();
        if (Array.isArray(object?.delegationResponses)) obj.delegationResponses = object.delegationResponses.map((e)=>staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.delegationResponses) obj.delegationResponses = message.delegationResponses.map((e)=>e ? staking_1.DelegationResponse.toJSON(e) : undefined);
        else obj.delegationResponses = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorDelegationsResponse();
        message.delegationResponses = object.delegationResponses?.map((e)=>staking_1.DelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegatorUnbondingDelegationsRequest() {
    return {
        delegatorAddr: "",
        pagination: undefined
    };
}
exports.QueryDelegatorUnbondingDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegatorUnbondingDelegationsResponse() {
    return {
        unbondingResponses: [],
        pagination: undefined
    };
}
exports.QueryDelegatorUnbondingDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses)staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsResponse();
        if (Array.isArray(object?.unbondingResponses)) obj.unbondingResponses = object.unbondingResponses.map((e)=>staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.unbondingResponses) obj.unbondingResponses = message.unbondingResponses.map((e)=>e ? staking_1.UnbondingDelegation.toJSON(e) : undefined);
        else obj.unbondingResponses = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        message.unbondingResponses = object.unbondingResponses?.map((e)=>staking_1.UnbondingDelegation.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryRedelegationsRequest() {
    return {
        delegatorAddr: "",
        srcValidatorAddr: "",
        dstValidatorAddr: "",
        pagination: undefined
    };
}
exports.QueryRedelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.srcValidatorAddr !== "") writer.uint32(18).string(message.srcValidatorAddr);
        if (message.dstValidatorAddr !== "") writer.uint32(26).string(message.dstValidatorAddr);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.srcValidatorAddr = reader.string();
                    break;
                case 3:
                    message.dstValidatorAddr = reader.string();
                    break;
                case 4:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryRedelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.srcValidatorAddr)) obj.srcValidatorAddr = String(object.srcValidatorAddr);
        if ((0, helpers_1.isSet)(object.dstValidatorAddr)) obj.dstValidatorAddr = String(object.dstValidatorAddr);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== undefined && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== undefined && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryRedelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.srcValidatorAddr = object.srcValidatorAddr ?? "";
        message.dstValidatorAddr = object.dstValidatorAddr ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryRedelegationsResponse() {
    return {
        redelegationResponses: [],
        pagination: undefined
    };
}
exports.QueryRedelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.redelegationResponses)staking_1.RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryRedelegationsResponse();
        if (Array.isArray(object?.redelegationResponses)) obj.redelegationResponses = object.redelegationResponses.map((e)=>staking_1.RedelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.redelegationResponses) obj.redelegationResponses = message.redelegationResponses.map((e)=>e ? staking_1.RedelegationResponse.toJSON(e) : undefined);
        else obj.redelegationResponses = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryRedelegationsResponse();
        message.redelegationResponses = object.redelegationResponses?.map((e)=>staking_1.RedelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegatorValidatorsRequest() {
    return {
        delegatorAddr: "",
        pagination: undefined
    };
}
exports.QueryDelegatorValidatorsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegatorValidatorsResponse() {
    return {
        validators: [],
        pagination: undefined
    };
}
exports.QueryDelegatorValidatorsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators)staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object?.validators)) obj.validators = object.validators.map((e)=>staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.validators) obj.validators = message.validators.map((e)=>e ? staking_1.Validator.toJSON(e) : undefined);
        else obj.validators = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = object.validators?.map((e)=>staking_1.Validator.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseQueryDelegatorValidatorRequest() {
    return {
        delegatorAddr: "",
        validatorAddr: ""
    };
}
exports.QueryDelegatorValidatorRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") writer.uint32(10).string(message.delegatorAddr);
        if (message.validatorAddr !== "") writer.uint32(18).string(message.validatorAddr);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatorAddr = reader.string();
                    break;
                case 2:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorValidatorRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr)) obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr)) obj.validatorAddr = String(object.validatorAddr);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.delegatorAddr !== undefined && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorValidatorRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    }
};
function createBaseQueryDelegatorValidatorResponse() {
    return {
        validator: staking_1.Validator.fromPartial({})
    };
}
exports.QueryDelegatorValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== undefined) staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.validator = staking_1.Validator.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryDelegatorValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator)) obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.validator !== undefined && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryDelegatorValidatorResponse();
        if (object.validator !== undefined && object.validator !== null) message.validator = staking_1.Validator.fromPartial(object.validator);
        return message;
    }
};
function createBaseQueryHistoricalInfoRequest() {
    return {
        height: BigInt(0)
    };
}
exports.QueryHistoricalInfoRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).int64(message.height);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryHistoricalInfoRequest();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryHistoricalInfoRequest();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        return message;
    }
};
function createBaseQueryHistoricalInfoResponse() {
    return {
        hist: undefined
    };
}
exports.QueryHistoricalInfoResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hist !== undefined) staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryHistoricalInfoResponse();
        if ((0, helpers_1.isSet)(object.hist)) obj.hist = staking_1.HistoricalInfo.fromJSON(object.hist);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hist !== undefined && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryHistoricalInfoResponse();
        if (object.hist !== undefined && object.hist !== null) message.hist = staking_1.HistoricalInfo.fromPartial(object.hist);
        return message;
    }
};
function createBaseQueryPoolRequest() {
    return {};
}
exports.QueryPoolRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryPoolRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryPoolRequest();
        return message;
    }
};
function createBaseQueryPoolResponse() {
    return {
        pool: staking_1.Pool.fromPartial({})
    };
}
exports.QueryPoolResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== undefined) staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.pool = staking_1.Pool.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryPoolResponse();
        if ((0, helpers_1.isSet)(object.pool)) obj.pool = staking_1.Pool.fromJSON(object.pool);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.pool !== undefined && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryPoolResponse();
        if (object.pool !== undefined && object.pool !== null) message.pool = staking_1.Pool.fromPartial(object.pool);
        return message;
    }
};
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseQueryParamsRequest();
        return message;
    }
};
function createBaseQueryParamsResponse() {
    return {
        params: staking_1.Params.fromPartial({})
    };
}
exports.QueryParamsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.params = staking_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params)) obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== undefined && object.params !== null) message.params = staking_1.Params.fromPartial(object.params);
        return message;
    }
};
class QueryClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
    }
    Validators(request) {
        const data = exports.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data);
        return promise.then((data)=>exports.QueryValidatorsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Validator(request) {
        const data = exports.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data);
        return promise.then((data)=>exports.QueryValidatorResponse.decode(new binary_1.BinaryReader(data)));
    }
    ValidatorDelegations(request) {
        const data = exports.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data);
        return promise.then((data)=>exports.QueryValidatorDelegationsResponse.decode(new binary_1.BinaryReader(data)));
    }
    ValidatorUnbondingDelegations(request) {
        const data = exports.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data);
        return promise.then((data)=>exports.QueryValidatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Delegation(request) {
        const data = exports.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data);
        return promise.then((data)=>exports.QueryDelegationResponse.decode(new binary_1.BinaryReader(data)));
    }
    UnbondingDelegation(request) {
        const data = exports.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data);
        return promise.then((data)=>exports.QueryUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegatorDelegations(request) {
        const data = exports.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data);
        return promise.then((data)=>exports.QueryDelegatorDelegationsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegatorUnbondingDelegations(request) {
        const data = exports.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data);
        return promise.then((data)=>exports.QueryDelegatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data)));
    }
    Redelegations(request) {
        const data = exports.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data);
        return promise.then((data)=>exports.QueryRedelegationsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegatorValidators(request) {
        const data = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data)=>exports.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data)));
    }
    DelegatorValidator(request) {
        const data = exports.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data);
        return promise.then((data)=>exports.QueryDelegatorValidatorResponse.decode(new binary_1.BinaryReader(data)));
    }
    HistoricalInfo(request) {
        const data = exports.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data);
        return promise.then((data)=>exports.QueryHistoricalInfoResponse.decode(new binary_1.BinaryReader(data)));
    }
    Pool(request = {}) {
        const data = exports.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data);
        return promise.then((data)=>exports.QueryPoolResponse.decode(new binary_1.BinaryReader(data)));
    }
    Params(request = {}) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data);
        return promise.then((data)=>exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;

},{"6a8ecb902f51cd3f":"43d5n","acbb772c93efb1e":"gUdrn","b3ec7922c3f539f4":"bi36x","11ac1cfb8c4794c6":"eYjRL"}],"ie6s1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupTxExtension = setupTxExtension;
const proto_signing_1 = require("38d937d475217723");
const signing_1 = require("3f2eb66610ac827e");
const service_1 = require("e5f35a53ff7892f7");
const tx_1 = require("b6bcbb530cd60dde");
const queryclient_1 = require("798b904eace92e61");
function setupTxExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new service_1.ServiceClientImpl(rpc);
    return {
        tx: {
            getTx: async (txId)=>{
                const request = {
                    hash: txId
                };
                const response = await queryService.GetTx(request);
                return response;
            },
            simulate: async (messages, memo, signer, sequence)=>{
                const tx = tx_1.Tx.fromPartial({
                    authInfo: tx_1.AuthInfo.fromPartial({
                        fee: tx_1.Fee.fromPartial({}),
                        signerInfos: [
                            {
                                publicKey: (0, proto_signing_1.encodePubkey)(signer),
                                sequence: BigInt(sequence),
                                modeInfo: {
                                    single: {
                                        mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED
                                    }
                                }
                            }
                        ]
                    }),
                    body: tx_1.TxBody.fromPartial({
                        messages: Array.from(messages),
                        memo: memo
                    }),
                    signatures: [
                        new Uint8Array()
                    ]
                });
                const request = service_1.SimulateRequest.fromPartial({
                    txBytes: tx_1.Tx.encode(tx).finish()
                });
                const response = await queryService.Simulate(request);
                return response;
            }
        }
    };
}

},{"38d937d475217723":"2gdyE","3f2eb66610ac827e":"9PT9z","e5f35a53ff7892f7":"fvIHf","b6bcbb530cd60dde":"dbom9","798b904eace92e61":"cM4fi"}],"fvIHf":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceClientImpl = exports.TxDecodeAminoResponse = exports.TxDecodeAminoRequest = exports.TxEncodeAminoResponse = exports.TxEncodeAminoRequest = exports.TxEncodeResponse = exports.TxEncodeRequest = exports.TxDecodeResponse = exports.TxDecodeRequest = exports.GetBlockWithTxsResponse = exports.GetBlockWithTxsRequest = exports.GetTxResponse = exports.GetTxRequest = exports.SimulateResponse = exports.SimulateRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.GetTxsEventResponse = exports.GetTxsEventRequest = exports.broadcastModeToJSON = exports.broadcastModeFromJSON = exports.BroadcastMode = exports.orderByToJSON = exports.orderByFromJSON = exports.OrderBy = exports.protobufPackage = void 0;
/* eslint-disable */ const tx_1 = require("9a093dd5df4ab400");
const pagination_1 = require("eafea038f01ca37c");
const abci_1 = require("fde4b4a5cd927f39");
const types_1 = require("f2d518301e6e1fad");
const block_1 = require("ef8dfbbef5a876bd");
const binary_1 = require("e121277ec5035b49");
const helpers_1 = require("508f63fd517413d0");
exports.protobufPackage = "cosmos.tx.v1beta1";
/** OrderBy defines the sorting order */ var OrderBy;
(function(OrderBy) {
    /**
     * ORDER_BY_UNSPECIFIED - ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults
     * to ASC in this case.
     */ OrderBy[OrderBy["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
    /** ORDER_BY_ASC - ORDER_BY_ASC defines ascending order */ OrderBy[OrderBy["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
    /** ORDER_BY_DESC - ORDER_BY_DESC defines descending order */ OrderBy[OrderBy["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
    OrderBy[OrderBy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderBy || (exports.OrderBy = OrderBy = {}));
function orderByFromJSON(object) {
    switch(object){
        case 0:
        case "ORDER_BY_UNSPECIFIED":
            return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
            return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
            return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderBy.UNRECOGNIZED;
    }
}
exports.orderByFromJSON = orderByFromJSON;
function orderByToJSON(object) {
    switch(object){
        case OrderBy.ORDER_BY_UNSPECIFIED:
            return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
            return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
            return "ORDER_BY_DESC";
        case OrderBy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.orderByToJSON = orderByToJSON;
/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
 * method.
 */ var BroadcastMode;
(function(BroadcastMode) {
    /** BROADCAST_MODE_UNSPECIFIED - zero-value for mode ordering */ BroadcastMode[BroadcastMode["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
    /**
     * BROADCAST_MODE_BLOCK - DEPRECATED: use BROADCAST_MODE_SYNC instead,
     * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
     */ BroadcastMode[BroadcastMode["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
    /**
     * BROADCAST_MODE_SYNC - BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
     * for a CheckTx execution response only.
     */ BroadcastMode[BroadcastMode["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
    /**
     * BROADCAST_MODE_ASYNC - BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
     * returns immediately.
     */ BroadcastMode[BroadcastMode["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
    BroadcastMode[BroadcastMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BroadcastMode || (exports.BroadcastMode = BroadcastMode = {}));
function broadcastModeFromJSON(object) {
    switch(object){
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
            return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
            return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
            return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
            return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BroadcastMode.UNRECOGNIZED;
    }
}
exports.broadcastModeFromJSON = broadcastModeFromJSON;
function broadcastModeToJSON(object) {
    switch(object){
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
            return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
            return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
            return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
            return "BROADCAST_MODE_ASYNC";
        case BroadcastMode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.broadcastModeToJSON = broadcastModeToJSON;
function createBaseGetTxsEventRequest() {
    return {
        events: [],
        pagination: undefined,
        orderBy: 0,
        page: BigInt(0),
        limit: BigInt(0),
        query: ""
    };
}
exports.GetTxsEventRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events)writer.uint32(10).string(v);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        if (message.orderBy !== 0) writer.uint32(24).int32(message.orderBy);
        if (message.page !== BigInt(0)) writer.uint32(32).uint64(message.page);
        if (message.limit !== BigInt(0)) writer.uint32(40).uint64(message.limit);
        if (message.query !== "") writer.uint32(50).string(message.query);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.events.push(reader.string());
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderBy = reader.int32();
                    break;
                case 4:
                    message.page = reader.uint64();
                    break;
                case 5:
                    message.limit = reader.uint64();
                    break;
                case 6:
                    message.query = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGetTxsEventRequest();
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>String(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.orderBy)) obj.orderBy = orderByFromJSON(object.orderBy);
        if ((0, helpers_1.isSet)(object.page)) obj.page = BigInt(object.page.toString());
        if ((0, helpers_1.isSet)(object.limit)) obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.query)) obj.query = String(object.query);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.events) obj.events = message.events.map((e)=>e);
        else obj.events = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        message.orderBy !== undefined && (obj.orderBy = orderByToJSON(message.orderBy));
        message.page !== undefined && (obj.page = (message.page || BigInt(0)).toString());
        message.limit !== undefined && (obj.limit = (message.limit || BigInt(0)).toString());
        message.query !== undefined && (obj.query = message.query);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetTxsEventRequest();
        message.events = object.events?.map((e)=>e) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        message.orderBy = object.orderBy ?? 0;
        if (object.page !== undefined && object.page !== null) message.page = BigInt(object.page.toString());
        if (object.limit !== undefined && object.limit !== null) message.limit = BigInt(object.limit.toString());
        message.query = object.query ?? "";
        return message;
    }
};
function createBaseGetTxsEventResponse() {
    return {
        txs: [],
        txResponses: [],
        pagination: undefined,
        total: BigInt(0)
    };
}
exports.GetTxsEventResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs)tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.txResponses)abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        if (message.total !== BigInt(0)) writer.uint32(32).uint64(message.total);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.total = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGetTxsEventResponse();
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>tx_1.Tx.fromJSON(e));
        if (Array.isArray(object?.txResponses)) obj.txResponses = object.txResponses.map((e)=>abci_1.TxResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.total)) obj.total = BigInt(object.total.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.txs) obj.txs = message.txs.map((e)=>e ? tx_1.Tx.toJSON(e) : undefined);
        else obj.txs = [];
        if (message.txResponses) obj.txResponses = message.txResponses.map((e)=>e ? abci_1.TxResponse.toJSON(e) : undefined);
        else obj.txResponses = [];
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        message.total !== undefined && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetTxsEventResponse();
        message.txs = object.txs?.map((e)=>tx_1.Tx.fromPartial(e)) || [];
        message.txResponses = object.txResponses?.map((e)=>abci_1.TxResponse.fromPartial(e)) || [];
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        if (object.total !== undefined && object.total !== null) message.total = BigInt(object.total.toString());
        return message;
    }
};
function createBaseBroadcastTxRequest() {
    return {
        txBytes: new Uint8Array(),
        mode: 0
    };
}
exports.BroadcastTxRequest = {
    typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) writer.uint32(10).bytes(message.txBytes);
        if (message.mode !== 0) writer.uint32(16).int32(message.mode);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txBytes = reader.bytes();
                    break;
                case 2:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBroadcastTxRequest();
        if ((0, helpers_1.isSet)(object.txBytes)) obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        if ((0, helpers_1.isSet)(object.mode)) obj.mode = broadcastModeFromJSON(object.mode);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
        message.mode !== undefined && (obj.mode = broadcastModeToJSON(message.mode));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBroadcastTxRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        message.mode = object.mode ?? 0;
        return message;
    }
};
function createBaseBroadcastTxResponse() {
    return {
        txResponse: undefined
    };
}
exports.BroadcastTxResponse = {
    typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.txResponse !== undefined) abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBroadcastTxResponse();
        if ((0, helpers_1.isSet)(object.txResponse)) obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.txResponse !== undefined && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBroadcastTxResponse();
        if (object.txResponse !== undefined && object.txResponse !== null) message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        return message;
    }
};
function createBaseSimulateRequest() {
    return {
        tx: undefined,
        txBytes: new Uint8Array()
    };
}
exports.SimulateRequest = {
    typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== undefined) tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        if (message.txBytes.length !== 0) writer.uint32(18).bytes(message.txBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSimulateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.txBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSimulateRequest();
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txBytes)) obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSimulateRequest();
        if (object.tx !== undefined && object.tx !== null) message.tx = tx_1.Tx.fromPartial(object.tx);
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
    }
};
function createBaseSimulateResponse() {
    return {
        gasInfo: undefined,
        result: undefined
    };
}
exports.SimulateResponse = {
    typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== undefined) abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        if (message.result !== undefined) abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSimulateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.result = abci_1.Result.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSimulateResponse();
        if ((0, helpers_1.isSet)(object.gasInfo)) obj.gasInfo = abci_1.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result)) obj.result = abci_1.Result.fromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.gasInfo !== undefined && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : undefined);
        message.result !== undefined && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSimulateResponse();
        if (object.gasInfo !== undefined && object.gasInfo !== null) message.gasInfo = abci_1.GasInfo.fromPartial(object.gasInfo);
        if (object.result !== undefined && object.result !== null) message.result = abci_1.Result.fromPartial(object.result);
        return message;
    }
};
function createBaseGetTxRequest() {
    return {
        hash: ""
    };
}
exports.GetTxRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") writer.uint32(10).string(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTxRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGetTxRequest();
        if ((0, helpers_1.isSet)(object.hash)) obj.hash = String(object.hash);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = message.hash);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetTxRequest();
        message.hash = object.hash ?? "";
        return message;
    }
};
function createBaseGetTxResponse() {
    return {
        tx: undefined,
        txResponse: undefined
    };
}
exports.GetTxResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== undefined) tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        if (message.txResponse !== undefined) abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTxResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGetTxResponse();
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txResponse)) obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
        message.txResponse !== undefined && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetTxResponse();
        if (object.tx !== undefined && object.tx !== null) message.tx = tx_1.Tx.fromPartial(object.tx);
        if (object.txResponse !== undefined && object.txResponse !== null) message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        return message;
    }
};
function createBaseGetBlockWithTxsRequest() {
    return {
        height: BigInt(0),
        pagination: undefined
    };
}
exports.GetBlockWithTxsRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).int64(message.height);
        if (message.pagination !== undefined) pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.int64();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGetBlockWithTxsRequest();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetBlockWithTxsRequest();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        return message;
    }
};
function createBaseGetBlockWithTxsResponse() {
    return {
        txs: [],
        blockId: undefined,
        block: undefined,
        pagination: undefined
    };
}
exports.GetBlockWithTxsResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs)tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.blockId !== undefined) types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
        if (message.block !== undefined) block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
        if (message.pagination !== undefined) pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.blockId = types_1.BlockID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.block = block_1.Block.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGetBlockWithTxsResponse();
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>tx_1.Tx.fromJSON(e));
        if ((0, helpers_1.isSet)(object.blockId)) obj.blockId = types_1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.block)) obj.block = block_1.Block.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.pagination)) obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.txs) obj.txs = message.txs.map((e)=>e ? tx_1.Tx.toJSON(e) : undefined);
        else obj.txs = [];
        message.blockId !== undefined && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : undefined);
        message.block !== undefined && (obj.block = message.block ? block_1.Block.toJSON(message.block) : undefined);
        message.pagination !== undefined && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetBlockWithTxsResponse();
        message.txs = object.txs?.map((e)=>tx_1.Tx.fromPartial(e)) || [];
        if (object.blockId !== undefined && object.blockId !== null) message.blockId = types_1.BlockID.fromPartial(object.blockId);
        if (object.block !== undefined && object.block !== null) message.block = block_1.Block.fromPartial(object.block);
        if (object.pagination !== undefined && object.pagination !== null) message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        return message;
    }
};
function createBaseTxDecodeRequest() {
    return {
        txBytes: new Uint8Array()
    };
}
exports.TxDecodeRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) writer.uint32(10).bytes(message.txBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxDecodeRequest();
        if ((0, helpers_1.isSet)(object.txBytes)) obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxDecodeRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
    }
};
function createBaseTxDecodeResponse() {
    return {
        tx: undefined
    };
}
exports.TxDecodeResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== undefined) tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxDecodeResponse();
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxDecodeResponse();
        if (object.tx !== undefined && object.tx !== null) message.tx = tx_1.Tx.fromPartial(object.tx);
        return message;
    }
};
function createBaseTxEncodeRequest() {
    return {
        tx: undefined
    };
}
exports.TxEncodeRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== undefined) tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.tx = tx_1.Tx.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxEncodeRequest();
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.tx !== undefined && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxEncodeRequest();
        if (object.tx !== undefined && object.tx !== null) message.tx = tx_1.Tx.fromPartial(object.tx);
        return message;
    }
};
function createBaseTxEncodeResponse() {
    return {
        txBytes: new Uint8Array()
    };
}
exports.TxEncodeResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) writer.uint32(10).bytes(message.txBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.txBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxEncodeResponse();
        if ((0, helpers_1.isSet)(object.txBytes)) obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.txBytes !== undefined && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== undefined ? message.txBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxEncodeResponse();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
    }
};
function createBaseTxEncodeAminoRequest() {
    return {
        aminoJson: ""
    };
}
exports.TxEncodeAminoRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") writer.uint32(10).string(message.aminoJson);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.aminoJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxEncodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoJson)) obj.aminoJson = String(object.aminoJson);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.aminoJson !== undefined && (obj.aminoJson = message.aminoJson);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxEncodeAminoRequest();
        message.aminoJson = object.aminoJson ?? "";
        return message;
    }
};
function createBaseTxEncodeAminoResponse() {
    return {
        aminoBinary: new Uint8Array()
    };
}
exports.TxEncodeAminoResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) writer.uint32(10).bytes(message.aminoBinary);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.aminoBinary = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxEncodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoBinary)) obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.aminoBinary !== undefined && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== undefined ? message.aminoBinary : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxEncodeAminoResponse();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
    }
};
function createBaseTxDecodeAminoRequest() {
    return {
        aminoBinary: new Uint8Array()
    };
}
exports.TxDecodeAminoRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) writer.uint32(10).bytes(message.aminoBinary);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.aminoBinary = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxDecodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoBinary)) obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.aminoBinary !== undefined && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== undefined ? message.aminoBinary : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxDecodeAminoRequest();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
    }
};
function createBaseTxDecodeAminoResponse() {
    return {
        aminoJson: ""
    };
}
exports.TxDecodeAminoResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") writer.uint32(10).string(message.aminoJson);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.aminoJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxDecodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoJson)) obj.aminoJson = String(object.aminoJson);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.aminoJson !== undefined && (obj.aminoJson = message.aminoJson);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxDecodeAminoResponse();
        message.aminoJson = object.aminoJson ?? "";
        return message;
    }
};
class ServiceClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
        this.TxDecode = this.TxDecode.bind(this);
        this.TxEncode = this.TxEncode.bind(this);
        this.TxEncodeAmino = this.TxEncodeAmino.bind(this);
        this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
    }
    Simulate(request) {
        const data = exports.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data);
        return promise.then((data)=>exports.SimulateResponse.decode(new binary_1.BinaryReader(data)));
    }
    GetTx(request) {
        const data = exports.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data);
        return promise.then((data)=>exports.GetTxResponse.decode(new binary_1.BinaryReader(data)));
    }
    BroadcastTx(request) {
        const data = exports.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data);
        return promise.then((data)=>exports.BroadcastTxResponse.decode(new binary_1.BinaryReader(data)));
    }
    GetTxsEvent(request) {
        const data = exports.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data);
        return promise.then((data)=>exports.GetTxsEventResponse.decode(new binary_1.BinaryReader(data)));
    }
    GetBlockWithTxs(request) {
        const data = exports.GetBlockWithTxsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data);
        return promise.then((data)=>exports.GetBlockWithTxsResponse.decode(new binary_1.BinaryReader(data)));
    }
    TxDecode(request) {
        const data = exports.TxDecodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", data);
        return promise.then((data)=>exports.TxDecodeResponse.decode(new binary_1.BinaryReader(data)));
    }
    TxEncode(request) {
        const data = exports.TxEncodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", data);
        return promise.then((data)=>exports.TxEncodeResponse.decode(new binary_1.BinaryReader(data)));
    }
    TxEncodeAmino(request) {
        const data = exports.TxEncodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", data);
        return promise.then((data)=>exports.TxEncodeAminoResponse.decode(new binary_1.BinaryReader(data)));
    }
    TxDecodeAmino(request) {
        const data = exports.TxDecodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", data);
        return promise.then((data)=>exports.TxDecodeAminoResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.ServiceClientImpl = ServiceClientImpl;

},{"9a093dd5df4ab400":"dbom9","eafea038f01ca37c":"43d5n","fde4b4a5cd927f39":"jt1ue","f2d518301e6e1fad":"9y1Fs","ef8dfbbef5a876bd":"kLm0D","e121277ec5035b49":"bi36x","508f63fd517413d0":"eYjRL"}],"jt1ue":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchBlocksResult = exports.SearchTxsResult = exports.TxMsgData = exports.MsgData = exports.SimulationResponse = exports.Result = exports.GasInfo = exports.Attribute = exports.StringEvent = exports.ABCIMessageLog = exports.TxResponse = exports.protobufPackage = void 0;
/* eslint-disable */ const any_1 = require("b783c16c5be5c6b5");
const types_1 = require("ce88b8ab5211b2b5");
const block_1 = require("99e02b06da42ffd5");
const binary_1 = require("ebaead1120eef81");
const helpers_1 = require("7607380dc68ed3d1");
exports.protobufPackage = "cosmos.base.abci.v1beta1";
function createBaseTxResponse() {
    return {
        height: BigInt(0),
        txhash: "",
        codespace: "",
        code: 0,
        data: "",
        rawLog: "",
        logs: [],
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        tx: undefined,
        timestamp: "",
        events: []
    };
}
exports.TxResponse = {
    typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) writer.uint32(8).int64(message.height);
        if (message.txhash !== "") writer.uint32(18).string(message.txhash);
        if (message.codespace !== "") writer.uint32(26).string(message.codespace);
        if (message.code !== 0) writer.uint32(32).uint32(message.code);
        if (message.data !== "") writer.uint32(42).string(message.data);
        if (message.rawLog !== "") writer.uint32(50).string(message.rawLog);
        for (const v of message.logs)exports.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
        if (message.info !== "") writer.uint32(66).string(message.info);
        if (message.gasWanted !== BigInt(0)) writer.uint32(72).int64(message.gasWanted);
        if (message.gasUsed !== BigInt(0)) writer.uint32(80).int64(message.gasUsed);
        if (message.tx !== undefined) any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        if (message.timestamp !== "") writer.uint32(98).string(message.timestamp);
        for (const v of message.events)types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.height = reader.int64();
                    break;
                case 2:
                    message.txhash = reader.string();
                    break;
                case 3:
                    message.codespace = reader.string();
                    break;
                case 4:
                    message.code = reader.uint32();
                    break;
                case 5:
                    message.data = reader.string();
                    break;
                case 6:
                    message.rawLog = reader.string();
                    break;
                case 7:
                    message.logs.push(exports.ABCIMessageLog.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.info = reader.string();
                    break;
                case 9:
                    message.gasWanted = reader.int64();
                    break;
                case 10:
                    message.gasUsed = reader.int64();
                    break;
                case 11:
                    message.tx = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.timestamp = reader.string();
                    break;
                case 13:
                    message.events.push(types_1.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxResponse();
        if ((0, helpers_1.isSet)(object.height)) obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.txhash)) obj.txhash = String(object.txhash);
        if ((0, helpers_1.isSet)(object.codespace)) obj.codespace = String(object.codespace);
        if ((0, helpers_1.isSet)(object.code)) obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data)) obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.rawLog)) obj.rawLog = String(object.rawLog);
        if (Array.isArray(object?.logs)) obj.logs = object.logs.map((e)=>exports.ABCIMessageLog.fromJSON(e));
        if ((0, helpers_1.isSet)(object.info)) obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gasWanted)) obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed)) obj.gasUsed = BigInt(object.gasUsed.toString());
        if ((0, helpers_1.isSet)(object.tx)) obj.tx = any_1.Any.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = String(object.timestamp);
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>types_1.Event.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.txhash !== undefined && (obj.txhash = message.txhash);
        message.codespace !== undefined && (obj.codespace = message.codespace);
        message.code !== undefined && (obj.code = Math.round(message.code));
        message.data !== undefined && (obj.data = message.data);
        message.rawLog !== undefined && (obj.rawLog = message.rawLog);
        if (message.logs) obj.logs = message.logs.map((e)=>e ? exports.ABCIMessageLog.toJSON(e) : undefined);
        else obj.logs = [];
        message.info !== undefined && (obj.info = message.info);
        message.gasWanted !== undefined && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== undefined && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        message.tx !== undefined && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : undefined);
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        if (message.events) obj.events = message.events.map((e)=>e ? types_1.Event.toJSON(e) : undefined);
        else obj.events = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxResponse();
        if (object.height !== undefined && object.height !== null) message.height = BigInt(object.height.toString());
        message.txhash = object.txhash ?? "";
        message.codespace = object.codespace ?? "";
        message.code = object.code ?? 0;
        message.data = object.data ?? "";
        message.rawLog = object.rawLog ?? "";
        message.logs = object.logs?.map((e)=>exports.ABCIMessageLog.fromPartial(e)) || [];
        message.info = object.info ?? "";
        if (object.gasWanted !== undefined && object.gasWanted !== null) message.gasWanted = BigInt(object.gasWanted.toString());
        if (object.gasUsed !== undefined && object.gasUsed !== null) message.gasUsed = BigInt(object.gasUsed.toString());
        if (object.tx !== undefined && object.tx !== null) message.tx = any_1.Any.fromPartial(object.tx);
        message.timestamp = object.timestamp ?? "";
        message.events = object.events?.map((e)=>types_1.Event.fromPartial(e)) || [];
        return message;
    }
};
function createBaseABCIMessageLog() {
    return {
        msgIndex: 0,
        log: "",
        events: []
    };
}
exports.ABCIMessageLog = {
    typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgIndex !== 0) writer.uint32(8).uint32(message.msgIndex);
        if (message.log !== "") writer.uint32(18).string(message.log);
        for (const v of message.events)exports.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseABCIMessageLog();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.msgIndex = reader.uint32();
                    break;
                case 2:
                    message.log = reader.string();
                    break;
                case 3:
                    message.events.push(exports.StringEvent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseABCIMessageLog();
        if ((0, helpers_1.isSet)(object.msgIndex)) obj.msgIndex = Number(object.msgIndex);
        if ((0, helpers_1.isSet)(object.log)) obj.log = String(object.log);
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>exports.StringEvent.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.msgIndex !== undefined && (obj.msgIndex = Math.round(message.msgIndex));
        message.log !== undefined && (obj.log = message.log);
        if (message.events) obj.events = message.events.map((e)=>e ? exports.StringEvent.toJSON(e) : undefined);
        else obj.events = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseABCIMessageLog();
        message.msgIndex = object.msgIndex ?? 0;
        message.log = object.log ?? "";
        message.events = object.events?.map((e)=>exports.StringEvent.fromPartial(e)) || [];
        return message;
    }
};
function createBaseStringEvent() {
    return {
        type: "",
        attributes: []
    };
}
exports.StringEvent = {
    typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") writer.uint32(10).string(message.type);
        for (const v of message.attributes)exports.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStringEvent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.attributes.push(exports.Attribute.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseStringEvent();
        if ((0, helpers_1.isSet)(object.type)) obj.type = String(object.type);
        if (Array.isArray(object?.attributes)) obj.attributes = object.attributes.map((e)=>exports.Attribute.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type);
        if (message.attributes) obj.attributes = message.attributes.map((e)=>e ? exports.Attribute.toJSON(e) : undefined);
        else obj.attributes = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseStringEvent();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e)=>exports.Attribute.fromPartial(e)) || [];
        return message;
    }
};
function createBaseAttribute() {
    return {
        key: "",
        value: ""
    };
}
exports.Attribute = {
    typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== "") writer.uint32(18).string(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAttribute();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseAttribute();
        if ((0, helpers_1.isSet)(object.key)) obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value)) obj.value = String(object.value);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    }
};
function createBaseGasInfo() {
    return {
        gasWanted: BigInt(0),
        gasUsed: BigInt(0)
    };
}
exports.GasInfo = {
    typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasWanted !== BigInt(0)) writer.uint32(8).uint64(message.gasWanted);
        if (message.gasUsed !== BigInt(0)) writer.uint32(16).uint64(message.gasUsed);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGasInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.gasWanted = reader.uint64();
                    break;
                case 2:
                    message.gasUsed = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseGasInfo();
        if ((0, helpers_1.isSet)(object.gasWanted)) obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed)) obj.gasUsed = BigInt(object.gasUsed.toString());
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.gasWanted !== undefined && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== undefined && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGasInfo();
        if (object.gasWanted !== undefined && object.gasWanted !== null) message.gasWanted = BigInt(object.gasWanted.toString());
        if (object.gasUsed !== undefined && object.gasUsed !== null) message.gasUsed = BigInt(object.gasUsed.toString());
        return message;
    }
};
function createBaseResult() {
    return {
        data: new Uint8Array(),
        log: "",
        events: [],
        msgResponses: []
    };
}
exports.Result = {
    typeUrl: "/cosmos.base.abci.v1beta1.Result",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) writer.uint32(10).bytes(message.data);
        if (message.log !== "") writer.uint32(18).string(message.log);
        for (const v of message.events)types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
        for (const v of message.msgResponses)any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.log = reader.string();
                    break;
                case 3:
                    message.events.push(types_1.Event.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseResult();
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log)) obj.log = String(object.log);
        if (Array.isArray(object?.events)) obj.events = object.events.map((e)=>types_1.Event.fromJSON(e));
        if (Array.isArray(object?.msgResponses)) obj.msgResponses = object.msgResponses.map((e)=>any_1.Any.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        message.log !== undefined && (obj.log = message.log);
        if (message.events) obj.events = message.events.map((e)=>e ? types_1.Event.toJSON(e) : undefined);
        else obj.events = [];
        if (message.msgResponses) obj.msgResponses = message.msgResponses.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.msgResponses = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseResult();
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.events = object.events?.map((e)=>types_1.Event.fromPartial(e)) || [];
        message.msgResponses = object.msgResponses?.map((e)=>any_1.Any.fromPartial(e)) || [];
        return message;
    }
};
function createBaseSimulationResponse() {
    return {
        gasInfo: exports.GasInfo.fromPartial({}),
        result: undefined
    };
}
exports.SimulationResponse = {
    typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== undefined) exports.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        if (message.result !== undefined) exports.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSimulationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.gasInfo = exports.GasInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.result = exports.Result.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSimulationResponse();
        if ((0, helpers_1.isSet)(object.gasInfo)) obj.gasInfo = exports.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result)) obj.result = exports.Result.fromJSON(object.result);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.gasInfo !== undefined && (obj.gasInfo = message.gasInfo ? exports.GasInfo.toJSON(message.gasInfo) : undefined);
        message.result !== undefined && (obj.result = message.result ? exports.Result.toJSON(message.result) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSimulationResponse();
        if (object.gasInfo !== undefined && object.gasInfo !== null) message.gasInfo = exports.GasInfo.fromPartial(object.gasInfo);
        if (object.result !== undefined && object.result !== null) message.result = exports.Result.fromPartial(object.result);
        return message;
    }
};
function createBaseMsgData() {
    return {
        msgType: "",
        data: new Uint8Array()
    };
}
exports.MsgData = {
    typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgType !== "") writer.uint32(10).string(message.msgType);
        if (message.data.length !== 0) writer.uint32(18).bytes(message.data);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.msgType = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgData();
        if ((0, helpers_1.isSet)(object.msgType)) obj.msgType = String(object.msgType);
        if ((0, helpers_1.isSet)(object.data)) obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.msgType !== undefined && (obj.msgType = message.msgType);
        message.data !== undefined && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgData();
        message.msgType = object.msgType ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
    }
};
function createBaseTxMsgData() {
    return {
        data: [],
        msgResponses: []
    };
}
exports.TxMsgData = {
    typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.data)exports.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.msgResponses)any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.data.push(exports.MsgData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseTxMsgData();
        if (Array.isArray(object?.data)) obj.data = object.data.map((e)=>exports.MsgData.fromJSON(e));
        if (Array.isArray(object?.msgResponses)) obj.msgResponses = object.msgResponses.map((e)=>any_1.Any.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.data) obj.data = message.data.map((e)=>e ? exports.MsgData.toJSON(e) : undefined);
        else obj.data = [];
        if (message.msgResponses) obj.msgResponses = message.msgResponses.map((e)=>e ? any_1.Any.toJSON(e) : undefined);
        else obj.msgResponses = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseTxMsgData();
        message.data = object.data?.map((e)=>exports.MsgData.fromPartial(e)) || [];
        message.msgResponses = object.msgResponses?.map((e)=>any_1.Any.fromPartial(e)) || [];
        return message;
    }
};
function createBaseSearchTxsResult() {
    return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        txs: []
    };
}
exports.SearchTxsResult = {
    typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) writer.uint32(8).uint64(message.totalCount);
        if (message.count !== BigInt(0)) writer.uint32(16).uint64(message.count);
        if (message.pageNumber !== BigInt(0)) writer.uint32(24).uint64(message.pageNumber);
        if (message.pageTotal !== BigInt(0)) writer.uint32(32).uint64(message.pageTotal);
        if (message.limit !== BigInt(0)) writer.uint32(40).uint64(message.limit);
        for (const v of message.txs)exports.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchTxsResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.totalCount = reader.uint64();
                    break;
                case 2:
                    message.count = reader.uint64();
                    break;
                case 3:
                    message.pageNumber = reader.uint64();
                    break;
                case 4:
                    message.pageTotal = reader.uint64();
                    break;
                case 5:
                    message.limit = reader.uint64();
                    break;
                case 6:
                    message.txs.push(exports.TxResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSearchTxsResult();
        if ((0, helpers_1.isSet)(object.totalCount)) obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count)) obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber)) obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal)) obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit)) obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object?.txs)) obj.txs = object.txs.map((e)=>exports.TxResponse.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.totalCount !== undefined && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== undefined && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== undefined && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== undefined && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== undefined && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.txs) obj.txs = message.txs.map((e)=>e ? exports.TxResponse.toJSON(e) : undefined);
        else obj.txs = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSearchTxsResult();
        if (object.totalCount !== undefined && object.totalCount !== null) message.totalCount = BigInt(object.totalCount.toString());
        if (object.count !== undefined && object.count !== null) message.count = BigInt(object.count.toString());
        if (object.pageNumber !== undefined && object.pageNumber !== null) message.pageNumber = BigInt(object.pageNumber.toString());
        if (object.pageTotal !== undefined && object.pageTotal !== null) message.pageTotal = BigInt(object.pageTotal.toString());
        if (object.limit !== undefined && object.limit !== null) message.limit = BigInt(object.limit.toString());
        message.txs = object.txs?.map((e)=>exports.TxResponse.fromPartial(e)) || [];
        return message;
    }
};
function createBaseSearchBlocksResult() {
    return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        blocks: []
    };
}
exports.SearchBlocksResult = {
    typeUrl: "/cosmos.base.abci.v1beta1.SearchBlocksResult",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) writer.uint32(8).int64(message.totalCount);
        if (message.count !== BigInt(0)) writer.uint32(16).int64(message.count);
        if (message.pageNumber !== BigInt(0)) writer.uint32(24).int64(message.pageNumber);
        if (message.pageTotal !== BigInt(0)) writer.uint32(32).int64(message.pageTotal);
        if (message.limit !== BigInt(0)) writer.uint32(40).int64(message.limit);
        for (const v of message.blocks)block_1.Block.encode(v, writer.uint32(50).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchBlocksResult();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.totalCount = reader.int64();
                    break;
                case 2:
                    message.count = reader.int64();
                    break;
                case 3:
                    message.pageNumber = reader.int64();
                    break;
                case 4:
                    message.pageTotal = reader.int64();
                    break;
                case 5:
                    message.limit = reader.int64();
                    break;
                case 6:
                    message.blocks.push(block_1.Block.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseSearchBlocksResult();
        if ((0, helpers_1.isSet)(object.totalCount)) obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count)) obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber)) obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal)) obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit)) obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object?.blocks)) obj.blocks = object.blocks.map((e)=>block_1.Block.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.totalCount !== undefined && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== undefined && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== undefined && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== undefined && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== undefined && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.blocks) obj.blocks = message.blocks.map((e)=>e ? block_1.Block.toJSON(e) : undefined);
        else obj.blocks = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSearchBlocksResult();
        if (object.totalCount !== undefined && object.totalCount !== null) message.totalCount = BigInt(object.totalCount.toString());
        if (object.count !== undefined && object.count !== null) message.count = BigInt(object.count.toString());
        if (object.pageNumber !== undefined && object.pageNumber !== null) message.pageNumber = BigInt(object.pageNumber.toString());
        if (object.pageTotal !== undefined && object.pageTotal !== null) message.pageTotal = BigInt(object.pageTotal.toString());
        if (object.limit !== undefined && object.limit !== null) message.limit = BigInt(object.limit.toString());
        message.blocks = object.blocks?.map((e)=>block_1.Block.fromPartial(e)) || [];
        return message;
    }
};

},{"b783c16c5be5c6b5":"56aJC","ce88b8ab5211b2b5":"7FclI","99e02b06da42ffd5":"kLm0D","ebaead1120eef81":"bi36x","7607380dc68ed3d1":"eYjRL"}],"kLm0D":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Block = exports.protobufPackage = void 0;
/* eslint-disable */ const types_1 = require("b3878d5dd0b85882");
const evidence_1 = require("268bacec18d93ada");
const binary_1 = require("a9cc09d913c43b2c");
const helpers_1 = require("4c69e6936b71202");
exports.protobufPackage = "tendermint.types";
function createBaseBlock() {
    return {
        header: types_1.Header.fromPartial({}),
        data: types_1.Data.fromPartial({}),
        evidence: evidence_1.EvidenceList.fromPartial({}),
        lastCommit: undefined
    };
}
exports.Block = {
    typeUrl: "/tendermint.types.Block",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== undefined) types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        if (message.data !== undefined) types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        if (message.evidence !== undefined) evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        if (message.lastCommit !== undefined) types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.header = types_1.Header.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.data = types_1.Data.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseBlock();
        if ((0, helpers_1.isSet)(object.header)) obj.header = types_1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.data)) obj.data = types_1.Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.evidence)) obj.evidence = evidence_1.EvidenceList.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.lastCommit)) obj.lastCommit = types_1.Commit.fromJSON(object.lastCommit);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.header !== undefined && (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);
        message.data !== undefined && (obj.data = message.data ? types_1.Data.toJSON(message.data) : undefined);
        message.evidence !== undefined && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : undefined);
        message.lastCommit !== undefined && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseBlock();
        if (object.header !== undefined && object.header !== null) message.header = types_1.Header.fromPartial(object.header);
        if (object.data !== undefined && object.data !== null) message.data = types_1.Data.fromPartial(object.data);
        if (object.evidence !== undefined && object.evidence !== null) message.evidence = evidence_1.EvidenceList.fromPartial(object.evidence);
        if (object.lastCommit !== undefined && object.lastCommit !== null) message.lastCommit = types_1.Commit.fromPartial(object.lastCommit);
        return message;
    }
};

},{"b3878d5dd0b85882":"9y1Fs","268bacec18d93ada":"3WEYE","a9cc09d913c43b2c":"bi36x","4c69e6936b71202":"eYjRL"}],"3WEYE":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvidenceList = exports.LightClientAttackEvidence = exports.DuplicateVoteEvidence = exports.Evidence = exports.protobufPackage = void 0;
/* eslint-disable */ const types_1 = require("3b725bcb61515158");
const timestamp_1 = require("5fdb7f4fa2eb5813");
const validator_1 = require("d7f47a3e599bd775");
const binary_1 = require("1670d12f41a139e6");
const helpers_1 = require("13ae1cc09502a685");
exports.protobufPackage = "tendermint.types";
function createBaseEvidence() {
    return {
        duplicateVoteEvidence: undefined,
        lightClientAttackEvidence: undefined
    };
}
exports.Evidence = {
    typeUrl: "/tendermint.types.Evidence",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.duplicateVoteEvidence !== undefined) exports.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
        if (message.lightClientAttackEvidence !== undefined) exports.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.lightClientAttackEvidence = exports.LightClientAttackEvidence.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseEvidence();
        if ((0, helpers_1.isSet)(object.duplicateVoteEvidence)) obj.duplicateVoteEvidence = exports.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence);
        if ((0, helpers_1.isSet)(object.lightClientAttackEvidence)) obj.lightClientAttackEvidence = exports.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.duplicateVoteEvidence !== undefined && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : undefined);
        message.lightClientAttackEvidence !== undefined && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEvidence();
        if (object.duplicateVoteEvidence !== undefined && object.duplicateVoteEvidence !== null) message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence);
        if (object.lightClientAttackEvidence !== undefined && object.lightClientAttackEvidence !== null) message.lightClientAttackEvidence = exports.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence);
        return message;
    }
};
function createBaseDuplicateVoteEvidence() {
    return {
        voteA: undefined,
        voteB: undefined,
        totalVotingPower: BigInt(0),
        validatorPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.DuplicateVoteEvidence = {
    typeUrl: "/tendermint.types.DuplicateVoteEvidence",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteA !== undefined) types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
        if (message.voteB !== undefined) types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
        if (message.totalVotingPower !== BigInt(0)) writer.uint32(24).int64(message.totalVotingPower);
        if (message.validatorPower !== BigInt(0)) writer.uint32(32).int64(message.validatorPower);
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDuplicateVoteEvidence();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.voteA = types_1.Vote.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.voteB = types_1.Vote.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.totalVotingPower = reader.int64();
                    break;
                case 4:
                    message.validatorPower = reader.int64();
                    break;
                case 5:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseDuplicateVoteEvidence();
        if ((0, helpers_1.isSet)(object.voteA)) obj.voteA = types_1.Vote.fromJSON(object.voteA);
        if ((0, helpers_1.isSet)(object.voteB)) obj.voteB = types_1.Vote.fromJSON(object.voteB);
        if ((0, helpers_1.isSet)(object.totalVotingPower)) obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.validatorPower)) obj.validatorPower = BigInt(object.validatorPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.voteA !== undefined && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : undefined);
        message.voteB !== undefined && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : undefined);
        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.validatorPower !== undefined && (obj.validatorPower = (message.validatorPower || BigInt(0)).toString());
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDuplicateVoteEvidence();
        if (object.voteA !== undefined && object.voteA !== null) message.voteA = types_1.Vote.fromPartial(object.voteA);
        if (object.voteB !== undefined && object.voteB !== null) message.voteB = types_1.Vote.fromPartial(object.voteB);
        if (object.totalVotingPower !== undefined && object.totalVotingPower !== null) message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if (object.validatorPower !== undefined && object.validatorPower !== null) message.validatorPower = BigInt(object.validatorPower.toString());
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        return message;
    }
};
function createBaseLightClientAttackEvidence() {
    return {
        conflictingBlock: undefined,
        commonHeight: BigInt(0),
        byzantineValidators: [],
        totalVotingPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.LightClientAttackEvidence = {
    typeUrl: "/tendermint.types.LightClientAttackEvidence",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.conflictingBlock !== undefined) types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
        if (message.commonHeight !== BigInt(0)) writer.uint32(16).int64(message.commonHeight);
        for (const v of message.byzantineValidators)validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.totalVotingPower !== BigInt(0)) writer.uint32(32).int64(message.totalVotingPower);
        if (message.timestamp !== undefined) timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLightClientAttackEvidence();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.commonHeight = reader.int64();
                    break;
                case 3:
                    message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.totalVotingPower = reader.int64();
                    break;
                case 5:
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseLightClientAttackEvidence();
        if ((0, helpers_1.isSet)(object.conflictingBlock)) obj.conflictingBlock = types_1.LightBlock.fromJSON(object.conflictingBlock);
        if ((0, helpers_1.isSet)(object.commonHeight)) obj.commonHeight = BigInt(object.commonHeight.toString());
        if (Array.isArray(object?.byzantineValidators)) obj.byzantineValidators = object.byzantineValidators.map((e)=>validator_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.totalVotingPower)) obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp)) obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.conflictingBlock !== undefined && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : undefined);
        message.commonHeight !== undefined && (obj.commonHeight = (message.commonHeight || BigInt(0)).toString());
        if (message.byzantineValidators) obj.byzantineValidators = message.byzantineValidators.map((e)=>e ? validator_1.Validator.toJSON(e) : undefined);
        else obj.byzantineValidators = [];
        message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.timestamp !== undefined && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseLightClientAttackEvidence();
        if (object.conflictingBlock !== undefined && object.conflictingBlock !== null) message.conflictingBlock = types_1.LightBlock.fromPartial(object.conflictingBlock);
        if (object.commonHeight !== undefined && object.commonHeight !== null) message.commonHeight = BigInt(object.commonHeight.toString());
        message.byzantineValidators = object.byzantineValidators?.map((e)=>validator_1.Validator.fromPartial(e)) || [];
        if (object.totalVotingPower !== undefined && object.totalVotingPower !== null) message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if (object.timestamp !== undefined && object.timestamp !== null) message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        return message;
    }
};
function createBaseEvidenceList() {
    return {
        evidence: []
    };
}
exports.EvidenceList = {
    typeUrl: "/tendermint.types.EvidenceList",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.evidence)exports.Evidence.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvidenceList();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.evidence.push(exports.Evidence.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseEvidenceList();
        if (Array.isArray(object?.evidence)) obj.evidence = object.evidence.map((e)=>exports.Evidence.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        if (message.evidence) obj.evidence = message.evidence.map((e)=>e ? exports.Evidence.toJSON(e) : undefined);
        else obj.evidence = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEvidenceList();
        message.evidence = object.evidence?.map((e)=>exports.Evidence.fromPartial(e)) || [];
        return message;
    }
};

},{"3b725bcb61515158":"9y1Fs","5fdb7f4fa2eb5813":"6J6bq","d7f47a3e599bd775":"5jJLR","1670d12f41a139e6":"bi36x","13ae1cc09502a685":"eYjRL"}],"68SrM":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
exports.createVestingAminoConverters = createVestingAminoConverters;
function isAminoMsgCreateVestingAccount(msg) {
    return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
}
function createVestingAminoConverters() {
    return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
            aminoType: "cosmos-sdk/MsgCreateVestingAccount",
            toAmino: ({ fromAddress, toAddress, amount, endTime, delayed })=>({
                    from_address: fromAddress,
                    to_address: toAddress,
                    amount: [
                        ...amount
                    ],
                    end_time: endTime.toString(),
                    delayed: delayed
                }),
            fromAmino: ({ from_address, to_address, amount, end_time, delayed })=>({
                    fromAddress: from_address,
                    toAddress: to_address,
                    amount: [
                        ...amount
                    ],
                    endTime: BigInt(end_time),
                    delayed: delayed
                })
        }
    };
}

},{}],"gnu9X":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.vestingTypes = void 0;
const tx_1 = require("cd640d8d77f59d82");
exports.vestingTypes = [
    [
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        tx_1.MsgCreateVestingAccount
    ]
];

},{"cd640d8d77f59d82":"2ETSl"}],"2ETSl":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgCreatePeriodicVestingAccountResponse = exports.MsgCreatePeriodicVestingAccount = exports.MsgCreatePermanentLockedAccountResponse = exports.MsgCreatePermanentLockedAccount = exports.MsgCreateVestingAccountResponse = exports.MsgCreateVestingAccount = exports.protobufPackage = void 0;
/* eslint-disable */ const coin_1 = require("9a1ae176843c4d94");
const vesting_1 = require("b23dbe9bc2d3e952");
const binary_1 = require("66d8f7ec142b858a");
const helpers_1 = require("9becdbc15b670967");
exports.protobufPackage = "cosmos.vesting.v1beta1";
function createBaseMsgCreateVestingAccount() {
    return {
        fromAddress: "",
        toAddress: "",
        amount: [],
        endTime: BigInt(0),
        delayed: false
    };
}
exports.MsgCreateVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") writer.uint32(10).string(message.fromAddress);
        if (message.toAddress !== "") writer.uint32(18).string(message.toAddress);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        if (message.endTime !== BigInt(0)) writer.uint32(32).int64(message.endTime);
        if (message.delayed === true) writer.uint32(40).bool(message.delayed);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fromAddress = reader.string();
                    break;
                case 2:
                    message.toAddress = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.endTime = reader.int64();
                    break;
                case 5:
                    message.delayed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreateVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress)) obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress)) obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime)) obj.endTime = BigInt(object.endTime.toString());
        if ((0, helpers_1.isSet)(object.delayed)) obj.delayed = Boolean(object.delayed);
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        message.endTime !== undefined && (obj.endTime = (message.endTime || BigInt(0)).toString());
        message.delayed !== undefined && (obj.delayed = message.delayed);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreateVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        if (object.endTime !== undefined && object.endTime !== null) message.endTime = BigInt(object.endTime.toString());
        message.delayed = object.delayed ?? false;
        return message;
    }
};
function createBaseMsgCreateVestingAccountResponse() {
    return {};
}
exports.MsgCreateVestingAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccountResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCreateVestingAccountResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCreateVestingAccountResponse();
        return message;
    }
};
function createBaseMsgCreatePermanentLockedAccount() {
    return {
        fromAddress: "",
        toAddress: "",
        amount: []
    };
}
exports.MsgCreatePermanentLockedAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") writer.uint32(10).string(message.fromAddress);
        if (message.toAddress !== "") writer.uint32(18).string(message.toAddress);
        for (const v of message.amount)coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fromAddress = reader.string();
                    break;
                case 2:
                    message.toAddress = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreatePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.fromAddress)) obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress)) obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount)) obj.amount = object.amount.map((e)=>coin_1.Coin.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
        if (message.amount) obj.amount = message.amount.map((e)=>e ? coin_1.Coin.toJSON(e) : undefined);
        else obj.amount = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreatePermanentLockedAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e)=>coin_1.Coin.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgCreatePermanentLockedAccountResponse() {
    return {};
}
exports.MsgCreatePermanentLockedAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCreatePermanentLockedAccountResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        return message;
    }
};
function createBaseMsgCreatePeriodicVestingAccount() {
    return {
        fromAddress: "",
        toAddress: "",
        startTime: BigInt(0),
        vestingPeriods: []
    };
}
exports.MsgCreatePeriodicVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
    encode (message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") writer.uint32(10).string(message.fromAddress);
        if (message.toAddress !== "") writer.uint32(18).string(message.toAddress);
        if (message.startTime !== BigInt(0)) writer.uint32(24).int64(message.startTime);
        for (const v of message.vestingPeriods)vesting_1.Period.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fromAddress = reader.string();
                    break;
                case 2:
                    message.toAddress = reader.string();
                    break;
                case 3:
                    message.startTime = reader.int64();
                    break;
                case 4:
                    message.vestingPeriods.push(vesting_1.Period.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        const obj = createBaseMsgCreatePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress)) obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress)) obj.toAddress = String(object.toAddress);
        if ((0, helpers_1.isSet)(object.startTime)) obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object?.vestingPeriods)) obj.vestingPeriods = object.vestingPeriods.map((e)=>vesting_1.Period.fromJSON(e));
        return obj;
    },
    toJSON (message) {
        const obj = {};
        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
        message.startTime !== undefined && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) obj.vestingPeriods = message.vestingPeriods.map((e)=>e ? vesting_1.Period.toJSON(e) : undefined);
        else obj.vestingPeriods = [];
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMsgCreatePeriodicVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        if (object.startTime !== undefined && object.startTime !== null) message.startTime = BigInt(object.startTime.toString());
        message.vestingPeriods = object.vestingPeriods?.map((e)=>vesting_1.Period.fromPartial(e)) || [];
        return message;
    }
};
function createBaseMsgCreatePeriodicVestingAccountResponse() {
    return {};
}
exports.MsgCreatePeriodicVestingAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
    encode (_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        const obj = createBaseMsgCreatePeriodicVestingAccountResponse();
        return obj;
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        return message;
    }
};
class MsgClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.CreateVestingAccount = this.CreateVestingAccount.bind(this);
        this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this);
        this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
    }
    CreateVestingAccount(request) {
        const data = exports.MsgCreateVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", data);
        return promise.then((data)=>exports.MsgCreateVestingAccountResponse.decode(new binary_1.BinaryReader(data)));
    }
    CreatePermanentLockedAccount(request) {
        const data = exports.MsgCreatePermanentLockedAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", data);
        return promise.then((data)=>exports.MsgCreatePermanentLockedAccountResponse.decode(new binary_1.BinaryReader(data)));
    }
    CreatePeriodicVestingAccount(request) {
        const data = exports.MsgCreatePeriodicVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", data);
        return promise.then((data)=>exports.MsgCreatePeriodicVestingAccountResponse.decode(new binary_1.BinaryReader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;

},{"9a1ae176843c4d94":"1ymyZ","b23dbe9bc2d3e952":"5O0Qj","66d8f7ec142b858a":"bi36x","9becdbc15b670967":"eYjRL"}],"2rnY4":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeCompactBitArray = makeCompactBitArray;
exports.makeMultisignedTx = makeMultisignedTx;
exports.makeMultisignedTxBytes = makeMultisignedTxBytes;
const amino_1 = require("807f6875489f0954");
const encoding_1 = require("35d32ae722bcd339");
const proto_signing_1 = require("4c9110c09d2f2b4");
const multisig_1 = require("43ac917190ad6a15");
const signing_1 = require("d0635c851675e3d7");
const tx_1 = require("bcf743f91880f87");
function makeCompactBitArray(bits) {
    const byteCount = Math.ceil(bits.length / 8);
    const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
    const bytes = new Uint8Array(byteCount); // zero-filled
    bits.forEach((value, index)=>{
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        // eslint-disable-next-line no-bitwise
        if (value) bytes[bytePos] |= 1 << 7 - bitPos;
    });
    return multisig_1.CompactBitArray.fromPartial({
        elems: bytes,
        extraBitsStored: extraBits
    });
}
/**
 * Creates a signed transaction from signer info, transaction body and signatures.
 * The result can be broadcasted after serialization.
 *
 * Consider using `makeMultisignedTxBytes` instead if you want to broadcast the
 * transaction immediately.
 */ function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
    const addresses = Array.from(signatures.keys());
    const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
    const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
    const signaturesList = new Array();
    for(let i = 0; i < multisigPubkey.value.pubkeys.length; i++){
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
            signers[i] = true;
            signaturesList.push(signature);
        }
    }
    const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
            multi: {
                bitarray: makeCompactBitArray(signers),
                modeInfos: signaturesList.map((_)=>({
                        single: {
                            mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON
                        }
                    }))
            }
        },
        sequence: BigInt(sequence)
    };
    const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [
            signerInfo
        ],
        fee: {
            amount: [
                ...fee.amount
            ],
            gasLimit: BigInt(fee.gas)
        }
    });
    const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
    const signedTx = tx_1.TxRaw.fromPartial({
        bodyBytes: bodyBytes,
        authInfoBytes: authInfoBytes,
        signatures: [
            multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({
                signatures: signaturesList
            })).finish()
        ]
    });
    return signedTx;
}
/**
 * Creates a signed transaction from signer info, transaction body and signatures.
 * The result can be broadcasted.
 *
 * This is a wrapper around `makeMultisignedTx` that encodes the transaction for broadcasting.
 */ function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
    const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
    return Uint8Array.from(tx_1.TxRaw.encode(signedTx).finish());
}

},{"807f6875489f0954":"bh8mf","35d32ae722bcd339":"enCPS","4c9110c09d2f2b4":"2gdyE","43ac917190ad6a15":"aenYD","d0635c851675e3d7":"9PT9z","bcf743f91880f87":"dbom9"}],"8KORu":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSearchTxQueryArray = isSearchTxQueryArray;
function isSearchTxQueryArray(query) {
    return Array.isArray(query);
}

},{}],"hcImJ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SigningStargateClient = exports.defaultRegistryTypes = void 0;
exports.createDefaultAminoConverters = createDefaultAminoConverters;
const amino_1 = require("31e0661139ff1576");
const encoding_1 = require("e294fe9e04ca7ac4");
const math_1 = require("7031337ca1cc07d0");
const proto_signing_1 = require("2274a514966a25fc");
const tendermint_rpc_1 = require("39c92f721c90ab77");
const utils_1 = require("211db5f59271def6");
const coin_1 = require("989bccadfb254523");
const tx_1 = require("52e094cf19f9360b");
const tx_2 = require("b87c4ff764f451ed");
const signing_1 = require("7c2165410b8e1f39");
const tx_3 = require("b847defa6ec6c92b");
const tx_4 = require("55b85b588337a995");
const aminotypes_1 = require("d6b86478e429c365");
const fee_1 = require("7aa89ccaeac0f77");
const modules_1 = require("15648a4e57b249da");
const stargateclient_1 = require("cbe94b2ecfca9e55");
exports.defaultRegistryTypes = [
    [
        "/cosmos.base.v1beta1.Coin",
        coin_1.Coin
    ],
    ...modules_1.authzTypes,
    ...modules_1.bankTypes,
    ...modules_1.distributionTypes,
    ...modules_1.feegrantTypes,
    ...modules_1.govTypes,
    ...modules_1.groupTypes,
    ...modules_1.stakingTypes,
    ...modules_1.ibcTypes,
    ...modules_1.vestingTypes
];
function createDefaultAminoConverters() {
    return {
        ...(0, modules_1.createAuthzAminoConverters)(),
        ...(0, modules_1.createBankAminoConverters)(),
        ...(0, modules_1.createDistributionAminoConverters)(),
        ...(0, modules_1.createGovAminoConverters)(),
        ...(0, modules_1.createStakingAminoConverters)(),
        ...(0, modules_1.createIbcAminoConverters)(),
        ...(0, modules_1.createFeegrantAminoConverters)(),
        ...(0, modules_1.createVestingAminoConverters)()
    };
}
class SigningStargateClient extends stargateclient_1.StargateClient {
    registry;
    broadcastTimeoutMs;
    broadcastPollIntervalMs;
    signer;
    aminoTypes;
    gasPrice;
    // Starting with Cosmos SDK 0.47, we see many cases in which 1.3 is not enough anymore
    // E.g. https://github.com/cosmos/cosmos-sdk/issues/16020
    defaultGasMultiplier = 1.4;
    /**
     * Creates an instance by connecting to the given CometBFT RPC endpoint.
     *
     * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
     * To set the Comet client explicitly, use `createWithSigner`.
     */ static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return SigningStargateClient.createWithSigner(cometClient, signer, options);
    }
    /**
     * Creates an instance from a manually created Comet client.
     * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
     */ static createWithSigner(cometClient, signer, options = {}) {
        return new SigningStargateClient(cometClient, signer, options);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */ static async offline(signer, options = {}) {
        return new SigningStargateClient(undefined, signer, options);
    }
    constructor(cometClient, signer, options){
        super(cometClient, options);
        const { registry = new proto_signing_1.Registry(exports.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
    }
    async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m)=>this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account)=>account.address === signerAddress);
        if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
    }
    async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
            typeUrl: "/cosmos.bank.v1beta1.MsgSend",
            value: {
                fromAddress: senderAddress,
                toAddress: recipientAddress,
                amount: [
                    ...amount
                ]
            }
        };
        return this.signAndBroadcast(senderAddress, [
            sendMsg
        ], fee, memo);
    }
    async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
            typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
            value: tx_2.MsgDelegate.fromPartial({
                delegatorAddress: delegatorAddress,
                validatorAddress: validatorAddress,
                amount: amount
            })
        };
        return this.signAndBroadcast(delegatorAddress, [
            delegateMsg
        ], fee, memo);
    }
    async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
            typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
            value: tx_2.MsgUndelegate.fromPartial({
                delegatorAddress: delegatorAddress,
                validatorAddress: validatorAddress,
                amount: amount
            })
        };
        return this.signAndBroadcast(delegatorAddress, [
            undelegateMsg
        ], fee, memo);
    }
    async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
            typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
            value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
                delegatorAddress: delegatorAddress,
                validatorAddress: validatorAddress
            })
        };
        return this.signAndBroadcast(delegatorAddress, [
            withdrawMsg
        ], fee, memo);
    }
    /**
     * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
     * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
     * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
     * @see https://github.com/cosmos/cosmjs/issues/1493
     */ async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, /** timeout in seconds */ timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1000000000) : undefined;
        const transferMsg = {
            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
            value: tx_4.MsgTransfer.fromPartial({
                sourcePort: sourcePort,
                sourceChannel: sourceChannel,
                sender: senderAddress,
                receiver: recipientAddress,
                token: transferAmount,
                timeoutHeight: timeoutHeight,
                timeoutTimestamp: timeoutTimestampNanoseconds
            })
        };
        return this.signAndBroadcast(senderAddress, [
            transferMsg
        ], fee, memo);
    }
    async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
            (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
            const gasEstimation = await this.simulate(signerAddress, messages, memo);
            const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
            usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else usedFee = fee;
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, undefined, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    /**
     * This method is useful if you want to send a transaction in broadcast,
     * without waiting for it to be placed inside a block, because for example
     * I would like to receive the hash to later track the transaction with another tool.
     * @returns Returns the hash of the transaction
     */ async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
            (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
            const gasEstimation = await this.simulate(signerAddress, messages, memo);
            const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
            usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else usedFee = fee;
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, undefined, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */ async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) signerData = explicitSignerData;
        else {
            const { accountNumber, sequence } = await this.getSequence(signerAddress);
            const chainId = await this.getChainId();
            signerData = {
                accountNumber: accountNumber,
                sequence: sequence,
                chainId: chainId
            };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
    }
    async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account)=>account.address === signerAddress);
        if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg)=>this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
            messages: signed.msgs.map((msg)=>this.aminoTypes.fromAmino(msg)),
            memo: signed.memo,
            timeoutHeight: timeoutHeight
        };
        const signedTxBodyEncodeObject = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([
            {
                pubkey,
                sequence: signedSequence
            }
        ], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
            bodyBytes: signedTxBodyBytes,
            authInfoBytes: signedAuthInfoBytes,
            signatures: [
                (0, encoding_1.fromBase64)(signature.signature)
            ]
        });
    }
    async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account)=>account.address === signerAddress);
        if (!accountFromSigner) throw new Error("Failed to retrieve account from signer");
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: {
                messages: messages,
                memo: memo,
                timeoutHeight: timeoutHeight
            }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([
            {
                pubkey,
                sequence
            }
        ], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
            bodyBytes: signed.bodyBytes,
            authInfoBytes: signed.authInfoBytes,
            signatures: [
                (0, encoding_1.fromBase64)(signature.signature)
            ]
        });
    }
}
exports.SigningStargateClient = SigningStargateClient;

},{"31e0661139ff1576":"bh8mf","e294fe9e04ca7ac4":"enCPS","7031337ca1cc07d0":"e8aug","2274a514966a25fc":"2gdyE","39c92f721c90ab77":"5uMVU","211db5f59271def6":"3R4mb","989bccadfb254523":"1ymyZ","52e094cf19f9360b":"1bSSP","b87c4ff764f451ed":"j0J9T","7c2165410b8e1f39":"9PT9z","b847defa6ec6c92b":"dbom9","55b85b588337a995":"gBIkp","d6b86478e429c365":"7vdok","7aa89ccaeac0f77":"3phn0","15648a4e57b249da":"MIuAK","cbe94b2ecfca9e55":"f7GTj"}],"5uMVU":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
var addresses_1 = require("62248650177e7ce7");
Object.defineProperty(exports, "pubkeyToAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.pubkeyToAddress;
    }
});
Object.defineProperty(exports, "pubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.pubkeyToRawAddress;
    }
});
Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.rawEd25519PubkeyToRawAddress;
    }
});
Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.rawSecp256k1PubkeyToRawAddress;
    }
});
var dates_1 = require("f115db6f59af97ef");
Object.defineProperty(exports, "DateTime", {
    enumerable: true,
    get: function() {
        return dates_1.DateTime;
    }
});
Object.defineProperty(exports, "fromRfc3339WithNanoseconds", {
    enumerable: true,
    get: function() {
        return dates_1.fromRfc3339WithNanoseconds;
    }
});
Object.defineProperty(exports, "fromSeconds", {
    enumerable: true,
    get: function() {
        return dates_1.fromSeconds;
    }
});
Object.defineProperty(exports, "toRfc3339WithNanoseconds", {
    enumerable: true,
    get: function() {
        return dates_1.toRfc3339WithNanoseconds;
    }
});
Object.defineProperty(exports, "toSeconds", {
    enumerable: true,
    get: function() {
        return dates_1.toSeconds;
    }
});
// The public Tendermint34Client.create constructor allows manually choosing an RpcClient.
// This is currently the only way to switch to the HttpBatchClient (which may become default at some point).
// Due to this API, we make RPC client implementations public.
exports.comet38 = __importStar(require("42d8779815cc3a5d"));
var comet38_1 = require("42d8779815cc3a5d");
Object.defineProperty(exports, "Comet38Client", {
    enumerable: true,
    get: function() {
        return comet38_1.Comet38Client;
    }
});
var rpcclients_1 = require("ad670adc291495c1");
Object.defineProperty(exports, "HttpBatchClient", {
    enumerable: true,
    get: function() {
        return rpcclients_1.HttpBatchClient;
    }
});
Object.defineProperty(exports, "HttpClient", {
    enumerable: true,
    get: function() {
        return rpcclients_1.HttpClient;
    }
});
Object.defineProperty(exports, "WebsocketClient", {
    enumerable: true,
    get: function() {
        return rpcclients_1.WebsocketClient;
    }
});
var tendermint34_1 = require("3b4866bd9f2733a9");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return tendermint34_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return tendermint34_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return tendermint34_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return tendermint34_1.SubscriptionEventType;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return tendermint34_1.VoteType;
    }
});
exports.tendermint34 = __importStar(require("3b4866bd9f2733a9"));
var tendermint34_2 = require("3b4866bd9f2733a9");
Object.defineProperty(exports, "Tendermint34Client", {
    enumerable: true,
    get: function() {
        return tendermint34_2.Tendermint34Client;
    }
});
exports.tendermint37 = __importStar(require("7534e0b652148a3e"));
var tendermint37_1 = require("7534e0b652148a3e");
Object.defineProperty(exports, "Tendermint37Client", {
    enumerable: true,
    get: function() {
        return tendermint37_1.Tendermint37Client;
    }
});
var tendermintclient_1 = require("3ae92cb16271a7e");
Object.defineProperty(exports, "connectComet", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.connectComet;
    }
});
Object.defineProperty(exports, "isComet38Client", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.isComet38Client;
    }
});
Object.defineProperty(exports, "isTendermint34Client", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.isTendermint34Client;
    }
});
Object.defineProperty(exports, "isTendermint37Client", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.isTendermint37Client;
    }
});
var types_1 = require("ca36ff487c5eb4f8");
Object.defineProperty(exports, "BlockIdFlag", {
    enumerable: true,
    get: function() {
        return types_1.BlockIdFlag;
    }
});

},{"62248650177e7ce7":"jYKKI","f115db6f59af97ef":"aYDXm","42d8779815cc3a5d":"cDSHN","ad670adc291495c1":"4i1Up","3b4866bd9f2733a9":"ieXXt","7534e0b652148a3e":"aFn6G","3ae92cb16271a7e":"7IF1D","ca36ff487c5eb4f8":"f88Rz"}],"jYKKI":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
exports.pubkeyToRawAddress = pubkeyToRawAddress;
exports.pubkeyToAddress = pubkeyToAddress;
const crypto_1 = require("220c38e6ed1f6065");
const encoding_1 = require("550a5f99facb3d1b");
function rawEd25519PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 32) throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
}
function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 33) throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
    return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
}
/**
 * Returns Tendermint address as bytes.
 *
 * This is for addresses that are derived by the Tendermint keypair (typically Ed25519).
 * Sometimes those addresses are bech32-encoded and contain the term "cons" in the presix
 * ("cosmosvalcons1...").
 *
 * For secp256k1 this assumes we already have a compressed pubkey, which is the default in Cosmos.
 */ function pubkeyToRawAddress(type, data) {
    switch(type){
        case "ed25519":
            return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
            return rawSecp256k1PubkeyToRawAddress(data);
        default:
            // Keep this case here to guard against new types being added but not handled
            throw new Error(`Pubkey type ${type} not supported`);
    }
}
/**
 * Returns Tendermint address in uppercase hex format.
 *
 * This is for addresses that are derived by the Tendermint keypair (typically Ed25519).
 * Sometimes those addresses are bech32-encoded and contain the term "cons" in the presix
 * ("cosmosvalcons1...").
 *
 * For secp256k1 this assumes we already have a compressed pubkey, which is the default in Cosmos.
 */ function pubkeyToAddress(type, data) {
    return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
}

},{"220c38e6ed1f6065":"kTd5b","550a5f99facb3d1b":"enCPS"}],"aYDXm":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DateTime = void 0;
exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
exports.fromSeconds = fromSeconds;
exports.toSeconds = toSeconds;
const encoding_1 = require("111764ecd25f9a4d");
const math_1 = require("74d7b7343c0e2025");
function fromRfc3339WithNanoseconds(dateTimeString) {
    const out = (0, encoding_1.fromRfc3339)(dateTimeString);
    const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
    const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
    out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
    return out;
}
function toRfc3339WithNanoseconds(dateTime) {
    const millisecondIso = dateTime.toISOString();
    const nanoseconds = dateTime.nanoseconds?.toString() ?? "";
    return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
}
function fromSeconds(seconds, nanos = 0) {
    const checkedNanos = new math_1.Uint32(nanos).toNumber();
    if (checkedNanos > 999999999) throw new Error("Nano seconds must not exceed 999999999");
    const out = new Date(seconds * 1000 + Math.floor(checkedNanos / 1000000));
    out.nanoseconds = checkedNanos % 1000000;
    return out;
}
/**
 * Calculates the UNIX timestamp in seconds as well as the nanoseconds after the given second.
 *
 * This is useful when dealing with external systems like the protobuf type
 * [.google.protobuf.Timestamp](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp)
 * or any other system that does not use millisecond precision.
 */ function toSeconds(date) {
    return {
        seconds: Math.floor(date.getTime() / 1000),
        nanos: date.getTime() % 1000 * 1000000 + (date.nanoseconds ?? 0)
    };
}
/** @deprecated Use fromRfc3339WithNanoseconds/toRfc3339WithNanoseconds instead */ class DateTime {
    /** @deprecated Use fromRfc3339WithNanoseconds instead */ static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
    }
    /** @deprecated Use toRfc3339WithNanoseconds instead */ static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
    }
}
exports.DateTime = DateTime;

},{"111764ecd25f9a4d":"enCPS","74d7b7343c0e2025":"e8aug"}],"cDSHN":[function(require,module,exports,__globalThis) {
"use strict";
// Note: all exports in this module are publicly available via
// `import { comet38 } from "@cosmjs/tendermint-rpc"`
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
var comet38client_1 = require("da7398c6c7d99edf");
Object.defineProperty(exports, "Comet38Client", {
    enumerable: true,
    get: function() {
        return comet38client_1.Comet38Client;
    }
});
var requests_1 = require("2c97e8cc16f14a24");
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return requests_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return requests_1.SubscriptionEventType;
    }
});
var responses_1 = require("696eef692ea20b56");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return responses_1.VoteType;
    }
});

},{"da7398c6c7d99edf":"gDzM3","2c97e8cc16f14a24":"5SK7W","696eef692ea20b56":"g2GwE"}],"gDzM3":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Comet38Client = void 0;
const rpcclients_1 = require("ae32dce873d9f5f4");
const adaptor_1 = require("dde6fe04864f2710");
const requests = __importStar(require("2602b4a7b22a92d7"));
/**
 * A client for the CometBFT 0.38 and 1.x RPC API
 */ class Comet38Client {
    /**
     * Creates a new Tendermint client for the given endpoint.
     *
     * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
     */ static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") rpcClient = new rpcclients_1.HttpClient(endpoint);
        else {
            const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
            rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return Comet38Client.create(rpcClient);
    }
    /**
     * Creates a new Tendermint client given an RPC client.
     */ static create(rpcClient) {
        return new Comet38Client(rpcClient);
    }
    client;
    /**
     * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
     */ constructor(client){
        this.client = client;
    }
    disconnect() {
        this.client.disconnect();
    }
    async abciInfo() {
        const query = {
            method: requests.Method.AbciInfo
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
    }
    async abciQuery(params) {
        const query = {
            params: params,
            method: requests.Method.AbciQuery
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
    }
    async block(height) {
        const query = {
            method: requests.Method.Block,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
    }
    async blockResults(height) {
        const query = {
            method: requests.Method.BlockResults,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
    }
    /**
     * Search for events that are in a block.
     *
     * NOTE
     * This method will error on any node that is running a Tendermint version lower than 0.34.9.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
     */ async blockSearch(params) {
        const query = {
            params: params,
            method: requests.Method.BlockSearch
        };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
            ...resp,
            // make sure we sort by height, as tendermint may be sorting by string value of the height
            blocks: [
                ...resp.blocks
            ].sort((a, b)=>a.block.header.height - b.block.header.height)
        };
    }
    // this should paginate through all blockSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    //
    // NOTE
    // This method will error on any node that is running a Tendermint version lower than 0.34.9.
    async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while(!done){
            const resp = await this.blockSearch({
                ...params,
                page: page
            });
            blocks.push(...resp.blocks);
            if (blocks.length < resp.totalCount) page++;
            else done = true;
        }
        // make sure we sort by height, as tendermint may be sorting by string value of the height
        // and the earlier items may be in a higher page than the later items
        blocks.sort((a, b)=>a.block.header.height - b.block.header.height);
        return {
            totalCount: blocks.length,
            blocks: blocks
        };
    }
    /**
     * Queries block headers filtered by minHeight <= height <= maxHeight.
     *
     * @param minHeight The minimum height to be included in the result. Defaults to 0.
     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
     */ async blockchain(minHeight, maxHeight) {
        const query = {
            method: requests.Method.Blockchain,
            params: {
                minHeight: minHeight,
                maxHeight: maxHeight
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
    }
    /**
     * Broadcast transaction to mempool and wait for response
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */ async broadcastTxSync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxSync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
    }
    /**
     * Broadcast transaction to mempool and do not wait for result
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */ async broadcastTxAsync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxAsync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
    }
    /**
     * Broadcast transaction to mempool and wait for block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
     */ async broadcastTxCommit(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxCommit
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
    }
    async commit(height) {
        const query = {
            method: requests.Method.Commit,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
    }
    async genesis() {
        const query = {
            method: requests.Method.Genesis
        };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
    }
    async health() {
        const query = {
            method: requests.Method.Health
        };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
    }
    async numUnconfirmedTxs() {
        const query = {
            method: requests.Method.NumUnconfirmedTxs
        };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
    }
    async status() {
        const query = {
            method: requests.Method.Status
        };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
    }
    subscribeNewBlock() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlock
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
    }
    subscribeNewBlockHeader() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlockHeader
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
    }
    subscribeTx(query) {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.Tx,
                raw: query
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
    }
    /**
     * Get a single transaction by hash
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx
     */ async tx(params) {
        const query = {
            params: params,
            method: requests.Method.Tx
        };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
    }
    /**
     * Search for transactions that are in a block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
     */ async txSearch(params) {
        const query = {
            params: params,
            method: requests.Method.TxSearch
        };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
    }
    // this should paginate through all txSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while(!done){
            const resp = await this.txSearch({
                ...params,
                page: page
            });
            txs.push(...resp.txs);
            if (txs.length < resp.totalCount) page++;
            else done = true;
        }
        return {
            totalCount: txs.length,
            txs: txs
        };
    }
    async validators(params) {
        const query = {
            method: requests.Method.Validators,
            params: params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
    }
    async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while(!done){
            const response = await this.validators({
                per_page: 50,
                height: blockHeight,
                page: page
            });
            validators.push(...response.validators);
            blockHeight = blockHeight || response.blockHeight;
            if (validators.length < response.total) page++;
            else done = true;
        }
        return {
            // NOTE: Default value is for type safety but this should always be set
            blockHeight: blockHeight ?? 0,
            count: validators.length,
            total: validators.length,
            validators: validators
        };
    }
    // doCall is a helper to handle the encode/call/decode logic
    async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
    }
    subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) throw new Error("This RPC client type cannot subscribe to events");
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event)=>{
            return decode(event);
        });
    }
}
exports.Comet38Client = Comet38Client;

},{"ae32dce873d9f5f4":"4i1Up","dde6fe04864f2710":"84KGD","2602b4a7b22a92d7":"5SK7W"}],"4i1Up":[function(require,module,exports,__globalThis) {
"use strict";
// This folder contains Tendermint-specific RPC clients
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
var httpbatchclient_1 = require("b644b6b2b114be5c");
Object.defineProperty(exports, "HttpBatchClient", {
    enumerable: true,
    get: function() {
        return httpbatchclient_1.HttpBatchClient;
    }
});
var httpclient_1 = require("9fe833a18fb6170c");
Object.defineProperty(exports, "HttpClient", {
    enumerable: true,
    get: function() {
        return httpclient_1.HttpClient;
    }
});
var rpcclient_1 = require("e1172e0e867e929b");
Object.defineProperty(exports, "instanceOfRpcStreamingClient", {
    enumerable: true,
    get: function() {
        return rpcclient_1.instanceOfRpcStreamingClient;
    }
});
var websocketclient_1 = require("49c5a082331d4dad");
Object.defineProperty(exports, "WebsocketClient", {
    enumerable: true,
    get: function() {
        return websocketclient_1.WebsocketClient;
    }
});

},{"b644b6b2b114be5c":"jnx9n","9fe833a18fb6170c":"8E6Iz","e1172e0e867e929b":"1gQhX","49c5a082331d4dad":"kKMc5"}],"jnx9n":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpBatchClient = void 0;
const json_rpc_1 = require("d137bcacc91bf54f");
const http_1 = require("e44a7d0988dd6b5");
const rpcclient_1 = require("40fbd3fe877742ac");
// Those values are private and can change any time.
// Does a user need to know them? I don't think so. You either set
// a custom value or leave the option field unset.
const defaultHttpBatchClientOptions = {
    dispatchInterval: 20,
    batchSizeLimit: 20
};
class HttpBatchClient {
    url;
    headers;
    options;
    timer;
    queue = [];
    constructor(endpoint, options = {}){
        this.options = {
            batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
            dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval,
            httpTimeout: options.httpTimeout
        };
        if (typeof endpoint === "string") {
            if (!(0, rpcclient_1.hasProtocol)(endpoint)) throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
            this.url = endpoint;
        } else {
            this.url = endpoint.url;
            this.headers = endpoint.headers;
        }
        this.timer = setInterval(()=>{
            this.tick();
        }, options.dispatchInterval);
        this.validate();
    }
    disconnect() {
        if (this.timer) clearInterval(this.timer);
        this.timer = undefined;
    }
    async execute(request) {
        return new Promise((resolve, reject)=>{
            this.queue.push({
                request,
                resolve,
                reject
            });
            if (this.queue.length >= this.options.batchSizeLimit) // this train is full, let's go
            this.tick();
        });
    }
    validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) throw new Error("batchSizeLimit must be a safe integer >= 1");
    }
    /**
     * This is called in an interval where promise rejections cannot be handled.
     * So this is not async and HTTP errors need to be handled by the queued promises.
     */ tick() {
        // Avoid race conditions
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length) return;
        const requests = batch.map((s)=>s.request);
        const requestIds = requests.map((request)=>request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests, this.options.httpTimeout).then((raw)=>{
            // Requests with a single entry return as an object
            const arr = Array.isArray(raw) ? raw : [
                raw
            ];
            arr.forEach((el)=>{
                const req = batch.find((s)=>s.request.id === el.id);
                if (!req) return;
                const { reject, resolve } = req;
                const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) reject(new Error(JSON.stringify(response.error)));
                else resolve(response);
            });
        }, (error)=>{
            for (const requestId of requestIds){
                const req = batch.find((s)=>s.request.id === requestId);
                if (!req) return;
                req.reject(error);
            }
        });
    }
}
exports.HttpBatchClient = HttpBatchClient;

},{"d137bcacc91bf54f":"7n99h","e44a7d0988dd6b5":"b9bSg","40fbd3fe877742ac":"1gQhX"}],"7n99h":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
var id_1 = require("b4cf7b27f6fe8cfe");
Object.defineProperty(exports, "makeJsonRpcId", {
    enumerable: true,
    get: function() {
        return id_1.makeJsonRpcId;
    }
});
var jsonrpcclient_1 = require("12373f6158737877");
Object.defineProperty(exports, "JsonRpcClient", {
    enumerable: true,
    get: function() {
        return jsonrpcclient_1.JsonRpcClient;
    }
});
var parse_1 = require("2fd8e05711083639");
Object.defineProperty(exports, "parseJsonRpcErrorResponse", {
    enumerable: true,
    get: function() {
        return parse_1.parseJsonRpcErrorResponse;
    }
});
Object.defineProperty(exports, "parseJsonRpcId", {
    enumerable: true,
    get: function() {
        return parse_1.parseJsonRpcId;
    }
});
Object.defineProperty(exports, "parseJsonRpcRequest", {
    enumerable: true,
    get: function() {
        return parse_1.parseJsonRpcRequest;
    }
});
Object.defineProperty(exports, "parseJsonRpcResponse", {
    enumerable: true,
    get: function() {
        return parse_1.parseJsonRpcResponse;
    }
});
Object.defineProperty(exports, "parseJsonRpcSuccessResponse", {
    enumerable: true,
    get: function() {
        return parse_1.parseJsonRpcSuccessResponse;
    }
});
var types_1 = require("82ad216469782a8a");
Object.defineProperty(exports, "isJsonRpcErrorResponse", {
    enumerable: true,
    get: function() {
        return types_1.isJsonRpcErrorResponse;
    }
});
Object.defineProperty(exports, "isJsonRpcSuccessResponse", {
    enumerable: true,
    get: function() {
        return types_1.isJsonRpcSuccessResponse;
    }
});
Object.defineProperty(exports, "jsonRpcCode", {
    enumerable: true,
    get: function() {
        return types_1.jsonRpcCode;
    }
});

},{"b4cf7b27f6fe8cfe":"bEuR1","12373f6158737877":"kaK3u","2fd8e05711083639":"1Pk23","82ad216469782a8a":"iop3D"}],"bEuR1":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeJsonRpcId = makeJsonRpcId;
// Start with 10001 to avoid possible collisions with all hand-selected values like e.g. 1,2,3,42,100
let counter = 10000;
/**
 * Creates a new ID to be used for creating a JSON-RPC request.
 *
 * Multiple calls of this produce unique values.
 *
 * The output may be any value compatible to JSON-RPC request IDs with an undefined output format and generation logic.
 */ function makeJsonRpcId() {
    return counter += 1;
}

},{}],"kaK3u":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JsonRpcClient = void 0;
const stream_1 = require("5e1650913806d849");
const types_1 = require("c827c4022f96a7ca");
/**
 * A thin wrapper that is used to bring together requests and responses by ID.
 *
 * Using this class is only advised for continuous communication channels like
 * WebSockets or WebWorker messaging.
 */ class JsonRpcClient {
    connection;
    constructor(connection){
        this.connection = connection;
    }
    async run(request) {
        const filteredStream = this.connection.responseStream.filter((r)=>r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
            const error = response.error;
            throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
    }
}
exports.JsonRpcClient = JsonRpcClient;

},{"5e1650913806d849":"9PhFZ","c827c4022f96a7ca":"iop3D"}],"9PhFZ":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
var concat_1 = require("e8a2f656a8a177eb");
Object.defineProperty(exports, "concat", {
    enumerable: true,
    get: function() {
        return concat_1.concat;
    }
});
var defaultvalueproducer_1 = require("8a3b8629690afa13");
Object.defineProperty(exports, "DefaultValueProducer", {
    enumerable: true,
    get: function() {
        return defaultvalueproducer_1.DefaultValueProducer;
    }
});
var dropduplicates_1 = require("1be3c5896e2af8cc");
Object.defineProperty(exports, "dropDuplicates", {
    enumerable: true,
    get: function() {
        return dropduplicates_1.dropDuplicates;
    }
});
var promise_1 = require("6d908172c0a60e87");
Object.defineProperty(exports, "firstEvent", {
    enumerable: true,
    get: function() {
        return promise_1.firstEvent;
    }
});
Object.defineProperty(exports, "fromListPromise", {
    enumerable: true,
    get: function() {
        return promise_1.fromListPromise;
    }
});
Object.defineProperty(exports, "toListPromise", {
    enumerable: true,
    get: function() {
        return promise_1.toListPromise;
    }
});
__exportStar(require("450bcc4d8d96e159"), exports);
var valueandupdates_1 = require("f909cb1a648e29b7");
Object.defineProperty(exports, "ValueAndUpdates", {
    enumerable: true,
    get: function() {
        return valueandupdates_1.ValueAndUpdates;
    }
});

},{"e8a2f656a8a177eb":"tnKO0","8a3b8629690afa13":"kuZ6k","1be3c5896e2af8cc":"9O9Ak","6d908172c0a60e87":"7nDhr","450bcc4d8d96e159":"iTKNa","f909cb1a648e29b7":"b9L72"}],"tnKO0":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.concat = concat;
const xstream_1 = require("6501bbdd29f96b1b");
/**
 * An implementation of concat that buffers all source stream events
 *
 * Marble diagram:
 *
 * ```text
 * --1--2---3---4-|
 * -a--b-c--d-|
 * --------X---------Y---------Z-
 *           concat
 * --1--2---3---4-abcdXY-------Z-
 * ```
 *
 * This is inspired by RxJS's concat as documented at http://rxmarbles.com/#concat and behaves
 * differently than xstream's concat as discussed in https://github.com/staltz/xstream/issues/170.
 *
 */ function concat(...streams) {
    const subscriptions = new Array();
    const queues = new Array(); // one queue per stream
    const completedStreams = new Set();
    let activeStreamIndex = 0;
    function reset() {
        while(subscriptions.length > 0){
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const subscription = subscriptions.shift();
            subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
    }
    const producer = {
        start: (listener)=>{
            streams.forEach((_)=>queues.push([]));
            function emitAllQueuesEvents(streamIndex) {
                while(true){
                    const element = queues[streamIndex].shift();
                    if (element === undefined) return;
                    listener.next(element);
                }
            }
            function isDone() {
                return activeStreamIndex >= streams.length;
            }
            if (isDone()) {
                listener.complete();
                return;
            }
            streams.forEach((stream, index)=>{
                subscriptions.push(stream.subscribe({
                    next: (value)=>{
                        if (index === activeStreamIndex) listener.next(value);
                        else queues[index].push(value);
                    },
                    complete: ()=>{
                        completedStreams.add(index);
                        while(completedStreams.has(activeStreamIndex)){
                            // this stream completed: emit all and move on
                            emitAllQueuesEvents(activeStreamIndex);
                            activeStreamIndex++;
                        }
                        if (isDone()) listener.complete();
                        else // now active stream can have some events queued but did not yet complete
                        emitAllQueuesEvents(activeStreamIndex);
                    },
                    error: (error)=>{
                        listener.error(error);
                        reset();
                    }
                }));
            });
        },
        stop: ()=>{
            reset();
        }
    };
    return xstream_1.Stream.create(producer);
}

},{"6501bbdd29f96b1b":"ikYVn"}],"ikYVn":[function(require,module,exports,__globalThis) {
"use strict";
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;
var ponyfill_1 = require("47fb3f99b983a630");
var globalthis_1 = require("f134dc7c9fc7e62c");
var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
var NO = {};
exports.NO = NO;
function noop() {}
function cp(a) {
    var l = a.length;
    var b = Array(l);
    for(var i = 0; i < l; ++i)b[i] = a[i];
    return b;
}
function and(f1, f2) {
    return function andFn(t) {
        return f1(t) && f2(t);
    };
}
function _try(c, t, u) {
    try {
        return c.f(t);
    } catch (e) {
        u._e(e);
        return NO;
    }
}
var NO_IL = {
    _n: noop,
    _e: noop,
    _c: noop
};
exports.NO_IL = NO_IL;
// mutates the input
function internalizeProducer(producer) {
    producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
    };
    producer._stop = producer.stop;
}
var StreamSub = /** @class */ function() {
    function StreamSub(_stream, _listener) {
        this._stream = _stream;
        this._listener = _listener;
    }
    StreamSub.prototype.unsubscribe = function() {
        this._stream._remove(this._listener);
    };
    return StreamSub;
}();
var Observer = /** @class */ function() {
    function Observer(_listener) {
        this._listener = _listener;
    }
    Observer.prototype.next = function(value) {
        this._listener._n(value);
    };
    Observer.prototype.error = function(err) {
        this._listener._e(err);
    };
    Observer.prototype.complete = function() {
        this._listener._c();
    };
    return Observer;
}();
var FromObservable = /** @class */ function() {
    function FromObservable(observable) {
        this.type = 'fromObservable';
        this.ins = observable;
        this.active = false;
    }
    FromObservable.prototype._start = function(out) {
        this.out = out;
        this.active = true;
        this._sub = this.ins.subscribe(new Observer(out));
        if (!this.active) this._sub.unsubscribe();
    };
    FromObservable.prototype._stop = function() {
        if (this._sub) this._sub.unsubscribe();
        this.active = false;
    };
    return FromObservable;
}();
var Merge = /** @class */ function() {
    function Merge(insArr) {
        this.type = 'merge';
        this.insArr = insArr;
        this.out = NO;
        this.ac = 0;
    }
    Merge.prototype._start = function(out) {
        this.out = out;
        var s = this.insArr;
        var L = s.length;
        this.ac = L;
        for(var i = 0; i < L; i++)s[i]._add(this);
    };
    Merge.prototype._stop = function() {
        var s = this.insArr;
        var L = s.length;
        for(var i = 0; i < L; i++)s[i]._remove(this);
        this.out = NO;
    };
    Merge.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        u._n(t);
    };
    Merge.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Merge.prototype._c = function() {
        if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO) return;
            u._c();
        }
    };
    return Merge;
}();
var CombineListener = /** @class */ function() {
    function CombineListener(i, out, p) {
        this.i = i;
        this.out = out;
        this.p = p;
        p.ils.push(this);
    }
    CombineListener.prototype._n = function(t) {
        var p = this.p, out = this.out;
        if (out === NO) return;
        if (p.up(t, this.i)) {
            var b = cp(p.vals);
            out._n(b);
        }
    };
    CombineListener.prototype._e = function(err) {
        var out = this.out;
        if (out === NO) return;
        out._e(err);
    };
    CombineListener.prototype._c = function() {
        var p = this.p;
        if (p.out === NO) return;
        if (--p.Nc === 0) p.out._c();
    };
    return CombineListener;
}();
var Combine = /** @class */ function() {
    function Combine(insArr) {
        this.type = 'combine';
        this.insArr = insArr;
        this.out = NO;
        this.ils = [];
        this.Nc = this.Nn = 0;
        this.vals = [];
    }
    Combine.prototype.up = function(t, i) {
        var v = this.vals[i];
        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
        this.vals[i] = t;
        return Nn === 0;
    };
    Combine.prototype._start = function(out) {
        this.out = out;
        var s = this.insArr;
        var n = this.Nc = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        if (n === 0) {
            out._n([]);
            out._c();
        } else for(var i = 0; i < n; i++){
            vals[i] = NO;
            s[i]._add(new CombineListener(i, out, this));
        }
    };
    Combine.prototype._stop = function() {
        var s = this.insArr;
        var n = s.length;
        var ils = this.ils;
        for(var i = 0; i < n; i++)s[i]._remove(ils[i]);
        this.out = NO;
        this.ils = [];
        this.vals = [];
    };
    return Combine;
}();
var FromArray = /** @class */ function() {
    function FromArray(a) {
        this.type = 'fromArray';
        this.a = a;
    }
    FromArray.prototype._start = function(out) {
        var a = this.a;
        for(var i = 0, n = a.length; i < n; i++)out._n(a[i]);
        out._c();
    };
    FromArray.prototype._stop = function() {};
    return FromArray;
}();
var FromPromise = /** @class */ function() {
    function FromPromise(p) {
        this.type = 'fromPromise';
        this.on = false;
        this.p = p;
    }
    FromPromise.prototype._start = function(out) {
        var prod = this;
        this.on = true;
        this.p.then(function(v) {
            if (prod.on) {
                out._n(v);
                out._c();
            }
        }, function(e) {
            out._e(e);
        }).then(noop, function(err) {
            setTimeout(function() {
                throw err;
            });
        });
    };
    FromPromise.prototype._stop = function() {
        this.on = false;
    };
    return FromPromise;
}();
var Periodic = /** @class */ function() {
    function Periodic(period) {
        this.type = 'periodic';
        this.period = period;
        this.intervalID = -1;
        this.i = 0;
    }
    Periodic.prototype._start = function(out) {
        var self = this;
        function intervalHandler() {
            out._n(self.i++);
        }
        this.intervalID = setInterval(intervalHandler, this.period);
    };
    Periodic.prototype._stop = function() {
        if (this.intervalID !== -1) clearInterval(this.intervalID);
        this.intervalID = -1;
        this.i = 0;
    };
    return Periodic;
}();
var Debug = /** @class */ function() {
    function Debug(ins, arg) {
        this.type = 'debug';
        this.ins = ins;
        this.out = NO;
        this.s = noop;
        this.l = '';
        if (typeof arg === 'string') this.l = arg;
        else if (typeof arg === 'function') this.s = arg;
    }
    Debug.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
    };
    Debug.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
    };
    Debug.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        var s = this.s, l = this.l;
        if (s !== noop) try {
            s(t);
        } catch (e) {
            u._e(e);
        }
        else if (l) console.log(l + ':', t);
        else console.log(t);
        u._n(t);
    };
    Debug.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Debug.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return Debug;
}();
var Drop = /** @class */ function() {
    function Drop(max, ins) {
        this.type = 'drop';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.dropped = 0;
    }
    Drop.prototype._start = function(out) {
        this.out = out;
        this.dropped = 0;
        this.ins._add(this);
    };
    Drop.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
    };
    Drop.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        if (this.dropped++ >= this.max) u._n(t);
    };
    Drop.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Drop.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return Drop;
}();
var EndWhenListener = /** @class */ function() {
    function EndWhenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    EndWhenListener.prototype._n = function() {
        this.op.end();
    };
    EndWhenListener.prototype._e = function(err) {
        this.out._e(err);
    };
    EndWhenListener.prototype._c = function() {
        this.op.end();
    };
    return EndWhenListener;
}();
var EndWhen = /** @class */ function() {
    function EndWhen(o, ins) {
        this.type = 'endWhen';
        this.ins = ins;
        this.out = NO;
        this.o = o;
        this.oil = NO_IL;
    }
    EndWhen.prototype._start = function(out) {
        this.out = out;
        this.o._add(this.oil = new EndWhenListener(out, this));
        this.ins._add(this);
    };
    EndWhen.prototype._stop = function() {
        this.ins._remove(this);
        this.o._remove(this.oil);
        this.out = NO;
        this.oil = NO_IL;
    };
    EndWhen.prototype.end = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    EndWhen.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        u._n(t);
    };
    EndWhen.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    EndWhen.prototype._c = function() {
        this.end();
    };
    return EndWhen;
}();
var Filter = /** @class */ function() {
    function Filter(passes, ins) {
        this.type = 'filter';
        this.ins = ins;
        this.out = NO;
        this.f = passes;
    }
    Filter.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
    };
    Filter.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
    };
    Filter.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        var r = _try(this, t, u);
        if (r === NO || !r) return;
        u._n(t);
    };
    Filter.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Filter.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return Filter;
}();
var FlattenListener = /** @class */ function() {
    function FlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    FlattenListener.prototype._n = function(t) {
        this.out._n(t);
    };
    FlattenListener.prototype._e = function(err) {
        this.out._e(err);
    };
    FlattenListener.prototype._c = function() {
        this.op.inner = NO;
        this.op.less();
    };
    return FlattenListener;
}();
var Flatten = /** @class */ function() {
    function Flatten(ins) {
        this.type = 'flatten';
        this.ins = ins;
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    }
    Flatten.prototype._start = function(out) {
        this.out = out;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
        this.ins._add(this);
    };
    Flatten.prototype._stop = function() {
        this.ins._remove(this);
        if (this.inner !== NO) this.inner._remove(this.il);
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    };
    Flatten.prototype.less = function() {
        var u = this.out;
        if (u === NO) return;
        if (!this.open && this.inner === NO) u._c();
    };
    Flatten.prototype._n = function(s) {
        var u = this.out;
        if (u === NO) return;
        var _a = this, inner = _a.inner, il = _a.il;
        if (inner !== NO && il !== NO_IL) inner._remove(il);
        (this.inner = s)._add(this.il = new FlattenListener(u, this));
    };
    Flatten.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Flatten.prototype._c = function() {
        this.open = false;
        this.less();
    };
    return Flatten;
}();
var Fold = /** @class */ function() {
    function Fold(f, seed, ins) {
        var _this = this;
        this.type = 'fold';
        this.ins = ins;
        this.out = NO;
        this.f = function(t) {
            return f(_this.acc, t);
        };
        this.acc = this.seed = seed;
    }
    Fold.prototype._start = function(out) {
        this.out = out;
        this.acc = this.seed;
        out._n(this.acc);
        this.ins._add(this);
    };
    Fold.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
        this.acc = this.seed;
    };
    Fold.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        var r = _try(this, t, u);
        if (r === NO) return;
        u._n(this.acc = r);
    };
    Fold.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Fold.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return Fold;
}();
var Last = /** @class */ function() {
    function Last(ins) {
        this.type = 'last';
        this.ins = ins;
        this.out = NO;
        this.has = false;
        this.val = NO;
    }
    Last.prototype._start = function(out) {
        this.out = out;
        this.has = false;
        this.ins._add(this);
    };
    Last.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
        this.val = NO;
    };
    Last.prototype._n = function(t) {
        this.has = true;
        this.val = t;
    };
    Last.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Last.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        if (this.has) {
            u._n(this.val);
            u._c();
        } else u._e(new Error('last() failed because input stream completed'));
    };
    return Last;
}();
var MapOp = /** @class */ function() {
    function MapOp(project, ins) {
        this.type = 'map';
        this.ins = ins;
        this.out = NO;
        this.f = project;
    }
    MapOp.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
    };
    MapOp.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
    };
    MapOp.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        var r = _try(this, t, u);
        if (r === NO) return;
        u._n(r);
    };
    MapOp.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    MapOp.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return MapOp;
}();
var Remember = /** @class */ function() {
    function Remember(ins) {
        this.type = 'remember';
        this.ins = ins;
        this.out = NO;
    }
    Remember.prototype._start = function(out) {
        this.out = out;
        this.ins._add(out);
    };
    Remember.prototype._stop = function() {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return Remember;
}();
var ReplaceError = /** @class */ function() {
    function ReplaceError(replacer, ins) {
        this.type = 'replaceError';
        this.ins = ins;
        this.out = NO;
        this.f = replacer;
    }
    ReplaceError.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
    };
    ReplaceError.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
    };
    ReplaceError.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        u._n(t);
    };
    ReplaceError.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
        } catch (e) {
            u._e(e);
        }
    };
    ReplaceError.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return ReplaceError;
}();
var StartWith = /** @class */ function() {
    function StartWith(ins, val) {
        this.type = 'startWith';
        this.ins = ins;
        this.out = NO;
        this.val = val;
    }
    StartWith.prototype._start = function(out) {
        this.out = out;
        this.out._n(this.val);
        this.ins._add(out);
    };
    StartWith.prototype._stop = function() {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return StartWith;
}();
var Take = /** @class */ function() {
    function Take(max, ins) {
        this.type = 'take';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.taken = 0;
    }
    Take.prototype._start = function(out) {
        this.out = out;
        this.taken = 0;
        if (this.max <= 0) out._c();
        else this.ins._add(this);
    };
    Take.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
    };
    Take.prototype._n = function(t) {
        var u = this.out;
        if (u === NO) return;
        var m = ++this.taken;
        if (m < this.max) u._n(t);
        else if (m === this.max) {
            u._n(t);
            u._c();
        }
    };
    Take.prototype._e = function(err) {
        var u = this.out;
        if (u === NO) return;
        u._e(err);
    };
    Take.prototype._c = function() {
        var u = this.out;
        if (u === NO) return;
        u._c();
    };
    return Take;
}();
var Stream = /** @class */ function() {
    function Stream(producer) {
        this._prod = producer || NO;
        this._ils = [];
        this._stopID = NO;
        this._dl = NO;
        this._d = false;
        this._target = null;
        this._err = NO;
    }
    Stream.prototype._n = function(t) {
        var a = this._ils;
        var L = a.length;
        if (this._d) this._dl._n(t);
        if (L == 1) a[0]._n(t);
        else if (L == 0) return;
        else {
            var b = cp(a);
            for(var i = 0; i < L; i++)b[i]._n(t);
        }
    };
    Stream.prototype._e = function(err) {
        if (this._err !== NO) return;
        this._err = err;
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d) this._dl._e(err);
        if (L == 1) a[0]._e(err);
        else if (L == 0) return;
        else {
            var b = cp(a);
            for(var i = 0; i < L; i++)b[i]._e(err);
        }
        if (!this._d && L == 0) throw this._err;
    };
    Stream.prototype._c = function() {
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d) this._dl._c();
        if (L == 1) a[0]._c();
        else if (L == 0) return;
        else {
            var b = cp(a);
            for(var i = 0; i < L; i++)b[i]._c();
        }
    };
    Stream.prototype._x = function() {
        if (this._ils.length === 0) return;
        if (this._prod !== NO) this._prod._stop();
        this._err = NO;
        this._ils = [];
    };
    Stream.prototype._stopNow = function() {
        // WARNING: code that calls this method should
        // first check if this._prod is valid (not `NO`)
        this._prod._stop();
        this._err = NO;
        this._stopID = NO;
    };
    Stream.prototype._add = function(il) {
        var ta = this._target;
        if (ta) return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) return;
        if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
        } else {
            var p = this._prod;
            if (p !== NO) p._start(this);
        }
    };
    Stream.prototype._remove = function(il) {
        var _this = this;
        var ta = this._target;
        if (ta) return ta._remove(il);
        var a = this._ils;
        var i = a.indexOf(il);
        if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
                this._err = NO;
                this._stopID = setTimeout(function() {
                    return _this._stopNow();
                });
            } else if (a.length === 1) this._pruneCycles();
        }
    };
    // If all paths stemming from `this` stream eventually end at `this`
    // stream, then we remove the single listener of `this` stream, to
    // force it to end its execution and dispose resources. This method
    // assumes as a precondition that this._ils has just one listener.
    Stream.prototype._pruneCycles = function() {
        if (this._hasNoSinks(this, [])) this._remove(this._ils[0]);
    };
    // Checks whether *there is no* path starting from `x` that leads to an end
    // listener (sink) in the stream graph, following edges A->B where B is a
    // listener of A. This means these paths constitute a cycle somehow. Is given
    // a trace of all visited nodes so far.
    Stream.prototype._hasNoSinks = function(x, trace) {
        if (trace.indexOf(x) !== -1) return true;
        else if (x.out === this) return true;
        else if (x.out && x.out !== NO) return this._hasNoSinks(x.out, trace.concat(x));
        else if (x._ils) {
            for(var i = 0, N = x._ils.length; i < N; i++)if (!this._hasNoSinks(x._ils[i], trace.concat(x))) return false;
            return true;
        } else return false;
    };
    Stream.prototype.ctor = function() {
        return this instanceof MemoryStream ? MemoryStream : Stream;
    };
    /**
     * Adds a Listener to the Stream.
     *
     * @param {Listener} listener
     */ Stream.prototype.addListener = function(listener) {
        listener._n = listener.next || noop;
        listener._e = listener.error || noop;
        listener._c = listener.complete || noop;
        this._add(listener);
    };
    /**
     * Removes a Listener from the Stream, assuming the Listener was added to it.
     *
     * @param {Listener<T>} listener
     */ Stream.prototype.removeListener = function(listener) {
        this._remove(listener);
    };
    /**
     * Adds a Listener to the Stream returning a Subscription to remove that
     * listener.
     *
     * @param {Listener} listener
     * @returns {Subscription}
     */ Stream.prototype.subscribe = function(listener) {
        this.addListener(listener);
        return new StreamSub(this, listener);
    };
    /**
     * Add interop between most.js and RxJS 5
     *
     * @returns {Stream}
     */ Stream.prototype[$$observable] = function() {
        return this;
    };
    /**
     * Creates a new Stream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {Stream}
     */ Stream.create = function(producer) {
        if (producer) {
            if (typeof producer.start !== 'function' || typeof producer.stop !== 'function') throw new Error('producer requires both start and stop functions');
            internalizeProducer(producer); // mutates the input
        }
        return new Stream(producer);
    };
    /**
     * Creates a new MemoryStream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {MemoryStream}
     */ Stream.createWithMemory = function(producer) {
        if (producer) internalizeProducer(producer); // mutates the input
        return new MemoryStream(producer);
    };
    /**
     * Creates a Stream that does nothing when started. It never emits any event.
     *
     * Marble diagram:
     *
     * ```text
     *          never
     * -----------------------
     * ```
     *
     * @factory true
     * @return {Stream}
     */ Stream.never = function() {
        return new Stream({
            _start: noop,
            _stop: noop
        });
    };
    /**
     * Creates a Stream that immediately emits the "complete" notification when
     * started, and that's it.
     *
     * Marble diagram:
     *
     * ```text
     * empty
     * -|
     * ```
     *
     * @factory true
     * @return {Stream}
     */ Stream.empty = function() {
        return new Stream({
            _start: function(il) {
                il._c();
            },
            _stop: noop
        });
    };
    /**
     * Creates a Stream that immediately emits an "error" notification with the
     * value you passed as the `error` argument when the stream starts, and that's
     * it.
     *
     * Marble diagram:
     *
     * ```text
     * throw(X)
     * -X
     * ```
     *
     * @factory true
     * @param error The error event to emit on the created stream.
     * @return {Stream}
     */ Stream.throw = function(error) {
        return new Stream({
            _start: function(il) {
                il._e(error);
            },
            _stop: noop
        });
    };
    /**
     * Creates a stream from an Array, Promise, or an Observable.
     *
     * @factory true
     * @param {Array|PromiseLike|Observable} input The input to make a stream from.
     * @return {Stream}
     */ Stream.from = function(input) {
        if (typeof input[$$observable] === 'function') return Stream.fromObservable(input);
        else if (typeof input.then === 'function') return Stream.fromPromise(input);
        else if (Array.isArray(input)) return Stream.fromArray(input);
        throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    };
    /**
     * Creates a Stream that immediately emits the arguments that you give to
     * *of*, then completes.
     *
     * Marble diagram:
     *
     * ```text
     * of(1,2,3)
     * 123|
     * ```
     *
     * @factory true
     * @param a The first value you want to emit as an event on the stream.
     * @param b The second value you want to emit as an event on the stream. One
     * or more of these values may be given as arguments.
     * @return {Stream}
     */ Stream.of = function() {
        var items = [];
        for(var _i = 0; _i < arguments.length; _i++)items[_i] = arguments[_i];
        return Stream.fromArray(items);
    };
    /**
     * Converts an array to a stream. The returned stream will emit synchronously
     * all the items in the array, and then complete.
     *
     * Marble diagram:
     *
     * ```text
     * fromArray([1,2,3])
     * 123|
     * ```
     *
     * @factory true
     * @param {Array} array The array to be converted as a stream.
     * @return {Stream}
     */ Stream.fromArray = function(array) {
        return new Stream(new FromArray(array));
    };
    /**
     * Converts a promise to a stream. The returned stream will emit the resolved
     * value of the promise, and then complete. However, if the promise is
     * rejected, the stream will emit the corresponding error.
     *
     * Marble diagram:
     *
     * ```text
     * fromPromise( ----42 )
     * -----------------42|
     * ```
     *
     * @factory true
     * @param {PromiseLike} promise The promise to be converted as a stream.
     * @return {Stream}
     */ Stream.fromPromise = function(promise) {
        return new Stream(new FromPromise(promise));
    };
    /**
     * Converts an Observable into a Stream.
     *
     * @factory true
     * @param {any} observable The observable to be converted as a stream.
     * @return {Stream}
     */ Stream.fromObservable = function(obs) {
        if (obs.endWhen !== undefined) return obs;
        var o = typeof obs[$$observable] === 'function' ? obs[$$observable]() : obs;
        return new Stream(new FromObservable(o));
    };
    /**
     * Creates a stream that periodically emits incremental numbers, every
     * `period` milliseconds.
     *
     * Marble diagram:
     *
     * ```text
     *     periodic(1000)
     * ---0---1---2---3---4---...
     * ```
     *
     * @factory true
     * @param {number} period The interval in milliseconds to use as a rate of
     * emission.
     * @return {Stream}
     */ Stream.periodic = function(period) {
        return new Stream(new Periodic(period));
    };
    Stream.prototype._map = function(project) {
        return new (this.ctor())(new MapOp(project, this));
    };
    /**
     * Transforms each event from the input Stream through a `project` function,
     * to get a Stream that emits those transformed events.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7------
     *    map(i => i * 10)
     * --10--30-50----70-----
     * ```
     *
     * @param {Function} project A function of type `(t: T) => U` that takes event
     * `t` of type `T` from the input Stream and produces an event of type `U`, to
     * be emitted on the output Stream.
     * @return {Stream}
     */ Stream.prototype.map = function(project) {
        return this._map(project);
    };
    /**
     * It's like `map`, but transforms each input event to always the same
     * constant value on the output Stream.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7-----
     *       mapTo(10)
     * --10--10-10----10----
     * ```
     *
     * @param projectedValue A value to emit on the output Stream whenever the
     * input Stream emits any value.
     * @return {Stream}
     */ Stream.prototype.mapTo = function(projectedValue) {
        var s = this.map(function() {
            return projectedValue;
        });
        var op = s._prod;
        op.type = 'mapTo';
        return s;
    };
    /**
     * Only allows events that pass the test given by the `passes` argument.
     *
     * Each event from the input stream is given to the `passes` function. If the
     * function returns `true`, the event is forwarded to the output stream,
     * otherwise it is ignored and not forwarded.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2--3-----4-----5---6--7-8--
     *     filter(i => i % 2 === 0)
     * ------2--------4---------6----8--
     * ```
     *
     * @param {Function} passes A function of type `(t: T) => boolean` that takes
     * an event from the input stream and checks if it passes, by returning a
     * boolean.
     * @return {Stream}
     */ Stream.prototype.filter = function(passes) {
        var p = this._prod;
        if (p instanceof Filter) return new Stream(new Filter(and(p.f, passes), p.ins));
        return new Stream(new Filter(passes, this));
    };
    /**
     * Lets the first `amount` many events from the input stream pass to the
     * output stream, then makes the output stream complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *    take(3)
     * --a---b--c|
     * ```
     *
     * @param {number} amount How many events to allow from the input stream
     * before completing the output stream.
     * @return {Stream}
     */ Stream.prototype.take = function(amount) {
        return new (this.ctor())(new Take(amount, this));
    };
    /**
     * Ignores the first `amount` many events from the input stream, and then
     * after that starts forwarding events from the input stream to the output
     * stream.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *       drop(3)
     * --------------d---e--
     * ```
     *
     * @param {number} amount How many events to ignore from the input stream
     * before forwarding all events from the input stream to the output stream.
     * @return {Stream}
     */ Stream.prototype.drop = function(amount) {
        return new Stream(new Drop(amount, this));
    };
    /**
     * When the input stream completes, the output stream will emit the last event
     * emitted by the input stream, and then will also complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c--d----|
     *       last()
     * -----------------d|
     * ```
     *
     * @return {Stream}
     */ Stream.prototype.last = function() {
        return new Stream(new Last(this));
    };
    /**
     * Prepends the given `initial` value to the sequence of events emitted by the
     * input stream. The returned stream is a MemoryStream, which means it is
     * already `remember()`'d.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3---
     *   startWith(0)
     * 0--1---2-----3---
     * ```
     *
     * @param initial The value or event to prepend.
     * @return {MemoryStream}
     */ Stream.prototype.startWith = function(initial) {
        return new MemoryStream(new StartWith(this, initial));
    };
    /**
     * Uses another stream to determine when to complete the current stream.
     *
     * When the given `other` stream emits an event or completes, the output
     * stream will complete. Before that happens, the output stream will behaves
     * like the input stream.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3--4----5----6---
     *   endWhen( --------a--b--| )
     * ---1---2-----3--4--|
     * ```
     *
     * @param other Some other stream that is used to know when should the output
     * stream of this operator complete.
     * @return {Stream}
     */ Stream.prototype.endWhen = function(other) {
        return new (this.ctor())(new EndWhen(other, this));
    };
    /**
     * "Folds" the stream onto itself.
     *
     * Combines events from the past throughout
     * the entire execution of the input stream, allowing you to accumulate them
     * together. It's essentially like `Array.prototype.reduce`. The returned
     * stream is a MemoryStream, which means it is already `remember()`'d.
     *
     * The output stream starts by emitting the `seed` which you give as argument.
     * Then, when an event happens on the input stream, it is combined with that
     * seed value through the `accumulate` function, and the output value is
     * emitted on the output stream. `fold` remembers that output value as `acc`
     * ("accumulator"), and then when a new input event `t` happens, `acc` will be
     * combined with that to produce the new `acc` and so forth.
     *
     * Marble diagram:
     *
     * ```text
     * ------1-----1--2----1----1------
     *   fold((acc, x) => acc + x, 3)
     * 3-----4-----5--7----8----9------
     * ```
     *
     * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that
     * takes the previous accumulated value `acc` and the incoming event from the
     * input stream and produces the new accumulated value.
     * @param seed The initial accumulated value, of type `R`.
     * @return {MemoryStream}
     */ Stream.prototype.fold = function(accumulate, seed) {
        return new MemoryStream(new Fold(accumulate, seed, this));
    };
    /**
     * Replaces an error with another stream.
     *
     * When (and if) an error happens on the input stream, instead of forwarding
     * that error to the output stream, *replaceError* will call the `replace`
     * function which returns the stream that the output stream will replicate.
     * And, in case that new stream also emits an error, `replace` will be called
     * again to get another stream to start replicating.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2-----3--4-----X
     *   replaceError( () => --10--| )
     * --1---2-----3--4--------10--|
     * ```
     *
     * @param {Function} replace A function of type `(err) => Stream` that takes
     * the error that occurred on the input stream or on the previous replacement
     * stream and returns a new stream. The output stream will behave like the
     * stream that this function returns.
     * @return {Stream}
     */ Stream.prototype.replaceError = function(replace) {
        return new (this.ctor())(new ReplaceError(replace, this));
    };
    /**
     * Flattens a "stream of streams", handling only one nested stream at a time
     * (no concurrency).
     *
     * If the input stream is a stream that emits streams, then this operator will
     * return an output stream which is a flat stream: emits regular events. The
     * flattening happens without concurrency. It works like this: when the input
     * stream emits a nested stream, *flatten* will start imitating that nested
     * one. However, as soon as the next nested stream is emitted on the input
     * stream, *flatten* will forget the previous nested one it was imitating, and
     * will start imitating the new nested one.
     *
     * Marble diagram:
     *
     * ```text
     * --+--------+---------------
     *   \        \
     *    \       ----1----2---3--
     *    --a--b----c----d--------
     *           flatten
     * -----a--b------1----2---3--
     * ```
     *
     * @return {Stream}
     */ Stream.prototype.flatten = function() {
        return new Stream(new Flatten(this));
    };
    /**
     * Passes the input stream to a custom operator, to produce an output stream.
     *
     * *compose* is a handy way of using an existing function in a chained style.
     * Instead of writing `outStream = f(inStream)` you can write
     * `outStream = inStream.compose(f)`.
     *
     * @param {function} operator A function that takes a stream as input and
     * returns a stream as well.
     * @return {Stream}
     */ Stream.prototype.compose = function(operator) {
        return operator(this);
    };
    /**
     * Returns an output stream that behaves like the input stream, but also
     * remembers the most recent event that happens on the input stream, so that a
     * newly added listener will immediately receive that memorised event.
     *
     * @return {MemoryStream}
     */ Stream.prototype.remember = function() {
        return new MemoryStream(new Remember(this));
    };
    /**
     * Returns an output stream that identically behaves like the input stream,
     * but also runs a `spy` function for each event, to help you debug your app.
     *
     * *debug* takes a `spy` function as argument, and runs that for each event
     * happening on the input stream. If you don't provide the `spy` argument,
     * then *debug* will just `console.log` each event. This helps you to
     * understand the flow of events through some operator chain.
     *
     * Please note that if the output stream has no listeners, then it will not
     * start, which means `spy` will never run because no actual event happens in
     * that case.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3-----4--
     *         debug
     * --1----2-----3-----4--
     * ```
     *
     * @param {function} labelOrSpy A string to use as the label when printing
     * debug information on the console, or a 'spy' function that takes an event
     * as argument, and does not need to return anything.
     * @return {Stream}
     */ Stream.prototype.debug = function(labelOrSpy) {
        return new (this.ctor())(new Debug(this, labelOrSpy));
    };
    /**
     * *imitate* changes this current Stream to emit the same events that the
     * `other` given Stream does. This method returns nothing.
     *
     * This method exists to allow one thing: **circular dependency of streams**.
     * For instance, let's imagine that for some reason you need to create a
     * circular dependency where stream `first$` depends on stream `second$`
     * which in turn depends on `first$`:
     *
     * <!-- skip-example -->
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var first$ = second$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * ```
     *
     * However, that is invalid JavaScript, because `second$` is undefined
     * on the first line. This is how *imitate* can help solve it:
     *
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var secondProxy$ = xs.create();
     * var first$ = secondProxy$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * secondProxy$.imitate(second$);
     * ```
     *
     * We create `secondProxy$` before the others, so it can be used in the
     * declaration of `first$`. Then, after both `first$` and `second$` are
     * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell
     * that they are "the same". `imitate` will not trigger the start of any
     * stream, it just binds `secondProxy$` and `second$` together.
     *
     * The following is an example where `imitate()` is important in Cycle.js
     * applications. A parent component contains some child components. A child
     * has an action stream which is given to the parent to define its state:
     *
     * <!-- skip-example -->
     * ```js
     * const childActionProxy$ = xs.create();
     * const parent = Parent({...sources, childAction$: childActionProxy$});
     * const childAction$ = parent.state$.map(s => s.child.action$).flatten();
     * childActionProxy$.imitate(childAction$);
     * ```
     *
     * Note, though, that **`imitate()` does not support MemoryStreams**. If we
     * would attempt to imitate a MemoryStream in a circular dependency, we would
     * either get a race condition (where the symptom would be "nothing happens")
     * or an infinite cyclic emission of values. It's useful to think about
     * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to
     * define a spreadsheet cell `A1` with a formula that depends on `B1` and
     * cell `B1` defined with a formula that depends on `A1`.
     *
     * If you find yourself wanting to use `imitate()` with a
     * MemoryStream, you should rework your code around `imitate()` to use a
     * Stream instead. Look for the stream in the circular dependency that
     * represents an event stream, and that would be a candidate for creating a
     * proxy Stream which then imitates the target Stream.
     *
     * @param {Stream} target The other stream to imitate on the current one. Must
     * not be a MemoryStream.
     */ Stream.prototype.imitate = function(target) {
        if (target instanceof MemoryStream) throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
        this._target = target;
        for(var ils = this._ils, N = ils.length, i = 0; i < N; i++)target._add(ils[i]);
        this._ils = [];
    };
    /**
     * Forces the Stream to emit the given value to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param value The "next" value you want to broadcast to all listeners of
     * this Stream.
     */ Stream.prototype.shamefullySendNext = function(value) {
        this._n(value);
    };
    /**
     * Forces the Stream to emit the given error to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param {any} error The error you want to broadcast to all the listeners of
     * this Stream.
     */ Stream.prototype.shamefullySendError = function(error) {
        this._e(error);
    };
    /**
     * Forces the Stream to emit the "completed" event to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     */ Stream.prototype.shamefullySendComplete = function() {
        this._c();
    };
    /**
     * Adds a "debug" listener to the stream. There can only be one debug
     * listener, that's why this is 'setDebugListener'. To remove the debug
     * listener, just call setDebugListener(null).
     *
     * A debug listener is like any other listener. The only difference is that a
     * debug listener is "stealthy": its presence/absence does not trigger the
     * start/stop of the stream (or the producer inside the stream). This is
     * useful so you can inspect what is going on without changing the behavior
     * of the program. If you have an idle stream and you add a normal listener to
     * it, the stream will start executing. But if you set a debug listener on an
     * idle stream, it won't start executing (not until the first normal listener
     * is added).
     *
     * As the name indicates, we don't recommend using this method to build app
     * logic. In fact, in most cases the debug operator works just fine. Only use
     * this one if you know what you're doing.
     *
     * @param {Listener<T>} listener
     */ Stream.prototype.setDebugListener = function(listener) {
        if (!listener) {
            this._d = false;
            this._dl = NO;
        } else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
        }
    };
    /**
     * Blends multiple streams together, emitting events from all of them
     * concurrently.
     *
     * *merge* takes multiple streams as arguments, and creates a stream that
     * behaves like each of the argument streams, in parallel.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3--------4---
     * ----a-----b----c---d------
     *            merge
     * --1-a--2--b--3-c---d--4---
     * ```
     *
     * @factory true
     * @param {Stream} stream1 A stream to merge together with other streams.
     * @param {Stream} stream2 A stream to merge together with other streams. Two
     * or more streams may be given as arguments.
     * @return {Stream}
     */ Stream.merge = function merge() {
        var streams = [];
        for(var _i = 0; _i < arguments.length; _i++)streams[_i] = arguments[_i];
        return new Stream(new Merge(streams));
    };
    /**
     * Combines multiple input streams together to return a stream whose events
     * are arrays that collect the latest events from each input stream.
     *
     * *combine* internally remembers the most recent event from each of the input
     * streams. When any of the input streams emits an event, that event together
     * with all the other saved events are combined into an array. That array will
     * be emitted on the output stream. It's essentially a way of joining together
     * the events from multiple streams.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3--------4---
     * ----a-----b-----c--d------
     *          combine
     * ----1a-2a-2b-3b-3c-3d-4d--
     * ```
     *
     * @factory true
     * @param {Stream} stream1 A stream to combine together with other streams.
     * @param {Stream} stream2 A stream to combine together with other streams.
     * Multiple streams, not just two, may be given as arguments.
     * @return {Stream}
     */ Stream.combine = function combine() {
        var streams = [];
        for(var _i = 0; _i < arguments.length; _i++)streams[_i] = arguments[_i];
        return new Stream(new Combine(streams));
    };
    return Stream;
}();
exports.Stream = Stream;
var MemoryStream = /** @class */ function(_super) {
    __extends(MemoryStream, _super);
    function MemoryStream(producer) {
        var _this = _super.call(this, producer) || this;
        _this._has = false;
        return _this;
    }
    MemoryStream.prototype._n = function(x) {
        this._v = x;
        this._has = true;
        _super.prototype._n.call(this, x);
    };
    MemoryStream.prototype._add = function(il) {
        var ta = this._target;
        if (ta) return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) {
            if (this._has) il._n(this._v);
            return;
        }
        if (this._stopID !== NO) {
            if (this._has) il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
        } else if (this._has) il._n(this._v);
        else {
            var p = this._prod;
            if (p !== NO) p._start(this);
        }
    };
    MemoryStream.prototype._stopNow = function() {
        this._has = false;
        _super.prototype._stopNow.call(this);
    };
    MemoryStream.prototype._x = function() {
        this._has = false;
        _super.prototype._x.call(this);
    };
    MemoryStream.prototype.map = function(project) {
        return this._map(project);
    };
    MemoryStream.prototype.mapTo = function(projectedValue) {
        return _super.prototype.mapTo.call(this, projectedValue);
    };
    MemoryStream.prototype.take = function(amount) {
        return _super.prototype.take.call(this, amount);
    };
    MemoryStream.prototype.endWhen = function(other) {
        return _super.prototype.endWhen.call(this, other);
    };
    MemoryStream.prototype.replaceError = function(replace) {
        return _super.prototype.replaceError.call(this, replace);
    };
    MemoryStream.prototype.remember = function() {
        return this;
    };
    MemoryStream.prototype.debug = function(labelOrSpy) {
        return _super.prototype.debug.call(this, labelOrSpy);
    };
    return MemoryStream;
}(Stream);
exports.MemoryStream = MemoryStream;
var xs = Stream;
exports.default = xs;

},{"47fb3f99b983a630":"ktjOm","f134dc7c9fc7e62c":"5M38u"}],"ktjOm":[function(require,module,exports,__globalThis) {
module.exports = require("9c7e22dd72d05c8b");

},{"9c7e22dd72d05c8b":"91GYP"}],"91GYP":[function(require,module,exports,__globalThis) {
'use strict';
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
    var result;
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) result = _Symbol.observable;
        else {
            // This just needs to be something that won't trample other user's Symbol.for use
            // It also will guide people to the source of their issues, if this is problematic.
            // META: It's a resource locator!
            result = _Symbol['for']('https://github.com/benlesh/symbol-observable');
            try {
                _Symbol.observable = result;
            } catch (err) {
            // Do nothing. In some environments, users have frozen `Symbol` for security reasons,
            // if it is frozen assigning to it will throw. In this case, we don't care, because
            // they will need to use the returned value from the ponyfill.
            }
        }
    } else result = '@@observable';
    return result;
}

},{}],"5M38u":[function(require,module,exports,__globalThis) {
'use strict';
var defineProperties = require("a3eb713dcd22d");
var implementation = require("afe321e0481e4722");
var getPolyfill = require("94e08febd028f123");
var shim = require("ff5cb9c2a8320d41");
var polyfill = getPolyfill();
var getGlobal = function() {
    return polyfill;
};
defineProperties(getGlobal, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = getGlobal;

},{"a3eb713dcd22d":"3Yhek","afe321e0481e4722":"flLWY","94e08febd028f123":"eFzPR","ff5cb9c2a8320d41":"gkbV3"}],"3Yhek":[function(require,module,exports,__globalThis) {
'use strict';
var keys = require("7ff177585d1618f0");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = require("84ca194f5a28ce70");
var isFunction = function(fn) {
    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};
var supportsDescriptors = require("c52d62086511583f")();
var defineProperty = function(object, name, value, predicate) {
    if (name in object) {
        if (predicate === true) {
            if (object[name] === value) return;
        } else if (!isFunction(predicate) || !predicate()) return;
    }
    if (supportsDescriptors) defineDataProperty(object, name, value, true);
    else defineDataProperty(object, name, value);
};
var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) props = concat.call(props, Object.getOwnPropertySymbols(map));
    for(var i = 0; i < props.length; i += 1)defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

},{"7ff177585d1618f0":"7YJS9","84ca194f5a28ce70":"2ObKB","c52d62086511583f":"7jqWN"}],"7YJS9":[function(require,module,exports,__globalThis) {
'use strict';
var slice = Array.prototype.slice;
var isArgs = require("93e8460f624c96f4");
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
} : require("344bb0d7b2568e03");
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
        var keysWorksWithArguments = function() {
            // Safari 5.0 bug
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) Object.keys = function keys(object) {
            if (isArgs(object)) return originalKeys(slice.call(object));
            return originalKeys(object);
        };
    } else Object.keys = keysShim;
    return Object.keys || keysShim;
};
module.exports = keysShim;

},{"93e8460f624c96f4":"i0JRI","344bb0d7b2568e03":"2bKUd"}],"i0JRI":[function(require,module,exports,__globalThis) {
'use strict';
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === '[object Arguments]';
    if (!isArgs) isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
    return isArgs;
};

},{}],"2bKUd":[function(require,module,exports,__globalThis) {
'use strict';
var keysShim;
if (!Object.keys) {
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = require("b0d8c8b84be91ffd"); // eslint-disable-line global-require
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
        toString: null
    }, 'toString');
    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
    };
    var hasAutomationEqualityBug = function() {
        /* global window */ if (typeof window === 'undefined') return false;
        for(var k in window)try {
            if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') try {
                equalsConstructorPrototype(window[k]);
            } catch (e) {
                return true;
            }
        } catch (e) {
            return true;
        }
        return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
        try {
            return equalsConstructorPrototype(o);
        } catch (e) {
            return false;
        }
    };
    keysShim = function keys(object) {
        var isObject = object !== null && typeof object === 'object';
        var isFunction = toStr.call(object) === '[object Function]';
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === '[object String]';
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) throw new TypeError('Object.keys called on a non-object');
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) for(var i = 0; i < object.length; ++i)theKeys.push(String(i));
        if (isArguments && object.length > 0) for(var j = 0; j < object.length; ++j)theKeys.push(String(j));
        else {
            for(var name in object)if (!(skipProto && name === 'prototype') && has.call(object, name)) theKeys.push(String(name));
        }
        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for(var k = 0; k < dontEnums.length; ++k)if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) theKeys.push(dontEnums[k]);
        }
        return theKeys;
    };
}
module.exports = keysShim;

},{"b0d8c8b84be91ffd":"i0JRI"}],"2ObKB":[function(require,module,exports,__globalThis) {
'use strict';
var $defineProperty = require("f17fd23367965521");
var $SyntaxError = require("50f12088ee0f6bb");
var $TypeError = require("45c79de2b2f9c949");
var gopd = require("3f9bd39335781ec7");
/** @type {import('.')} */ module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') throw new $TypeError('`obj` must be an object or a function`');
    if (typeof property !== 'string' && typeof property !== 'symbol') throw new $TypeError('`property` must be a string or a symbol`');
    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') throw new $TypeError('`loose`, if provided, must be a boolean');
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value: value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
    else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
    else throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
};

},{"f17fd23367965521":"lLFQB","50f12088ee0f6bb":"c6rW6","45c79de2b2f9c949":"izd0l","3f9bd39335781ec7":"3RG4k"}],"lLFQB":[function(require,module,exports,__globalThis) {
'use strict';
/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) try {
    $defineProperty({}, 'a', {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
}
module.exports = $defineProperty;

},{}],"c6rW6":[function(require,module,exports,__globalThis) {
'use strict';
/** @type {import('./syntax')} */ module.exports = SyntaxError;

},{}],"izd0l":[function(require,module,exports,__globalThis) {
'use strict';
/** @type {import('./type')} */ module.exports = TypeError;

},{}],"3RG4k":[function(require,module,exports,__globalThis) {
'use strict';
/** @type {import('.')} */ var $gOPD = require("2065a078be813600");
if ($gOPD) try {
    $gOPD([], 'length');
} catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
}
module.exports = $gOPD;

},{"2065a078be813600":"gSPq2"}],"gSPq2":[function(require,module,exports,__globalThis) {
'use strict';
/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;

},{}],"7jqWN":[function(require,module,exports,__globalThis) {
'use strict';
var $defineProperty = require("1c3b0ce871129f60");
var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!$defineProperty) return null;
    try {
        return $defineProperty([], 'length', {
            value: 1
        }).length !== 1;
    } catch (e) {
        // In Firefox 4-22, defining length on an array throws an exception.
        return true;
    }
};
module.exports = hasPropertyDescriptors;

},{"1c3b0ce871129f60":"lLFQB"}],"flLWY":[function(require,module,exports,__globalThis) {
/* eslint no-negated-condition: 0, no-new-func: 0 */ 'use strict';
if (typeof self !== 'undefined') module.exports = self;
else if (typeof window !== 'undefined') module.exports = window;
else module.exports = Function('return this')();

},{}],"eFzPR":[function(require,module,exports,__globalThis) {
var global = arguments[3];
'use strict';
var implementation = require("fb113d0ba8699b03");
module.exports = function getPolyfill() {
    if (typeof global !== 'object' || !global || global.Math !== Math || global.Array !== Array) return implementation;
    return global;
};

},{"fb113d0ba8699b03":"flLWY"}],"gkbV3":[function(require,module,exports,__globalThis) {
'use strict';
var define = require("eac8749572f6f344");
var gOPD = require("cd7e12906bf35b70");
var getPolyfill = require("680f27145a8c5913");
module.exports = function shimGlobal() {
    var polyfill = getPolyfill();
    if (define.supportsDescriptors) {
        var descriptor = gOPD(polyfill, 'globalThis');
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) Object.defineProperty(polyfill, 'globalThis', {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
        });
    } else if (typeof globalThis !== 'object' || globalThis !== polyfill) polyfill.globalThis = polyfill;
    return polyfill;
};

},{"eac8749572f6f344":"3Yhek","cd7e12906bf35b70":"3RG4k","680f27145a8c5913":"eFzPR"}],"kuZ6k":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultValueProducer = void 0;
// allows pre-producing values before anyone is listening
class DefaultValueProducer {
    get value() {
        return this.internalValue;
    }
    callbacks;
    internalValue;
    listener;
    constructor(value, callbacks){
        this.callbacks = callbacks;
        this.internalValue = value;
    }
    /**
     * Update the current value.
     *
     * If producer is active (i.e. someone is listening), this emits an event.
     * If not, just the current value is updated.
     */ update(value) {
        this.internalValue = value;
        if (this.listener) this.listener.next(value);
    }
    /**
     * Produce an error
     */ // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    error(error) {
        if (this.listener) this.listener.error(error);
    }
    /**
     * Called by the stream. Do not call this directly.
     */ start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) this.callbacks.onStarted();
    }
    /**
     * Called by the stream. Do not call this directly.
     */ stop() {
        if (this.callbacks) this.callbacks.onStop();
        this.listener = undefined;
    }
}
exports.DefaultValueProducer = DefaultValueProducer;

},{}],"9O9Ak":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dropDuplicates = dropDuplicates;
/**
 * Drops duplicate values in a stream.
 *
 * Marble diagram:
 *
 * ```text
 * -1-1-1-2-4-3-3-4--
 *   dropDuplicates
 * -1-----2-4-3------
 * ```
 *
 * Each value must be uniquely identified by a string given by
 * valueToKey(value).
 *
 * Internally this maintains a set of keys that have been processed already,
 * i.e. memory consumption and Set lookup times should be considered when
 * using this function.
 */ function dropDuplicates(valueToKey) {
    const operand = (instream)=>{
        const emittedKeys = new Set();
        const deduplicatedStream = instream.filter((value)=>!emittedKeys.has(valueToKey(value))).debug((value)=>emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
    };
    return operand;
}

},{}],"7nDhr":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromListPromise = fromListPromise;
exports.toListPromise = toListPromise;
exports.firstEvent = firstEvent;
const xstream_1 = require("405426eb2aec0cd6");
/**
 * Emits one event for each list element as soon as the promise resolves
 */ function fromListPromise(promise) {
    const producer = {
        start: (listener)=>{
            // the code in `start` runs as soon as anyone listens to the stream
            promise.then((iterable)=>{
                for (const element of iterable)listener.next(element);
                listener.complete();
            }).catch((error)=>{
                listener.error(error);
            });
        },
        stop: ()=>{}
    };
    return xstream_1.Stream.create(producer);
}
/**
 * Listens to stream and collects events. When `count` events are collected,
 * the promise resolves with an array of events.
 *
 * Rejects if stream completes before `count` events are collected.
 */ async function toListPromise(stream, count) {
    return new Promise((resolve, reject)=>{
        if (count === 0) {
            resolve([]);
            return;
        }
        const events = new Array();
        // take() unsubscribes from source stream automatically
        stream.take(count).subscribe({
            next: (event)=>{
                events.push(event);
                if (events.length === count) resolve(events);
            },
            complete: ()=>{
                reject(`Stream completed before all events could be collected. ` + `Collected ${events.length}, expected ${count}`);
            },
            error: (error)=>{
                reject(error);
            }
        });
    });
}
/**
 * Listens to stream, collects one event and revolves.
 *
 * Rejects if stream completes before one event was fired.
 */ async function firstEvent(stream) {
    return (await toListPromise(stream, 1))[0];
}

},{"405426eb2aec0cd6":"ikYVn"}],"iTKNa":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Reducer = void 0;
exports.countStream = countStream;
exports.asArray = asArray;
exports.lastValue = lastValue;
// Reducer takes a stream of events T and a ReducerFunc, that
// materializes a state of type U.
class Reducer {
    stream;
    reducer;
    state;
    // completed maintains state of stream, resolves/rejects
    // on complete or error
    completed;
    constructor(stream, reducer, initState){
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject)=>{
            const subscription = this.stream.subscribe({
                next: (evt)=>{
                    this.state = this.reducer(this.state, evt);
                },
                complete: ()=>{
                    resolve();
                    // this must happen after resolve, to ensure stream.subscribe() has finished
                    subscription.unsubscribe();
                },
                error: (err)=>{
                    reject(err);
                    // the stream already closed on error, but unsubscribe to be safe
                    subscription.unsubscribe();
                }
            });
        });
    }
    // value returns current materialized state
    value() {
        return this.state;
    }
    // finished resolves on completed stream, rejects on stream error
    async finished() {
        return this.completed;
    }
}
exports.Reducer = Reducer;
function increment(sum, _) {
    return sum + 1;
}
// countStream returns a reducer that contains current count
// of events on the stream
function countStream(stream) {
    return new Reducer(stream, increment, 0);
}
function append(list, evt) {
    return [
        ...list,
        evt
    ];
}
// asArray maintains an array containing all events that have
// occurred on the stream
function asArray(stream) {
    return new Reducer(stream, append, []);
}
function last(_, event) {
    return event;
}
// lastValue returns the last value read from the stream, or undefined if no values sent
function lastValue(stream) {
    return new Reducer(stream, last, undefined);
}

},{}],"b9L72":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValueAndUpdates = void 0;
const xstream_1 = require("922292c276afeb7f");
/**
 * A read only wrapper around DefaultValueProducer that allows
 * to synchronously get the current value using the .value property
 * and listen to updates by subscribing to the .updates stream
 */ class ValueAndUpdates {
    updates;
    get value() {
        return this.producer.value;
    }
    producer;
    constructor(producer){
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
    }
    /**
     * Resolves as soon as search value is found.
     *
     * @param search either a value or a function that must return true when found
     * @returns the value of the update that caused the search match
     */ async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value)=>value === search;
        return new Promise((resolve, reject)=>{
            const subscription = this.updates.subscribe({
                next: (newValue)=>{
                    if (searchImplementation(newValue)) {
                        resolve(newValue);
                        // MemoryStream.subscribe() calls next with the last value.
                        // Make async to ensure the subscription exists
                        setTimeout(()=>{
                            subscription.unsubscribe();
                        }, 0);
                    }
                },
                complete: ()=>{
                    subscription.unsubscribe();
                    reject("Update stream completed without expected value");
                },
                error: (error)=>{
                    reject(error);
                }
            });
        });
    }
}
exports.ValueAndUpdates = ValueAndUpdates;

},{"922292c276afeb7f":"ikYVn"}],"iop3D":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jsonRpcCode = void 0;
exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
function isJsonRpcErrorResponse(response) {
    return typeof response.error === "object";
}
function isJsonRpcSuccessResponse(response) {
    return !isJsonRpcErrorResponse(response);
}
/**
 * Error codes as specified in JSON-RPC 2.0
 *
 * @see https://www.jsonrpc.org/specification#error_object
 */ exports.jsonRpcCode = {
    parseError: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internalError: -32603,
    // server error (Reserved for implementation-defined server-errors.):
    // -32000 to -32099
    serverError: {
        default: -32000
    }
};

},{}],"1Pk23":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseJsonRpcId = parseJsonRpcId;
exports.parseJsonRpcRequest = parseJsonRpcRequest;
exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
exports.parseJsonRpcResponse = parseJsonRpcResponse;
const compatibility_1 = require("249c82aab6dd16c2");
/**
 * Extracts ID field from request or response object.
 *
 * Returns `null` when no valid ID was found.
 */ function parseJsonRpcId(data) {
    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) throw new Error("Data must be JSON compatible dictionary");
    const id = data.id;
    if (typeof id !== "number" && typeof id !== "string") return null;
    return id;
}
function parseJsonRpcRequest(data) {
    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) throw new Error("Data must be JSON compatible dictionary");
    if (typeof data.jsonrpc !== "string") throw new Error(`Invalid "jsonrpc" field. Must be a string.`);
    if (data.jsonrpc !== "2.0") throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);
    const id = parseJsonRpcId(data);
    if (id === null) throw new Error("Invalid id field");
    const method = data.method;
    if (typeof method !== "string") throw new Error(`Invalid "method" field. Must be a string.`);
    if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) throw new Error("Invalid params field");
    return {
        jsonrpc: "2.0",
        id: id,
        method: method,
        params: data.params
    };
}
function parseError(error) {
    if (typeof error.code !== "number") throw new Error("Error property 'code' is not a number");
    if (typeof error.message !== "string") throw new Error("Error property 'message' is not a string");
    let maybeUndefinedData;
    if (error.data === undefined) maybeUndefinedData = undefined;
    else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) maybeUndefinedData = error.data;
    else throw new Error("Error property 'data' is defined but not a JSON compatible value.");
    return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== undefined ? {
            data: maybeUndefinedData
        } : {}
    };
}
/** Throws if data is not a JsonRpcErrorResponse */ function parseJsonRpcErrorResponse(data) {
    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) throw new Error("Data must be JSON compatible dictionary");
    if (data.jsonrpc !== "2.0") throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
    const id = data.id;
    if (typeof id !== "number" && typeof id !== "string" && id !== null) throw new Error("Invalid id field");
    if (typeof data.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) throw new Error("Invalid error field");
    return {
        jsonrpc: "2.0",
        id: id,
        error: parseError(data.error)
    };
}
/** Throws if data is not a JsonRpcSuccessResponse */ function parseJsonRpcSuccessResponse(data) {
    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) throw new Error("Data must be JSON compatible dictionary");
    if (data.jsonrpc !== "2.0") throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
    const id = data.id;
    if (typeof id !== "number" && typeof id !== "string") throw new Error("Invalid id field");
    if (typeof data.result === "undefined") throw new Error("Invalid result field");
    const result = data.result;
    return {
        jsonrpc: "2.0",
        id: id,
        result: result
    };
}
/**
 * Returns a JsonRpcErrorResponse if input can be parsed as a JSON-RPC error. Otherwise parses
 * input as JsonRpcSuccessResponse. Throws if input is neither a valid error nor success response.
 */ function parseJsonRpcResponse(data) {
    let response;
    try {
        response = parseJsonRpcErrorResponse(data);
    } catch (_) {
        response = parseJsonRpcSuccessResponse(data);
    }
    return response;
}

},{"249c82aab6dd16c2":"ga63C"}],"ga63C":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isJsonCompatibleValue = isJsonCompatibleValue;
exports.isJsonCompatibleArray = isJsonCompatibleArray;
exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
function isJsonCompatibleValue(value) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
    isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
    isJsonCompatibleDictionary(value)) return true;
    else return false;
}
function isJsonCompatibleArray(value) {
    if (!Array.isArray(value)) return false;
    for (const item of value){
        if (!isJsonCompatibleValue(item)) return false;
    }
    // all items okay
    return true;
}
function isJsonCompatibleDictionary(value) {
    if (typeof value !== "object" || value === null) // value must be a non-null object
    return false;
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    return Object.values(value).every(isJsonCompatibleValue);
}

},{}],"b9bSg":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.http = http;
function filterBadStatus(res) {
    if (res.status >= 400) throw new Error(`Bad status on response: ${res.status}`);
    return res;
}
/**
 * Helper to work around missing CORS support in Tendermint (https://github.com/tendermint/tendermint/pull/2800)
 *
 * For some reason, fetch does not complain about missing server-side CORS support.
 */ async function http(method, url, headers, request, timeout) {
    const settings = {
        method: method,
        body: request ? JSON.stringify(request) : undefined,
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: timeout ? AbortSignal.timeout(timeout) : undefined
    };
    return fetch(url, settings).then(filterBadStatus).then((res)=>res.json());
}

},{}],"1gQhX":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
exports.hasProtocol = hasProtocol;
function instanceOfRpcStreamingClient(client) {
    return typeof client.listen === "function";
}
// Helpers for all RPC clients
function hasProtocol(url) {
    return url.search("://") !== -1;
}

},{}],"8E6Iz":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpClient = void 0;
const json_rpc_1 = require("5acf252f444134f6");
const http_1 = require("93a74e2f0123fed4");
const rpcclient_1 = require("a6c55dc978ebe931");
class HttpClient {
    url;
    headers;
    timeout;
    constructor(endpoint, timeout){
        if (typeof endpoint === "string") {
            if (!(0, rpcclient_1.hasProtocol)(endpoint)) throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
            this.url = endpoint;
        } else {
            this.url = endpoint.url;
            this.headers = endpoint.headers;
        }
        this.timeout = timeout;
    }
    disconnect() {
    // nothing to be done
    }
    async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request, this.timeout));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) throw new Error(JSON.stringify(response.error));
        return response;
    }
}
exports.HttpClient = HttpClient;

},{"5acf252f444134f6":"7n99h","93a74e2f0123fed4":"b9bSg","a6c55dc978ebe931":"1gQhX"}],"kKMc5":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketClient = void 0;
const json_rpc_1 = require("a4b96c73d9bf8432");
const socket_1 = require("b7d2b13d376882b1");
const stream_1 = require("9b8e6516ad06add1");
const xstream_1 = require("33c2f4a1cc1686f5");
const rpcclient_1 = require("1c65d91132603bc1");
function defaultErrorHandler(error) {
    throw error;
}
function toJsonRpcResponse(message) {
    // this should never happen, but I want an alert if it does
    if (message.type !== "message") throw new Error(`Unexpected message type on websocket: ${message.type}`);
    const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
    return jsonRpcEvent;
}
class RpcEventProducer {
    request;
    socket;
    running = false;
    subscriptions = [];
    constructor(request, socket){
        this.request = request;
        this.socket = socket;
    }
    /**
     * Implementation of Producer.start
     */ start(listener) {
        if (this.running) throw Error("Already started. Please stop first before restarting.");
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
    }
    /**
     * Implementation of Producer.stop
     *
     * Called by the stream when the stream's last listener stopped listening
     * or when the producer completed.
     */ stop() {
        this.running = false;
        // Tell the server we are done in order to save resources. We cannot wait for the result.
        // This may fail when socket connection is not open, thus ignore errors in queueRequest
        const endRequest = {
            ...this.request,
            method: "unsubscribe"
        };
        try {
            this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
            if (error instanceof Error && error.message.match(/socket has disconnected/i)) ;
            else throw error;
        }
    }
    connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        // this should unsubscribe itself, so doesn't need to be removed explicitly
        const idSubscription = responseStream.filter((response)=>response.id === this.request.id).subscribe({
            next: (response)=>{
                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
                    this.closeSubscriptions();
                    listener.error(JSON.stringify(response.error));
                }
                idSubscription.unsubscribe();
            }
        });
        // this will fire on a response (success or error)
        // Tendermint adds an "#event" suffix for events that follow a previous subscription
        // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107
        const idEventSubscription = responseStream.filter((response)=>response.id === this.request.id).subscribe({
            next: (response)=>{
                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
                    this.closeSubscriptions();
                    listener.error(JSON.stringify(response.error));
                } else listener.next(response.result);
            }
        });
        // this will fire in case the websocket disconnects cleanly
        const nonResponseSubscription = responseStream.subscribe({
            error: (error)=>{
                this.closeSubscriptions();
                listener.error(error);
            },
            complete: ()=>{
                this.closeSubscriptions();
                listener.complete();
            }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
    }
    closeSubscriptions() {
        for (const subscription of this.subscriptions)subscription.unsubscribe();
        // clear unused subscriptions
        this.subscriptions = [];
    }
}
class WebsocketClient {
    url;
    socket;
    /** Same events as in socket.events but in the format we need */ jsonRpcResponseStream;
    // Lazily create streams and use the same stream when listening to the same query twice.
    //
    // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this
    // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!
    subscriptionStreams = new Map();
    constructor(baseUrl, onError = defaultErrorHandler){
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        // make sure we don't end up with ...//websocket
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
            error: (error)=>{
                onError(error);
                errorSubscription.unsubscribe();
            }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
    }
    async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) throw new Error(JSON.stringify(response.error));
        return response;
    }
    listen(request) {
        if (request.method !== "subscribe") throw new Error(`Request method must be "subscribe" to start event listening`);
        const query = request.params.query;
        if (typeof query !== "string") throw new Error("request.params.query must be a string");
        if (!this.subscriptionStreams.has(query)) {
            const producer = new RpcEventProducer(request, this.socket);
            const stream = xstream_1.Stream.create(producer);
            this.subscriptionStreams.set(query, stream);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.subscriptionStreams.get(query).filter((response)=>response.query !== undefined);
    }
    /**
     * Resolves as soon as websocket is connected. execute() queues requests automatically,
     * so this should be required for testing purposes only.
     */ async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
    }
    disconnect() {
        this.socket.disconnect();
    }
    async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r)=>r.id === id));
    }
}
exports.WebsocketClient = WebsocketClient;

},{"a4b96c73d9bf8432":"7n99h","b7d2b13d376882b1":"5OmWg","9b8e6516ad06add1":"9PhFZ","33c2f4a1cc1686f5":"ikYVn","1c65d91132603bc1":"1gQhX"}],"5OmWg":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
var queueingstreamingsocket_1 = require("e59265c3156bb734");
Object.defineProperty(exports, "ConnectionStatus", {
    enumerable: true,
    get: function() {
        return queueingstreamingsocket_1.ConnectionStatus;
    }
});
Object.defineProperty(exports, "QueueingStreamingSocket", {
    enumerable: true,
    get: function() {
        return queueingstreamingsocket_1.QueueingStreamingSocket;
    }
});
var reconnectingsocket_1 = require("e534716aecf00283");
Object.defineProperty(exports, "ReconnectingSocket", {
    enumerable: true,
    get: function() {
        return reconnectingsocket_1.ReconnectingSocket;
    }
});
var socketwrapper_1 = require("6a2fa1301e4b70d7");
Object.defineProperty(exports, "SocketWrapper", {
    enumerable: true,
    get: function() {
        return socketwrapper_1.SocketWrapper;
    }
});
var streamingsocket_1 = require("7b5f382854a62667");
Object.defineProperty(exports, "StreamingSocket", {
    enumerable: true,
    get: function() {
        return streamingsocket_1.StreamingSocket;
    }
});

},{"e59265c3156bb734":"dmj0w","e534716aecf00283":"fVgxR","6a2fa1301e4b70d7":"8qLnk","7b5f382854a62667":"i0dAK"}],"dmj0w":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
const stream_1 = require("46953e2f66a99e85");
const xstream_1 = require("ceeaa731b7c62c");
const streamingsocket_1 = require("86f6edf7f99a86d3");
var ConnectionStatus;
(function(ConnectionStatus) {
    ConnectionStatus[ConnectionStatus["Unconnected"] = 0] = "Unconnected";
    ConnectionStatus[ConnectionStatus["Connecting"] = 1] = "Connecting";
    ConnectionStatus[ConnectionStatus["Connected"] = 2] = "Connected";
    ConnectionStatus[ConnectionStatus["Disconnected"] = 3] = "Disconnected";
})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
/**
 * A wrapper around StreamingSocket that can queue requests.
 */ class QueueingStreamingSocket {
    connectionStatus;
    events;
    url;
    timeout;
    queue = [];
    socket;
    isProcessingQueue = false;
    eventProducerListener;
    connectionStatusProducer;
    reconnectedHandler;
    constructor(url, timeout = 10000, reconnectedHandler){
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
            start: (listener)=>this.eventProducerListener = listener,
            stop: ()=>this.eventProducerListener = undefined
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
            next: (event)=>{
                if (!this.eventProducerListener) throw new Error("No event producer listener set");
                this.eventProducerListener.next(event);
            },
            error: ()=>{
                this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
            }
        });
    }
    connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async ()=>{
            this.connectionStatusProducer.update(ConnectionStatus.Connected);
            return this.processQueue();
        }, ()=>{
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        });
        this.socket.connect();
    }
    disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
    }
    reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
            next: (event)=>{
                if (!this.eventProducerListener) throw new Error("No event producer listener set");
                this.eventProducerListener.next(event);
            },
            error: ()=>{
                this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
            }
        });
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.socket.connected.then(()=>{
            if (this.reconnectedHandler) this.reconnectedHandler();
        });
        this.connect();
    }
    getQueueLength() {
        return this.queue.length;
    }
    queueRequest(request) {
        this.queue.push(request);
        // We dont need to wait for the queue to be processed.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.processQueue();
    }
    async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) return;
        this.isProcessingQueue = true;
        let request;
        while(request = this.queue.shift())try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
        } catch (_error) {
            // Probably the connection is down; will try again automatically when reconnected.
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
        }
    }
}
exports.QueueingStreamingSocket = QueueingStreamingSocket;

},{"46953e2f66a99e85":"9PhFZ","ceeaa731b7c62c":"ikYVn","86f6edf7f99a86d3":"i0dAK"}],"i0dAK":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamingSocket = void 0;
const xstream_1 = require("42329ecffa1388e7");
const socketwrapper_1 = require("e319bd1633394aa6");
/**
 * A WebSocket wrapper that exposes all events as a stream.
 *
 * This underlying socket will not be closed when the stream has no listeners
 */ class StreamingSocket {
    connected;
    events;
    eventProducerListener;
    socket;
    constructor(url, timeout = 10000){
        this.socket = new socketwrapper_1.SocketWrapper(url, (event)=>{
            if (this.eventProducerListener) this.eventProducerListener.next(event);
        }, (errorEvent)=>{
            if (this.eventProducerListener) this.eventProducerListener.error(errorEvent);
        }, ()=>{
        // socket opened
        }, (closeEvent)=>{
            if (this.eventProducerListener) {
                if (closeEvent.wasClean) this.eventProducerListener.complete();
                else this.eventProducerListener.error("Socket was closed unclean");
            }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
            start: (listener)=>this.eventProducerListener = listener,
            stop: ()=>this.eventProducerListener = undefined
        };
        this.events = xstream_1.Stream.create(eventProducer);
    }
    connect() {
        this.socket.connect();
    }
    disconnect() {
        this.socket.disconnect();
    }
    async send(data) {
        return this.socket.send(data);
    }
}
exports.StreamingSocket = StreamingSocket;

},{"42329ecffa1388e7":"ikYVn","e319bd1633394aa6":"8qLnk"}],"8qLnk":[function(require,module,exports,__globalThis) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SocketWrapper = void 0;
// eslint-disable-next-line @typescript-eslint/naming-convention
const isomorphic_ws_1 = __importDefault(require("576eed8fe604db70"));
function environmentIsNodeJs() {
    return false;
}
/**
 * A thin wrapper around isomorphic-ws' WebSocket class that adds
 * - constant message/error/open/close handlers
 * - explicit connection via a connect() method
 * - type support for events
 * - handling of corner cases in the open and close behaviour
 */ class SocketWrapper {
    connected;
    connectedResolver;
    connectedRejecter;
    socket;
    timeoutId;
    closed = false;
    url;
    messageHandler;
    errorHandler;
    openHandler;
    closeHandler;
    timeout;
    constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 10000){
        this.connected = new Promise((resolve, reject)=>{
            this.connectedResolver = resolve;
            this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
    }
    /**
     * returns a promise that resolves when connection is open
     */ connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error)=>{
            this.clearTimeout();
            if (this.errorHandler) this.errorHandler(error);
        };
        socket.onmessage = (messageEvent)=>{
            this.messageHandler({
                type: messageEvent.type,
                data: messageEvent.data
            });
        };
        socket.onopen = (_)=>{
            this.clearTimeout();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.connectedResolver();
            if (this.openHandler) this.openHandler();
        };
        socket.onclose = (closeEvent)=>{
            this.closed = true;
            if (this.closeHandler) this.closeHandler(closeEvent);
        };
        const started = Date.now();
        this.timeoutId = setTimeout(()=>{
            socket.onmessage = ()=>0;
            socket.onerror = ()=>0;
            socket.onopen = ()=>0;
            socket.onclose = ()=>0;
            socket.close();
            this.socket = undefined;
            const elapsed = Math.floor(Date.now() - started);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
    }
    /**
     * Closes an established connection and aborts other connection states
     */ disconnect() {
        if (!this.socket) throw new Error("Socket undefined. This must be called after connecting.");
        this.clearTimeout();
        switch(this.socket.readyState){
            case isomorphic_ws_1.default.OPEN:
                this.socket.close(1000 /* Normal Closure */ );
                break;
            case isomorphic_ws_1.default.CLOSED:
                break;
            case isomorphic_ws_1.default.CONNECTING:
                // imitate missing abort API
                this.socket.onopen = ()=>0;
                this.socket.onclose = ()=>0;
                this.socket.onerror = ()=>0;
                this.socket.onmessage = ()=>0;
                this.socket = undefined;
                if (this.closeHandler) this.closeHandler({
                    wasClean: false,
                    code: 4001
                });
                break;
            case isomorphic_ws_1.default.CLOSING:
                break;
            default:
                throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
    }
    async send(data) {
        return new Promise((resolve, reject)=>{
            if (!this.socket) throw new Error("Socket undefined. This must be called after connecting.");
            if (this.closed) throw new Error("Socket was closed, so no data can be sent anymore.");
            // this exception should be thrown by send() automatically according to
            // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers
            if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) throw new Error("Websocket is not open");
            if (environmentIsNodeJs()) this.socket.send(data, (err)=>{
                if (err) reject(err);
                else resolve();
            });
            else {
                // Browser websocket send method does not accept a callback
                this.socket.send(data);
                resolve();
            }
        });
    }
    /**
     * Clears the timeout function, such that no timeout error will be raised anymore. This should be
     * called when the connection is established, a connection error occurred or the socket is disconnected.
     *
     * This method must not be called before `connect()`.
     * This method is idempotent.
     */ clearTimeout() {
        if (!this.timeoutId) throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        // Note: do not unset this.timeoutId to allow multiple calls to this function
        clearTimeout(this.timeoutId);
    }
}
exports.SocketWrapper = SocketWrapper;

},{"576eed8fe604db70":"3yZ4p"}],"3yZ4p":[function(require,module,exports,__globalThis) {
// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js
var global = arguments[3];
var ws = null;
if (typeof WebSocket !== 'undefined') ws = WebSocket;
else if (typeof MozWebSocket !== 'undefined') ws = MozWebSocket;
else if (typeof global !== 'undefined') ws = global.WebSocket || global.MozWebSocket;
else if (typeof window !== 'undefined') ws = window.WebSocket || window.MozWebSocket;
else if (typeof self !== 'undefined') ws = self.WebSocket || self.MozWebSocket;
module.exports = ws;

},{}],"fVgxR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReconnectingSocket = void 0;
const xstream_1 = require("8e9a9a9243277f1");
const queueingstreamingsocket_1 = require("d94b5e0176798087");
/**
 * A wrapper around QueueingStreamingSocket that reconnects automatically.
 */ class ReconnectingSocket {
    /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */ static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5000);
    }
    connectionStatus;
    events;
    socket;
    eventProducerListener;
    unconnected = true;
    disconnected = false;
    timeoutIndex = 0;
    reconnectTimeout = null;
    constructor(url, timeout = 10000, reconnectedHandler){
        const eventProducer = {
            start: (listener)=>this.eventProducerListener = listener,
            stop: ()=>this.eventProducerListener = undefined
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
            next: (event)=>{
                if (this.eventProducerListener) this.eventProducerListener.next(event);
            },
            error: (error)=>{
                if (this.eventProducerListener) this.eventProducerListener.error(error);
            }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
            next: (status)=>{
                if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) this.timeoutIndex = 0;
                if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
                    if (this.reconnectTimeout) {
                        clearTimeout(this.reconnectTimeout);
                        this.reconnectTimeout = null;
                    }
                    this.reconnectTimeout = setTimeout(()=>{
                        this.socket.reconnect();
                    }, ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
                }
            }
        });
    }
    connect() {
        if (!this.unconnected) throw new Error("Cannot connect: socket has already connected");
        this.socket.connect();
        this.unconnected = false;
    }
    disconnect() {
        if (this.unconnected) throw new Error("Cannot disconnect: socket has not yet connected");
        this.socket.disconnect();
        if (this.eventProducerListener) this.eventProducerListener.complete();
        this.disconnected = true;
    }
    queueRequest(request) {
        if (this.disconnected) throw new Error("Cannot queue request: socket has disconnected");
        this.socket.queueRequest(request);
    }
}
exports.ReconnectingSocket = ReconnectingSocket;

},{"8e9a9a9243277f1":"ikYVn","d94b5e0176798087":"dmj0w"}],"84KGD":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.Params = void 0;
var requests_1 = require("f59082c2ac7cd70d");
Object.defineProperty(exports, "Params", {
    enumerable: true,
    get: function() {
        return requests_1.Params;
    }
});
var responses_1 = require("849ae589c82ecad2");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
});

},{"f59082c2ac7cd70d":"9V6yG","849ae589c82ecad2":"1UpVU"}],"9V6yG":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("5ba41d5a424cb965");
const inthelpers_1 = require("4276c394b7f1b2e8");
const jsonrpc_1 = require("9264150868ea11e9");
const encodings_1 = require("8a560e42be49e618");
const requests = __importStar(require("af7b8be7caabec28"));
function encodeHeightParam(param) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
    };
}
function encodeBlockchainRequestParams(param) {
    return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
    };
}
function encodeBlockSearchParams(params) {
    return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeAbciQueryParams(params) {
    return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
    };
}
function encodeBroadcastTxParams(params) {
    return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
    };
}
function encodeTxParams(params) {
    return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
    };
}
function encodeTxSearchParams(params) {
    return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeValidatorsParams(params) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
    };
}
class Params {
    static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
    }
    static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
    }
    static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
    }
    static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
    }
    static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeSubscribe(req) {
        const eventTag = {
            key: "tm.event",
            value: req.query.type
        };
        const query = requests.buildQuery({
            tags: [
                eventTag
            ],
            raw: req.query.raw
        });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", {
            query: query
        });
    }
    static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
    }
    // TODO: encode params for query string???
    static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
    }
    static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
    }
}
exports.Params = Params;

},{"5ba41d5a424cb965":"enCPS","4276c394b7f1b2e8":"4rUrR","9264150868ea11e9":"apgCO","8a560e42be49e618":"ixdA6","af7b8be7caabec28":"5SK7W"}],"4rUrR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.apiToSmallInt = apiToSmallInt;
exports.apiToBigInt = apiToBigInt;
exports.smallIntToApi = smallIntToApi;
const math_1 = require("8eb1b0adf6741312");
const encodings_1 = require("bb1ab6cbcf5c8aa1");
/**
 * Takes an integer value from the Tendermint RPC API and
 * returns it as number.
 *
 * Only works within the safe integer range.
 */ function apiToSmallInt(input) {
    const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
    return asInt.toNumber();
}
/**
 * Takes an integer value from the Tendermint RPC API and
 * returns it as BigInt.
 *
 * This supports the full uint64 and int64 ranges.
 */ function apiToBigInt(input) {
    (0, encodings_1.assertString)(input); // Runtime check on top of TypeScript just to be safe for semi-trusted API types
    if (!input.match(/^-?[0-9]+$/)) throw new Error("Invalid string format");
    return BigInt(input);
}
/**
 * Takes an integer in the safe integer range and returns
 * a string representation to be used in the Tendermint RPC API.
 */ function smallIntToApi(num) {
    return new math_1.Int53(num).toString();
}

},{"8eb1b0adf6741312":"e8aug","bb1ab6cbcf5c8aa1":"jbHhp"}],"jbHhp":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertSet = assertSet;
exports.assertBoolean = assertBoolean;
exports.assertString = assertString;
exports.assertNumber = assertNumber;
exports.assertArray = assertArray;
exports.assertObject = assertObject;
exports.assertNotEmpty = assertNotEmpty;
exports.may = may;
exports.dictionaryToStringMap = dictionaryToStringMap;
exports.encodeString = encodeString;
exports.encodeUvarint = encodeUvarint;
exports.encodeTime = encodeTime;
exports.encodeBytes = encodeBytes;
exports.encodeVersion = encodeVersion;
exports.encodeBlockId = encodeBlockId;
const encoding_1 = require("369965e326960ace");
/**
 * A runtime checker that ensures a given value is set (i.e. not undefined or null)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 */ function assertSet(value) {
    if (value === undefined) throw new Error("Value must not be undefined");
    if (value === null) throw new Error("Value must not be null");
    return value;
}
/**
 * A runtime checker that ensures a given value is a boolean
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertBoolean(value) {
    assertSet(value);
    if (typeof value !== "boolean") throw new Error("Value must be a boolean");
    return value;
}
/**
 * A runtime checker that ensures a given value is a string.
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertString(value) {
    assertSet(value);
    if (typeof value !== "string") throw new Error("Value must be a string");
    return value;
}
/**
 * A runtime checker that ensures a given value is a number
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertNumber(value) {
    assertSet(value);
    if (typeof value !== "number") throw new Error("Value must be a number");
    return value;
}
/**
 * A runtime checker that ensures a given value is an array
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertArray(value) {
    assertSet(value);
    if (!Array.isArray(value)) throw new Error("Value must be an array");
    return value;
}
/**
 * A runtime checker that ensures a given value is an object in the sense of JSON
 * (an unordered collection of keyvalue pairs where the keys are strings)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertObject(value) {
    assertSet(value);
    if (typeof value !== "object") throw new Error("Value must be an object");
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") throw new Error("Value must be a simple object");
    return value;
}
/**
 * Throws an error if value matches the empty value for the
 * given type (array/string of length 0, number of value 0, ...)
 *
 * Otherwise returns the value.
 *
 * This implies assertSet
 */ function assertNotEmpty(value) {
    assertSet(value);
    if (typeof value === "number" && value === 0) throw new Error("must provide a non-zero value");
    else if (value.length === 0) throw new Error("must provide a non-empty value");
    return value;
}
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
function dictionaryToStringMap(obj) {
    const out = new Map();
    for (const key of Object.keys(obj)){
        const value = obj[key];
        if (typeof value !== "string") throw new Error("Found dictionary value of type other than string");
        out.set(key, value);
    }
    return out;
}
// Encodings needed for hashing block headers
// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195
function encodeString(s) {
    const utf8 = (0, encoding_1.toUtf8)(s);
    return Uint8Array.from([
        utf8.length,
        ...utf8
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87
function encodeUvarint(n) {
    return n >= 0x80 ? Uint8Array.from([
        n & 0xff | 0x80,
        ...encodeUvarint(n >> 7)
    ]) : Uint8Array.from([
        n & 0xff
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178
function encodeTime(time) {
    const milliseconds = time.getTime();
    const seconds = Math.floor(milliseconds / 1000);
    const secondsArray = seconds ? [
        0x08,
        ...encodeUvarint(seconds)
    ] : new Uint8Array();
    const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;
    const nanosecondsArray = nanoseconds ? [
        0x10,
        ...encodeUvarint(nanoseconds)
    ] : new Uint8Array();
    return Uint8Array.from([
        ...secondsArray,
        ...nanosecondsArray
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187
function encodeBytes(bytes) {
    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet
    if (bytes.length >= 0x80) throw new Error("Not implemented for byte arrays of length 128 or more");
    return bytes.length ? Uint8Array.from([
        bytes.length,
        ...bytes
    ]) : new Uint8Array();
}
function encodeVersion(version) {
    const blockArray = version.block ? Uint8Array.from([
        0x08,
        ...encodeUvarint(version.block)
    ]) : new Uint8Array();
    const appArray = version.app ? Uint8Array.from([
        0x10,
        ...encodeUvarint(version.app)
    ]) : new Uint8Array();
    return Uint8Array.from([
        ...blockArray,
        ...appArray
    ]);
}
function encodeBlockId(blockId) {
    return Uint8Array.from([
        0x0a,
        blockId.hash.length,
        ...blockId.hash,
        0x12,
        blockId.parts.hash.length + 4,
        0x08,
        blockId.parts.total,
        0x12,
        blockId.parts.hash.length,
        ...blockId.parts.hash
    ]);
}

},{"369965e326960ace":"enCPS"}],"apgCO":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createJsonRpcRequest = createJsonRpcRequest;
const numbersWithoutZero = "123456789";
/** generates a random numeric character  */ function randomNumericChar() {
    return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
}
/**
 * An (absolutely not cryptographically secure) random integer > 0.
 */ function randomId() {
    return parseInt(Array.from({
        length: 12
    }).map(()=>randomNumericChar()).join(""), 10);
}
/** Creates a JSON-RPC request with random ID */ function createJsonRpcRequest(method, params) {
    const paramsCopy = params ? {
        ...params
    } : {};
    return {
        jsonrpc: "2.0",
        id: randomId(),
        method: method,
        params: paramsCopy
    };
}

},{}],"ixdA6":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertSet = assertSet;
exports.assertBoolean = assertBoolean;
exports.assertString = assertString;
exports.assertNumber = assertNumber;
exports.assertArray = assertArray;
exports.assertObject = assertObject;
exports.assertNotEmpty = assertNotEmpty;
exports.may = may;
exports.dictionaryToStringMap = dictionaryToStringMap;
exports.encodeString = encodeString;
exports.encodeUvarint = encodeUvarint;
exports.encodeTime = encodeTime;
exports.encodeBytes = encodeBytes;
exports.encodeVersion = encodeVersion;
exports.encodeBlockId = encodeBlockId;
const encoding_1 = require("74bb83017c4c356d");
/**
 * A runtime checker that ensures a given value is set (i.e. not undefined or null)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 */ function assertSet(value) {
    if (value === undefined) throw new Error("Value must not be undefined");
    if (value === null) throw new Error("Value must not be null");
    return value;
}
/**
 * A runtime checker that ensures a given value is a boolean
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertBoolean(value) {
    assertSet(value);
    if (typeof value !== "boolean") throw new Error("Value must be a boolean");
    return value;
}
/**
 * A runtime checker that ensures a given value is a string.
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertString(value) {
    assertSet(value);
    if (typeof value !== "string") throw new Error("Value must be a string");
    return value;
}
/**
 * A runtime checker that ensures a given value is a number
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertNumber(value) {
    assertSet(value);
    if (typeof value !== "number") throw new Error("Value must be a number");
    return value;
}
/**
 * A runtime checker that ensures a given value is an array
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertArray(value) {
    assertSet(value);
    if (!Array.isArray(value)) throw new Error("Value must be an array");
    return value;
}
/**
 * A runtime checker that ensures a given value is an object in the sense of JSON
 * (an unordered collection of keyvalue pairs where the keys are strings)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertObject(value) {
    assertSet(value);
    if (typeof value !== "object") throw new Error("Value must be an object");
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") throw new Error("Value must be a simple object");
    return value;
}
/**
 * Throws an error if value matches the empty value for the
 * given type (array/string of length 0, number of value 0, ...)
 *
 * Otherwise returns the value.
 *
 * This implies assertSet
 */ function assertNotEmpty(value) {
    assertSet(value);
    if (typeof value === "number" && value === 0) throw new Error("must provide a non-zero value");
    else if (value.length === 0) throw new Error("must provide a non-empty value");
    return value;
}
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
function dictionaryToStringMap(obj) {
    const out = new Map();
    for (const key of Object.keys(obj)){
        const value = obj[key];
        if (typeof value !== "string") throw new Error("Found dictionary value of type other than string");
        out.set(key, value);
    }
    return out;
}
// Encodings needed for hashing block headers
// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195
function encodeString(s) {
    const utf8 = (0, encoding_1.toUtf8)(s);
    return Uint8Array.from([
        utf8.length,
        ...utf8
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87
function encodeUvarint(n) {
    return n >= 0x80 ? Uint8Array.from([
        n & 0xff | 0x80,
        ...encodeUvarint(n >> 7)
    ]) : Uint8Array.from([
        n & 0xff
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178
function encodeTime(time) {
    const milliseconds = time.getTime();
    const seconds = Math.floor(milliseconds / 1000);
    const secondsArray = seconds ? [
        0x08,
        ...encodeUvarint(seconds)
    ] : new Uint8Array();
    const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;
    const nanosecondsArray = nanoseconds ? [
        0x10,
        ...encodeUvarint(nanoseconds)
    ] : new Uint8Array();
    return Uint8Array.from([
        ...secondsArray,
        ...nanosecondsArray
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187
function encodeBytes(bytes) {
    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet
    if (bytes.length >= 0x80) throw new Error("Not implemented for byte arrays of length 128 or more");
    return bytes.length ? Uint8Array.from([
        bytes.length,
        ...bytes
    ]) : new Uint8Array();
}
function encodeVersion(version) {
    const blockArray = version.block ? Uint8Array.from([
        0x08,
        ...encodeUvarint(version.block)
    ]) : new Uint8Array();
    const appArray = version.app ? Uint8Array.from([
        0x10,
        ...encodeUvarint(version.app)
    ]) : new Uint8Array();
    return Uint8Array.from([
        ...blockArray,
        ...appArray
    ]);
}
function encodeBlockId(blockId) {
    return Uint8Array.from([
        0x0a,
        blockId.hash.length,
        ...blockId.hash,
        0x12,
        blockId.parts.hash.length + 4,
        0x08,
        blockId.parts.total,
        0x12,
        blockId.parts.hash.length,
        ...blockId.parts.hash
    ]);
}

},{"74bb83017c4c356d":"enCPS"}],"5SK7W":[function(require,module,exports,__globalThis) {
"use strict";
/* eslint-disable @typescript-eslint/naming-convention */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubscriptionEventType = exports.Method = void 0;
exports.buildQuery = buildQuery;
/**
 * RPC methods as documented in https://docs.tendermint.com/master/rpc/
 *
 * Enum raw value must match the spelling in the "shell" example call (snake_case)
 */ var Method;
(function(Method) {
    Method["AbciInfo"] = "abci_info";
    Method["AbciQuery"] = "abci_query";
    Method["Block"] = "block";
    /** Get block headers for minHeight <= height <= maxHeight. */ Method["Blockchain"] = "blockchain";
    Method["BlockResults"] = "block_results";
    Method["BlockSearch"] = "block_search";
    Method["BroadcastTxAsync"] = "broadcast_tx_async";
    Method["BroadcastTxSync"] = "broadcast_tx_sync";
    Method["BroadcastTxCommit"] = "broadcast_tx_commit";
    Method["Commit"] = "commit";
    Method["Genesis"] = "genesis";
    Method["Health"] = "health";
    Method["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
    Method["Status"] = "status";
    Method["Subscribe"] = "subscribe";
    Method["Tx"] = "tx";
    Method["TxSearch"] = "tx_search";
    Method["Validators"] = "validators";
    Method["Unsubscribe"] = "unsubscribe";
})(Method || (exports.Method = Method = {}));
/**
 * Raw values must match the tendermint event name
 *
 * @see https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
 */ var SubscriptionEventType;
(function(SubscriptionEventType) {
    SubscriptionEventType["NewBlock"] = "NewBlock";
    SubscriptionEventType["NewBlockHeader"] = "NewBlockHeader";
    SubscriptionEventType["Tx"] = "Tx";
})(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
function buildQuery(components) {
    const tags = components.tags ? components.tags : [];
    const tagComponents = tags.map((tag)=>`${tag.key}='${tag.value}'`);
    const rawComponents = components.raw ? [
        components.raw
    ] : [];
    return [
        ...tagComponents,
        ...rawComponents
    ].join(" AND ");
}

},{}],"1UpVU":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = void 0;
exports.decodeEvent = decodeEvent;
exports.decodeValidatorUpdate = decodeValidatorUpdate;
exports.decodeCommit = decodeCommit;
exports.decodeValidatorGenesis = decodeValidatorGenesis;
exports.decodeValidatorInfo = decodeValidatorInfo;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("241f679712fb0d0c");
const utils_1 = require("b3d48a7a3591c5d5");
const dates_1 = require("ae184a9908d5a554");
const inthelpers_1 = require("4fa09f3fa73df3d8");
const types_1 = require("18945523abc91db8");
const encodings_1 = require("46bf0a72b2b304fc");
const hasher_1 = require("cd4772503f608612");
function decodeAbciInfo(data) {
    return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
    };
}
function decodeQueryProof(data) {
    return {
        ops: data.ops.map((op)=>({
                type: op.type,
                key: (0, encoding_1.fromBase64)(op.key),
                data: (0, encoding_1.fromBase64)(op.data)
            }))
    };
}
function decodeAbciQuery(data) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
    };
}
function decodeEventAttribute(attribute) {
    return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
    };
}
function decodeAttributes(attributes) {
    return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
}
function decodeEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
    };
}
function decodeEvents(events) {
    return (0, encodings_1.assertArray)(events).map(decodeEvent);
}
function decodeTxData(data) {
    return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
    };
}
function decodePubkey(data) {
    if ("Sum" in data) {
        // we don't need to check type because we're checking algorithm
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
            algorithm,
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
    } else switch(data.type){
        // go-amino special code
        case "tendermint/PubKeyEd25519":
            return {
                algorithm: "ed25519",
                data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
        case "tendermint/PubKeySecp256k1":
            return {
                algorithm: "secp256k1",
                data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
        default:
            throw new Error(`unknown pubkey type: ${data.type}`);
    }
}
/**
 * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry
 *
 * > Add time_iota_ms to block's consensus parameters (not exposed to the application)
 * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310
 */ function decodeBlockParams(data) {
    return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
    };
}
function decodeEvidenceParams(data) {
    return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
    };
}
function decodeConsensusParams(data) {
    return {
        block: data.block ? decodeBlockParams((0, encodings_1.assertObject)(data.block)) : undefined,
        evidence: data.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence)) : undefined
    };
}
function decodeValidatorUpdate(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
    };
}
function decodeBlockResults(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data.finalize_block_events || [])
    };
}
function decodeBlockId(data) {
    return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
            total: (0, encodings_1.assertNotEmpty)(data.parts.total),
            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
    };
}
function decodeBlockVersion(data) {
    return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
    };
}
function decodeHeader(data) {
    return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
    };
}
function decodeBlockMeta(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
    };
}
function decodeBlockchain(data) {
    return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
    };
}
function decodeBroadcastTxSync(data) {
    return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
    };
}
function decodeBroadcastTxCommit(data) {
    const txResult = data.tx_result ? decodeTxData(data.tx_result) : undefined;
    return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: txResult,
        txResult: txResult
    };
}
function decodeBlockIdFlag(blockIdFlag) {
    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
    return blockIdFlag;
}
function decodeCommitSignature(data) {
    return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : undefined,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined
    };
}
function decodeCommit(data) {
    return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: data.signatures ? (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature) : []
    };
}
function decodeCommitResponse(data) {
    return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
    };
}
function decodeValidatorGenesis(data) {
    return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
    };
}
function decodeGenesis(data) {
    return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
    };
}
function decodeValidatorInfo(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined
    };
}
function decodeNodeInfo(data) {
    return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertString)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
            app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
            block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
            p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
    };
}
function decodeSyncInfo(data) {
    const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : undefined;
    const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : undefined;
    return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : undefined,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : undefined,
        earliestBlockHeight: earliestBlockHeight || undefined,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : undefined,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
    };
}
function decodeStatus(data) {
    return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
    };
}
function decodeTxProof(data) {
    return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
            total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
            index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
    };
}
function decodeTxResponse(data) {
    return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
    };
}
function decodeTxSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
    };
}
function decodeTxEvent(data) {
    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
    return {
        tx: tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
    };
}
function decodeValidators(data) {
    return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
    };
}
function decodeBlock(data) {
    return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
    };
}
function decodeBlockResponse(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
    };
}
function decodeBlockSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
    };
}
function decodeNumUnconfirmedTxs(data) {
    return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
    };
}
class Responses {
    static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeBlock(response) {
        return decodeBlockResponse(response.result);
    }
    static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
    }
    static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
    }
    static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
    }
    static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
    }
    static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
    }
    static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
    }
    static decodeCommit(response) {
        return decodeCommitResponse(response.result);
    }
    static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
    }
    static decodeHealth() {
        return null;
    }
    static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
    }
    static decodeStatus(response) {
        return decodeStatus(response.result);
    }
    static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
    }
    static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
    }
    static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
    }
    static decodeTx(response) {
        return decodeTxResponse(response.result);
    }
    static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
    }
    static decodeValidators(response) {
        return decodeValidators(response.result);
    }
}
exports.Responses = Responses;

},{"241f679712fb0d0c":"enCPS","b3d48a7a3591c5d5":"3R4mb","ae184a9908d5a554":"aYDXm","4fa09f3fa73df3d8":"4rUrR","18945523abc91db8":"f88Rz","46bf0a72b2b304fc":"ixdA6","cd4772503f608612":"8qeFB"}],"f88Rz":[function(require,module,exports,__globalThis) {
"use strict";
// Types in this file are exported outside of the @cosmjs/tendermint-rpc package,
// e.g. as part of a request or response
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockIdFlag = void 0;
var BlockIdFlag;
(function(BlockIdFlag) {
    BlockIdFlag[BlockIdFlag["Unknown"] = 0] = "Unknown";
    BlockIdFlag[BlockIdFlag["Absent"] = 1] = "Absent";
    BlockIdFlag[BlockIdFlag["Commit"] = 2] = "Commit";
    BlockIdFlag[BlockIdFlag["Nil"] = 3] = "Nil";
    BlockIdFlag[BlockIdFlag["Unrecognized"] = -1] = "Unrecognized";
})(BlockIdFlag || (exports.BlockIdFlag = BlockIdFlag = {}));

},{}],"8qeFB":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashTx = hashTx;
exports.hashBlock = hashBlock;
const crypto_1 = require("f0e73f8d13af3500");
const encodings_1 = require("9b216fc339ee66d9");
// hash is sha256
// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260
function hashTx(tx) {
    return (0, crypto_1.sha256)(tx);
}
function getSplitPoint(n) {
    if (n < 1) throw new Error("Cannot split an empty tree");
    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
}
function hashLeaf(leaf) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        0
    ]));
    hash.update(leaf);
    return hash.digest();
}
function hashInner(left, right) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        1
    ]));
    hash.update(left);
    hash.update(right);
    return hash.digest();
}
// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot
// Note: the hashes input may not actually be hashes, especially before a recursive call
function hashTree(hashes) {
    switch(hashes.length){
        case 0:
            throw new Error("Cannot hash empty tree");
        case 1:
            return hashLeaf(hashes[0]);
        default:
            {
                const slicePoint = getSplitPoint(hashes.length);
                const left = hashTree(hashes.slice(0, slicePoint));
                const right = hashTree(hashes.slice(slicePoint));
                return hashInner(left, right);
            }
    }
}
function hashBlock(header) {
    if (!header.lastBlockId) throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
    const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
    ];
    return hashTree(encodedFields);
}

},{"f0e73f8d13af3500":"kTd5b","9b216fc339ee66d9":"ixdA6"}],"g2GwE":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = void 0;
exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
/**
 * Returns true iff transaction made it successfully into the transaction pool
 */ function broadcastTxSyncSuccess(res) {
    // code must be 0 on success
    return res.code === 0;
}
/**
 * Returns true iff transaction made it successfully into a block
 * (i.e. success in `check_tx` and `deliver_tx` field)
 */ function broadcastTxCommitSuccess(response) {
    // code must be 0 on success
    // deliverTx may be present but empty on failure
    return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
}
/**
 * raw values from https://github.com/tendermint/tendermint/blob/dfa9a9a30a666132425b29454e90a472aa579a48/types/vote.go#L44
 */ var VoteType;
(function(VoteType) {
    VoteType[VoteType["PreVote"] = 1] = "PreVote";
    VoteType[VoteType["PreCommit"] = 2] = "PreCommit";
})(VoteType || (exports.VoteType = VoteType = {}));

},{}],"ieXXt":[function(require,module,exports,__globalThis) {
"use strict";
// Note: all exports in this module are publicly available via
// `import { tendermint34 } from "@cosmjs/tendermint-rpc"`
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
var requests_1 = require("3b3aaaa1dd7634f8");
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return requests_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return requests_1.SubscriptionEventType;
    }
});
var responses_1 = require("e66b01916a3c5a2b");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return responses_1.VoteType;
    }
});
var tendermint34client_1 = require("2c314e59dfc3541b");
Object.defineProperty(exports, "Tendermint34Client", {
    enumerable: true,
    get: function() {
        return tendermint34client_1.Tendermint34Client;
    }
});

},{"3b3aaaa1dd7634f8":"9qw5d","e66b01916a3c5a2b":"h92lA","2c314e59dfc3541b":"kwKKv"}],"9qw5d":[function(require,module,exports,__globalThis) {
"use strict";
/* eslint-disable @typescript-eslint/naming-convention */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubscriptionEventType = exports.Method = void 0;
exports.buildQuery = buildQuery;
/**
 * RPC methods as documented in https://docs.tendermint.com/master/rpc/
 *
 * Enum raw value must match the spelling in the "shell" example call (snake_case)
 */ var Method;
(function(Method) {
    Method["AbciInfo"] = "abci_info";
    Method["AbciQuery"] = "abci_query";
    Method["Block"] = "block";
    /** Get block headers for minHeight <= height <= maxHeight. */ Method["Blockchain"] = "blockchain";
    Method["BlockResults"] = "block_results";
    Method["BlockSearch"] = "block_search";
    Method["BroadcastTxAsync"] = "broadcast_tx_async";
    Method["BroadcastTxSync"] = "broadcast_tx_sync";
    Method["BroadcastTxCommit"] = "broadcast_tx_commit";
    Method["Commit"] = "commit";
    Method["Genesis"] = "genesis";
    Method["Health"] = "health";
    Method["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
    Method["Status"] = "status";
    Method["Subscribe"] = "subscribe";
    Method["Tx"] = "tx";
    Method["TxSearch"] = "tx_search";
    Method["Validators"] = "validators";
    Method["Unsubscribe"] = "unsubscribe";
})(Method || (exports.Method = Method = {}));
/**
 * Raw values must match the tendermint event name
 *
 * @see https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
 */ var SubscriptionEventType;
(function(SubscriptionEventType) {
    SubscriptionEventType["NewBlock"] = "NewBlock";
    SubscriptionEventType["NewBlockHeader"] = "NewBlockHeader";
    SubscriptionEventType["Tx"] = "Tx";
})(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
function buildQuery(components) {
    const tags = components.tags ? components.tags : [];
    const tagComponents = tags.map((tag)=>`${tag.key}='${tag.value}'`);
    const rawComponents = components.raw ? [
        components.raw
    ] : [];
    return [
        ...tagComponents,
        ...rawComponents
    ].join(" AND ");
}

},{}],"h92lA":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = void 0;
exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
/**
 * Returns true iff transaction made it successfully into the transaction pool
 */ function broadcastTxSyncSuccess(res) {
    // code must be 0 on success
    return res.code === 0;
}
/**
 * Returns true iff transaction made it successfully into a block
 * (i.e. success in `check_tx` and `deliver_tx` field)
 */ function broadcastTxCommitSuccess(response) {
    // code must be 0 on success
    // deliverTx may be present but empty on failure
    return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
}
/**
 * raw values from https://github.com/tendermint/tendermint/blob/dfa9a9a30a666132425b29454e90a472aa579a48/types/vote.go#L44
 */ var VoteType;
(function(VoteType) {
    VoteType[VoteType["PreVote"] = 1] = "PreVote";
    VoteType[VoteType["PreCommit"] = 2] = "PreCommit";
})(VoteType || (exports.VoteType = VoteType = {}));

},{}],"kwKKv":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint34Client = void 0;
const rpcclients_1 = require("44090f2b69cc8e20");
const adaptor_1 = require("1f4b9dd2d77865c8");
const requests = __importStar(require("20ed434f812decc0"));
class Tendermint34Client {
    /**
     * Creates a new Tendermint client for the given endpoint.
     *
     * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
     */ static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") rpcClient = new rpcclients_1.HttpClient(endpoint);
        else {
            const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
            rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return Tendermint34Client.create(rpcClient);
    }
    /**
     * Creates a new Tendermint client given an RPC client.
     */ static create(rpcClient) {
        return new Tendermint34Client(rpcClient);
    }
    client;
    /**
     * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
     */ constructor(client){
        this.client = client;
    }
    disconnect() {
        this.client.disconnect();
    }
    async abciInfo() {
        const query = {
            method: requests.Method.AbciInfo
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
    }
    async abciQuery(params) {
        const query = {
            params: params,
            method: requests.Method.AbciQuery
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
    }
    async block(height) {
        const query = {
            method: requests.Method.Block,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
    }
    async blockResults(height) {
        const query = {
            method: requests.Method.BlockResults,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
    }
    /**
     * Search for events that are in a block.
     *
     * NOTE
     * This method will error on any node that is running a Tendermint version lower than 0.34.9.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
     */ async blockSearch(params) {
        const query = {
            params: params,
            method: requests.Method.BlockSearch
        };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
            ...resp,
            // make sure we sort by height, as tendermint may be sorting by string value of the height
            blocks: [
                ...resp.blocks
            ].sort((a, b)=>a.block.header.height - b.block.header.height)
        };
    }
    // this should paginate through all blockSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    //
    // NOTE
    // This method will error on any node that is running a Tendermint version lower than 0.34.9.
    async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while(!done){
            const resp = await this.blockSearch({
                ...params,
                page: page
            });
            blocks.push(...resp.blocks);
            if (blocks.length < resp.totalCount) page++;
            else done = true;
        }
        // make sure we sort by height, as tendermint may be sorting by string value of the height
        // and the earlier items may be in a higher page than the later items
        blocks.sort((a, b)=>a.block.header.height - b.block.header.height);
        return {
            totalCount: blocks.length,
            blocks: blocks
        };
    }
    /**
     * Queries block headers filtered by minHeight <= height <= maxHeight.
     *
     * @param minHeight The minimum height to be included in the result. Defaults to 0.
     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
     */ async blockchain(minHeight, maxHeight) {
        const query = {
            method: requests.Method.Blockchain,
            params: {
                minHeight: minHeight,
                maxHeight: maxHeight
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
    }
    /**
     * Broadcast transaction to mempool and wait for response
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */ async broadcastTxSync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxSync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
    }
    /**
     * Broadcast transaction to mempool and do not wait for result
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */ async broadcastTxAsync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxAsync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
    }
    /**
     * Broadcast transaction to mempool and wait for block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
     */ async broadcastTxCommit(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxCommit
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
    }
    async commit(height) {
        const query = {
            method: requests.Method.Commit,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
    }
    async genesis() {
        const query = {
            method: requests.Method.Genesis
        };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
    }
    async health() {
        const query = {
            method: requests.Method.Health
        };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
    }
    async numUnconfirmedTxs() {
        const query = {
            method: requests.Method.NumUnconfirmedTxs
        };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
    }
    async status() {
        const query = {
            method: requests.Method.Status
        };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
    }
    subscribeNewBlock() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlock
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
    }
    subscribeNewBlockHeader() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlockHeader
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
    }
    subscribeTx(query) {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.Tx,
                raw: query
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
    }
    /**
     * Get a single transaction by hash
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx
     */ async tx(params) {
        const query = {
            params: params,
            method: requests.Method.Tx
        };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
    }
    /**
     * Search for transactions that are in a block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
     */ async txSearch(params) {
        const query = {
            params: params,
            method: requests.Method.TxSearch
        };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
    }
    // this should paginate through all txSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while(!done){
            const resp = await this.txSearch({
                ...params,
                page: page
            });
            txs.push(...resp.txs);
            if (txs.length < resp.totalCount) page++;
            else done = true;
        }
        return {
            totalCount: txs.length,
            txs: txs
        };
    }
    async validators(params) {
        const query = {
            method: requests.Method.Validators,
            params: params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
    }
    async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while(!done){
            const response = await this.validators({
                per_page: 50,
                height: blockHeight,
                page: page
            });
            validators.push(...response.validators);
            blockHeight = blockHeight || response.blockHeight;
            if (validators.length < response.total) page++;
            else done = true;
        }
        return {
            // NOTE: Default value is for type safety but this should always be set
            blockHeight: blockHeight ?? 0,
            count: validators.length,
            total: validators.length,
            validators: validators
        };
    }
    // doCall is a helper to handle the encode/call/decode logic
    async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
    }
    subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) throw new Error("This RPC client type cannot subscribe to events");
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event)=>{
            return decode(event);
        });
    }
}
exports.Tendermint34Client = Tendermint34Client;

},{"44090f2b69cc8e20":"4i1Up","1f4b9dd2d77865c8":"2NFwR","20ed434f812decc0":"9qw5d"}],"2NFwR":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.Params = void 0;
var requests_1 = require("2dcdcbc751a08472");
Object.defineProperty(exports, "Params", {
    enumerable: true,
    get: function() {
        return requests_1.Params;
    }
});
var responses_1 = require("9a5c8c0c1165e7a0");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
});

},{"2dcdcbc751a08472":"hXEuO","9a5c8c0c1165e7a0":"39lro"}],"hXEuO":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("130c223076fa2391");
const inthelpers_1 = require("6af63bc5ce76ac7c");
const jsonrpc_1 = require("86bb0e481198bcec");
const encodings_1 = require("45124440f2987e4b");
const requests = __importStar(require("5c66301f21392261"));
function encodeHeightParam(param) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
    };
}
function encodeBlockchainRequestParams(param) {
    return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
    };
}
function encodeBlockSearchParams(params) {
    return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeAbciQueryParams(params) {
    return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
    };
}
function encodeBroadcastTxParams(params) {
    return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
    };
}
function encodeTxParams(params) {
    return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
    };
}
function encodeTxSearchParams(params) {
    return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeValidatorsParams(params) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
    };
}
class Params {
    static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
    }
    static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
    }
    static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
    }
    static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
    }
    static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeSubscribe(req) {
        const eventTag = {
            key: "tm.event",
            value: req.query.type
        };
        const query = requests.buildQuery({
            tags: [
                eventTag
            ],
            raw: req.query.raw
        });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", {
            query: query
        });
    }
    static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
    }
    // TODO: encode params for query string???
    static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
    }
    static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
    }
}
exports.Params = Params;

},{"130c223076fa2391":"enCPS","6af63bc5ce76ac7c":"4rUrR","86bb0e481198bcec":"apgCO","45124440f2987e4b":"jbHhp","5c66301f21392261":"9qw5d"}],"39lro":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = void 0;
exports.decodeEvent = decodeEvent;
exports.decodeValidatorUpdate = decodeValidatorUpdate;
exports.decodeValidatorGenesis = decodeValidatorGenesis;
exports.decodeValidatorInfo = decodeValidatorInfo;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("ff223b9ee5781d1f");
const utils_1 = require("404a62d75c7ac9d7");
const dates_1 = require("3f28a150790f739c");
const inthelpers_1 = require("a73537fee0d86e0e");
const types_1 = require("e13eed93c104aa1f");
const encodings_1 = require("fbaf3c53662e8d44");
const hasher_1 = require("dabdc66fa367059f");
function decodeAbciInfo(data) {
    return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
    };
}
function decodeQueryProof(data) {
    return {
        ops: data.ops.map((op)=>({
                type: op.type,
                key: (0, encoding_1.fromBase64)(op.key),
                data: (0, encoding_1.fromBase64)(op.data)
            }))
    };
}
function decodeAbciQuery(data) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
    };
}
function decodeAttribute(attribute) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(attribute.value ?? ""))
    };
}
function decodeAttributes(attributes) {
    return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
}
function decodeEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
    };
}
function decodeEvents(events) {
    return (0, encodings_1.assertArray)(events).map(decodeEvent);
}
function decodeTxData(data) {
    return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
    };
}
function decodePubkey(data) {
    if ("Sum" in data) {
        // we don't need to check type because we're checking algorithm
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
            algorithm,
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
    } else switch(data.type){
        // go-amino special code
        case "tendermint/PubKeyEd25519":
            return {
                algorithm: "ed25519",
                data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
        case "tendermint/PubKeySecp256k1":
            return {
                algorithm: "secp256k1",
                data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
        default:
            throw new Error(`unknown pubkey type: ${data.type}`);
    }
}
/**
 * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry
 *
 * > Add time_iota_ms to block's consensus parameters (not exposed to the application)
 * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310
 */ function decodeBlockParams(data) {
    return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
    };
}
function decodeEvidenceParams(data) {
    return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
    };
}
function decodeConsensusParams(data) {
    return {
        block: data.block ? decodeBlockParams((0, encodings_1.assertObject)(data.block)) : undefined,
        evidence: data.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence)) : undefined
    };
}
function decodeValidatorUpdate(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
    };
}
function decodeBlockResults(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
    };
}
function decodeBlockId(data) {
    return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
            total: (0, encodings_1.assertNotEmpty)(data.parts.total),
            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
    };
}
function decodeBlockVersion(data) {
    return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
    };
}
function decodeHeader(data) {
    return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
    };
}
function decodeBlockMeta(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
    };
}
function decodeBlockchain(data) {
    return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
    };
}
function decodeBroadcastTxSync(data) {
    return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
    };
}
function decodeBroadcastTxCommit(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
    };
}
function decodeBlockIdFlag(blockIdFlag) {
    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
    return blockIdFlag;
}
function decodeCommitSignature(data) {
    return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : undefined,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined
    };
}
function decodeCommit(data) {
    return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
    };
}
function decodeCommitResponse(data) {
    return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
    };
}
function decodeValidatorGenesis(data) {
    return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
    };
}
function decodeGenesis(data) {
    return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
    };
}
function decodeValidatorInfo(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined
    };
}
function decodeNodeInfo(data) {
    return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertNotEmpty)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
            app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
            block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
            p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
    };
}
function decodeSyncInfo(data) {
    const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : undefined;
    const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : undefined;
    return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : undefined,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : undefined,
        earliestBlockHeight: earliestBlockHeight || undefined,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : undefined,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
    };
}
function decodeStatus(data) {
    return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
    };
}
function decodeTxProof(data) {
    return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
            total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
            index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
    };
}
function decodeTxResponse(data) {
    return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
    };
}
function decodeTxSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
    };
}
function decodeTxEvent(data) {
    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
    return {
        tx: tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
    };
}
function decodeValidators(data) {
    return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
    };
}
function decodeBlock(data) {
    return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
    };
}
function decodeBlockResponse(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
    };
}
function decodeBlockSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
    };
}
function decodeNumUnconfirmedTxs(data) {
    return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
    };
}
class Responses {
    static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeBlock(response) {
        return decodeBlockResponse(response.result);
    }
    static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
    }
    static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
    }
    static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
    }
    static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
    }
    static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
    }
    static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
    }
    static decodeCommit(response) {
        return decodeCommitResponse(response.result);
    }
    static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
    }
    static decodeHealth() {
        return null;
    }
    static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
    }
    static decodeStatus(response) {
        return decodeStatus(response.result);
    }
    static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
    }
    static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
    }
    static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
    }
    static decodeTx(response) {
        return decodeTxResponse(response.result);
    }
    static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
    }
    static decodeValidators(response) {
        return decodeValidators(response.result);
    }
}
exports.Responses = Responses;

},{"ff223b9ee5781d1f":"enCPS","404a62d75c7ac9d7":"3R4mb","3f28a150790f739c":"aYDXm","a73537fee0d86e0e":"4rUrR","e13eed93c104aa1f":"f88Rz","fbaf3c53662e8d44":"jbHhp","dabdc66fa367059f":"cK0pu"}],"cK0pu":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashTx = hashTx;
exports.hashBlock = hashBlock;
const crypto_1 = require("32ea1a0ce13c3fc1");
const encodings_1 = require("b32c493663b005e5");
// hash is sha256
// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260
function hashTx(tx) {
    return (0, crypto_1.sha256)(tx);
}
function getSplitPoint(n) {
    if (n < 1) throw new Error("Cannot split an empty tree");
    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
}
function hashLeaf(leaf) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        0
    ]));
    hash.update(leaf);
    return hash.digest();
}
function hashInner(left, right) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        1
    ]));
    hash.update(left);
    hash.update(right);
    return hash.digest();
}
// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot
// Note: the hashes input may not actually be hashes, especially before a recursive call
function hashTree(hashes) {
    switch(hashes.length){
        case 0:
            throw new Error("Cannot hash empty tree");
        case 1:
            return hashLeaf(hashes[0]);
        default:
            {
                const slicePoint = getSplitPoint(hashes.length);
                const left = hashTree(hashes.slice(0, slicePoint));
                const right = hashTree(hashes.slice(slicePoint));
                return hashInner(left, right);
            }
    }
}
function hashBlock(header) {
    if (!header.lastBlockId) throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
    const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
    ];
    return hashTree(encodedFields);
}

},{"32ea1a0ce13c3fc1":"kTd5b","b32c493663b005e5":"jbHhp"}],"aFn6G":[function(require,module,exports,__globalThis) {
"use strict";
// Note: all exports in this module are publicly available via
// `import { tendermint37 } from "@cosmjs/tendermint-rpc"`
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
var requests_1 = require("d6b218c62ff92408");
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return requests_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return requests_1.SubscriptionEventType;
    }
});
var responses_1 = require("fbb05bb004bef26b");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return responses_1.VoteType;
    }
});
var tendermint37client_1 = require("4765b266017fe90c");
Object.defineProperty(exports, "Tendermint37Client", {
    enumerable: true,
    get: function() {
        return tendermint37client_1.Tendermint37Client;
    }
});

},{"d6b218c62ff92408":"ewT62","fbb05bb004bef26b":"5gvP2","4765b266017fe90c":"g1WpT"}],"ewT62":[function(require,module,exports,__globalThis) {
"use strict";
/* eslint-disable @typescript-eslint/naming-convention */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubscriptionEventType = exports.Method = void 0;
exports.buildQuery = buildQuery;
/**
 * RPC methods as documented in https://docs.tendermint.com/master/rpc/
 *
 * Enum raw value must match the spelling in the "shell" example call (snake_case)
 */ var Method;
(function(Method) {
    Method["AbciInfo"] = "abci_info";
    Method["AbciQuery"] = "abci_query";
    Method["Block"] = "block";
    /** Get block headers for minHeight <= height <= maxHeight. */ Method["Blockchain"] = "blockchain";
    Method["BlockResults"] = "block_results";
    Method["BlockSearch"] = "block_search";
    Method["BroadcastTxAsync"] = "broadcast_tx_async";
    Method["BroadcastTxSync"] = "broadcast_tx_sync";
    Method["BroadcastTxCommit"] = "broadcast_tx_commit";
    Method["Commit"] = "commit";
    Method["Genesis"] = "genesis";
    Method["Health"] = "health";
    Method["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
    Method["Status"] = "status";
    Method["Subscribe"] = "subscribe";
    Method["Tx"] = "tx";
    Method["TxSearch"] = "tx_search";
    Method["Validators"] = "validators";
    Method["Unsubscribe"] = "unsubscribe";
})(Method || (exports.Method = Method = {}));
/**
 * Raw values must match the tendermint event name
 *
 * @see https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
 */ var SubscriptionEventType;
(function(SubscriptionEventType) {
    SubscriptionEventType["NewBlock"] = "NewBlock";
    SubscriptionEventType["NewBlockHeader"] = "NewBlockHeader";
    SubscriptionEventType["Tx"] = "Tx";
})(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
function buildQuery(components) {
    const tags = components.tags ? components.tags : [];
    const tagComponents = tags.map((tag)=>`${tag.key}='${tag.value}'`);
    const rawComponents = components.raw ? [
        components.raw
    ] : [];
    return [
        ...tagComponents,
        ...rawComponents
    ].join(" AND ");
}

},{}],"5gvP2":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = void 0;
exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
/**
 * Returns true iff transaction made it successfully into the transaction pool
 */ function broadcastTxSyncSuccess(res) {
    // code must be 0 on success
    return res.code === 0;
}
/**
 * Returns true iff transaction made it successfully into a block
 * (i.e. success in `check_tx` and `deliver_tx` field)
 */ function broadcastTxCommitSuccess(response) {
    // code must be 0 on success
    // deliverTx may be present but empty on failure
    return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
}
/**
 * raw values from https://github.com/tendermint/tendermint/blob/dfa9a9a30a666132425b29454e90a472aa579a48/types/vote.go#L44
 */ var VoteType;
(function(VoteType) {
    VoteType[VoteType["PreVote"] = 1] = "PreVote";
    VoteType[VoteType["PreCommit"] = 2] = "PreCommit";
})(VoteType || (exports.VoteType = VoteType = {}));

},{}],"g1WpT":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint37Client = void 0;
const rpcclients_1 = require("302a8b1f6eae4136");
const adaptor_1 = require("39d13fa2dd00da27");
const requests = __importStar(require("f17521a4c1f79b04"));
class Tendermint37Client {
    /**
     * Creates a new Tendermint client for the given endpoint.
     *
     * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
     */ static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") rpcClient = new rpcclients_1.HttpClient(endpoint);
        else {
            const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
            rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return Tendermint37Client.create(rpcClient);
    }
    /**
     * Creates a new Tendermint client given an RPC client.
     */ static create(rpcClient) {
        return new Tendermint37Client(rpcClient);
    }
    client;
    /**
     * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
     */ constructor(client){
        this.client = client;
    }
    disconnect() {
        this.client.disconnect();
    }
    async abciInfo() {
        const query = {
            method: requests.Method.AbciInfo
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
    }
    async abciQuery(params) {
        const query = {
            params: params,
            method: requests.Method.AbciQuery
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
    }
    async block(height) {
        const query = {
            method: requests.Method.Block,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
    }
    async blockResults(height) {
        const query = {
            method: requests.Method.BlockResults,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
    }
    /**
     * Search for events that are in a block.
     *
     * NOTE
     * This method will error on any node that is running a Tendermint version lower than 0.34.9.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
     */ async blockSearch(params) {
        const query = {
            params: params,
            method: requests.Method.BlockSearch
        };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
            ...resp,
            // make sure we sort by height, as tendermint may be sorting by string value of the height
            blocks: [
                ...resp.blocks
            ].sort((a, b)=>a.block.header.height - b.block.header.height)
        };
    }
    // this should paginate through all blockSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    //
    // NOTE
    // This method will error on any node that is running a Tendermint version lower than 0.34.9.
    async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while(!done){
            const resp = await this.blockSearch({
                ...params,
                page: page
            });
            blocks.push(...resp.blocks);
            if (blocks.length < resp.totalCount) page++;
            else done = true;
        }
        // make sure we sort by height, as tendermint may be sorting by string value of the height
        // and the earlier items may be in a higher page than the later items
        blocks.sort((a, b)=>a.block.header.height - b.block.header.height);
        return {
            totalCount: blocks.length,
            blocks: blocks
        };
    }
    /**
     * Queries block headers filtered by minHeight <= height <= maxHeight.
     *
     * @param minHeight The minimum height to be included in the result. Defaults to 0.
     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
     */ async blockchain(minHeight, maxHeight) {
        const query = {
            method: requests.Method.Blockchain,
            params: {
                minHeight: minHeight,
                maxHeight: maxHeight
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
    }
    /**
     * Broadcast transaction to mempool and wait for response
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */ async broadcastTxSync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxSync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
    }
    /**
     * Broadcast transaction to mempool and do not wait for result
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */ async broadcastTxAsync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxAsync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
    }
    /**
     * Broadcast transaction to mempool and wait for block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
     */ async broadcastTxCommit(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxCommit
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
    }
    async commit(height) {
        const query = {
            method: requests.Method.Commit,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
    }
    async genesis() {
        const query = {
            method: requests.Method.Genesis
        };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
    }
    async health() {
        const query = {
            method: requests.Method.Health
        };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
    }
    async numUnconfirmedTxs() {
        const query = {
            method: requests.Method.NumUnconfirmedTxs
        };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
    }
    async status() {
        const query = {
            method: requests.Method.Status
        };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
    }
    subscribeNewBlock() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlock
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
    }
    subscribeNewBlockHeader() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlockHeader
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
    }
    subscribeTx(query) {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.Tx,
                raw: query
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
    }
    /**
     * Get a single transaction by hash
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx
     */ async tx(params) {
        const query = {
            params: params,
            method: requests.Method.Tx
        };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
    }
    /**
     * Search for transactions that are in a block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
     */ async txSearch(params) {
        const query = {
            params: params,
            method: requests.Method.TxSearch
        };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
    }
    // this should paginate through all txSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while(!done){
            const resp = await this.txSearch({
                ...params,
                page: page
            });
            txs.push(...resp.txs);
            if (txs.length < resp.totalCount) page++;
            else done = true;
        }
        return {
            totalCount: txs.length,
            txs: txs
        };
    }
    async validators(params) {
        const query = {
            method: requests.Method.Validators,
            params: params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
    }
    async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while(!done){
            const response = await this.validators({
                per_page: 50,
                height: blockHeight,
                page: page
            });
            validators.push(...response.validators);
            blockHeight = blockHeight || response.blockHeight;
            if (validators.length < response.total) page++;
            else done = true;
        }
        return {
            // NOTE: Default value is for type safety but this should always be set
            blockHeight: blockHeight ?? 0,
            count: validators.length,
            total: validators.length,
            validators: validators
        };
    }
    // doCall is a helper to handle the encode/call/decode logic
    async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
    }
    subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) throw new Error("This RPC client type cannot subscribe to events");
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event)=>{
            return decode(event);
        });
    }
}
exports.Tendermint37Client = Tendermint37Client;

},{"302a8b1f6eae4136":"4i1Up","39d13fa2dd00da27":"81bdq","f17521a4c1f79b04":"ewT62"}],"81bdq":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.Params = void 0;
var requests_1 = require("61233c389aa2c0ce");
Object.defineProperty(exports, "Params", {
    enumerable: true,
    get: function() {
        return requests_1.Params;
    }
});
var responses_1 = require("8123d30b9be627f1");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
});

},{"61233c389aa2c0ce":"6dxOR","8123d30b9be627f1":"k8Ohw"}],"6dxOR":[function(require,module,exports,__globalThis) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("f7d4482b86c9ea02");
const inthelpers_1 = require("acc4e0d31c0154e0");
const jsonrpc_1 = require("4e7a090368f1ee1c");
const encodings_1 = require("4b8bc3bf6f83083e");
const requests = __importStar(require("86dc9aa44d7a382c"));
function encodeHeightParam(param) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
    };
}
function encodeBlockchainRequestParams(param) {
    return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
    };
}
function encodeBlockSearchParams(params) {
    return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeAbciQueryParams(params) {
    return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
    };
}
function encodeBroadcastTxParams(params) {
    return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
    };
}
function encodeTxParams(params) {
    return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
    };
}
function encodeTxSearchParams(params) {
    return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeValidatorsParams(params) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
    };
}
class Params {
    static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
    }
    static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
    }
    static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
    }
    static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
    }
    static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeSubscribe(req) {
        const eventTag = {
            key: "tm.event",
            value: req.query.type
        };
        const query = requests.buildQuery({
            tags: [
                eventTag
            ],
            raw: req.query.raw
        });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", {
            query: query
        });
    }
    static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
    }
    // TODO: encode params for query string???
    static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
    }
    static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
    }
}
exports.Params = Params;

},{"f7d4482b86c9ea02":"enCPS","acc4e0d31c0154e0":"4rUrR","4e7a090368f1ee1c":"apgCO","4b8bc3bf6f83083e":"7KCCe","86dc9aa44d7a382c":"ewT62"}],"7KCCe":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertSet = assertSet;
exports.assertBoolean = assertBoolean;
exports.assertString = assertString;
exports.assertNumber = assertNumber;
exports.assertArray = assertArray;
exports.assertObject = assertObject;
exports.assertNotEmpty = assertNotEmpty;
exports.may = may;
exports.dictionaryToStringMap = dictionaryToStringMap;
exports.encodeString = encodeString;
exports.encodeUvarint = encodeUvarint;
exports.encodeTime = encodeTime;
exports.encodeBytes = encodeBytes;
exports.encodeVersion = encodeVersion;
exports.encodeBlockId = encodeBlockId;
const encoding_1 = require("8cb65f92695381b2");
/**
 * A runtime checker that ensures a given value is set (i.e. not undefined or null)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 */ function assertSet(value) {
    if (value === undefined) throw new Error("Value must not be undefined");
    if (value === null) throw new Error("Value must not be null");
    return value;
}
/**
 * A runtime checker that ensures a given value is a boolean
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertBoolean(value) {
    assertSet(value);
    if (typeof value !== "boolean") throw new Error("Value must be a boolean");
    return value;
}
/**
 * A runtime checker that ensures a given value is a string.
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertString(value) {
    assertSet(value);
    if (typeof value !== "string") throw new Error("Value must be a string");
    return value;
}
/**
 * A runtime checker that ensures a given value is a number
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertNumber(value) {
    assertSet(value);
    if (typeof value !== "number") throw new Error("Value must be a number");
    return value;
}
/**
 * A runtime checker that ensures a given value is an array
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertArray(value) {
    assertSet(value);
    if (!Array.isArray(value)) throw new Error("Value must be an array");
    return value;
}
/**
 * A runtime checker that ensures a given value is an object in the sense of JSON
 * (an unordered collection of keyvalue pairs where the keys are strings)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertObject(value) {
    assertSet(value);
    if (typeof value !== "object") throw new Error("Value must be an object");
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") throw new Error("Value must be a simple object");
    return value;
}
/**
 * Throws an error if value matches the empty value for the
 * given type (array/string of length 0, number of value 0, ...)
 *
 * Otherwise returns the value.
 *
 * This implies assertSet
 */ function assertNotEmpty(value) {
    assertSet(value);
    if (typeof value === "number" && value === 0) throw new Error("must provide a non-zero value");
    else if (value.length === 0) throw new Error("must provide a non-empty value");
    return value;
}
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
function dictionaryToStringMap(obj) {
    const out = new Map();
    for (const key of Object.keys(obj)){
        const value = obj[key];
        if (typeof value !== "string") throw new Error("Found dictionary value of type other than string");
        out.set(key, value);
    }
    return out;
}
// Encodings needed for hashing block headers
// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195
function encodeString(s) {
    const utf8 = (0, encoding_1.toUtf8)(s);
    return Uint8Array.from([
        utf8.length,
        ...utf8
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87
function encodeUvarint(n) {
    return n >= 0x80 ? Uint8Array.from([
        n & 0xff | 0x80,
        ...encodeUvarint(n >> 7)
    ]) : Uint8Array.from([
        n & 0xff
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178
function encodeTime(time) {
    const milliseconds = time.getTime();
    const seconds = Math.floor(milliseconds / 1000);
    const secondsArray = seconds ? [
        0x08,
        ...encodeUvarint(seconds)
    ] : new Uint8Array();
    const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;
    const nanosecondsArray = nanoseconds ? [
        0x10,
        ...encodeUvarint(nanoseconds)
    ] : new Uint8Array();
    return Uint8Array.from([
        ...secondsArray,
        ...nanosecondsArray
    ]);
}
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187
function encodeBytes(bytes) {
    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet
    if (bytes.length >= 0x80) throw new Error("Not implemented for byte arrays of length 128 or more");
    return bytes.length ? Uint8Array.from([
        bytes.length,
        ...bytes
    ]) : new Uint8Array();
}
function encodeVersion(version) {
    const blockArray = version.block ? Uint8Array.from([
        0x08,
        ...encodeUvarint(version.block)
    ]) : new Uint8Array();
    const appArray = version.app ? Uint8Array.from([
        0x10,
        ...encodeUvarint(version.app)
    ]) : new Uint8Array();
    return Uint8Array.from([
        ...blockArray,
        ...appArray
    ]);
}
function encodeBlockId(blockId) {
    return Uint8Array.from([
        0x0a,
        blockId.hash.length,
        ...blockId.hash,
        0x12,
        blockId.parts.hash.length + 4,
        0x08,
        blockId.parts.total,
        0x12,
        blockId.parts.hash.length,
        ...blockId.parts.hash
    ]);
}

},{"8cb65f92695381b2":"enCPS"}],"k8Ohw":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = void 0;
exports.decodeEvent = decodeEvent;
exports.decodeValidatorUpdate = decodeValidatorUpdate;
exports.decodeValidatorGenesis = decodeValidatorGenesis;
exports.decodeValidatorInfo = decodeValidatorInfo;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = require("5cfa7848d5451261");
const utils_1 = require("46fbb968a20859d5");
const dates_1 = require("f77a1be6b9569b42");
const inthelpers_1 = require("90fdfb52c006e062");
const types_1 = require("17c3a85cf7669470");
const encodings_1 = require("ff55e1c92e31ce50");
const hasher_1 = require("ac9a242b823e4140");
function decodeAbciInfo(data) {
    return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
    };
}
function decodeQueryProof(data) {
    return {
        ops: data.ops.map((op)=>({
                type: op.type,
                key: (0, encoding_1.fromBase64)(op.key),
                data: (0, encoding_1.fromBase64)(op.data)
            }))
    };
}
function decodeAbciQuery(data) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
    };
}
function decodeEventAttribute(attribute) {
    return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
    };
}
function decodeAttributes(attributes) {
    return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
}
function decodeEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
    };
}
function decodeEvents(events) {
    return (0, encodings_1.assertArray)(events).map(decodeEvent);
}
function decodeTxData(data) {
    return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
    };
}
function decodePubkey(data) {
    if ("Sum" in data) {
        // we don't need to check type because we're checking algorithm
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
            algorithm,
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
    } else switch(data.type){
        // go-amino special code
        case "tendermint/PubKeyEd25519":
            return {
                algorithm: "ed25519",
                data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
        case "tendermint/PubKeySecp256k1":
            return {
                algorithm: "secp256k1",
                data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
        default:
            throw new Error(`unknown pubkey type: ${data.type}`);
    }
}
/**
 * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry
 *
 * > Add time_iota_ms to block's consensus parameters (not exposed to the application)
 * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310
 */ function decodeBlockParams(data) {
    return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
    };
}
function decodeEvidenceParams(data) {
    return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
    };
}
function decodeConsensusParams(data) {
    return {
        block: data.block ? decodeBlockParams((0, encodings_1.assertObject)(data.block)) : undefined,
        evidence: data.evidence ? decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence)) : undefined
    };
}
function decodeValidatorUpdate(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
    };
}
function decodeBlockResults(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
    };
}
function decodeBlockId(data) {
    return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
            total: (0, encodings_1.assertNotEmpty)(data.parts.total),
            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
    };
}
function decodeBlockVersion(data) {
    return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
    };
}
function decodeHeader(data) {
    return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
    };
}
function decodeBlockMeta(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
    };
}
function decodeBlockchain(data) {
    return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
    };
}
function decodeBroadcastTxSync(data) {
    return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
    };
}
function decodeBroadcastTxCommit(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
    };
}
function decodeBlockIdFlag(blockIdFlag) {
    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
    return blockIdFlag;
}
function decodeCommitSignature(data) {
    return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : undefined,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined
    };
}
function decodeCommit(data) {
    return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
    };
}
function decodeCommitResponse(data) {
    return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
    };
}
function decodeValidatorGenesis(data) {
    return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
    };
}
function decodeGenesis(data) {
    return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
    };
}
function decodeValidatorInfo(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined
    };
}
function decodeNodeInfo(data) {
    return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertString)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
            app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
            block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
            p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
    };
}
function decodeSyncInfo(data) {
    const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : undefined;
    const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : undefined;
    return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : undefined,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : undefined,
        earliestBlockHeight: earliestBlockHeight || undefined,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : undefined,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
    };
}
function decodeStatus(data) {
    return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
    };
}
function decodeTxProof(data) {
    return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
            total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
            index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
    };
}
function decodeTxResponse(data) {
    return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
    };
}
function decodeTxSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
    };
}
function decodeTxEvent(data) {
    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
    return {
        tx: tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
    };
}
function decodeValidators(data) {
    return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
    };
}
function decodeBlock(data) {
    return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
    };
}
function decodeBlockResponse(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
    };
}
function decodeBlockSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
    };
}
function decodeNumUnconfirmedTxs(data) {
    return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
    };
}
class Responses {
    static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeBlock(response) {
        return decodeBlockResponse(response.result);
    }
    static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
    }
    static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
    }
    static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
    }
    static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
    }
    static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
    }
    static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
    }
    static decodeCommit(response) {
        return decodeCommitResponse(response.result);
    }
    static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
    }
    static decodeHealth() {
        return null;
    }
    static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
    }
    static decodeStatus(response) {
        return decodeStatus(response.result);
    }
    static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
    }
    static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
    }
    static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
    }
    static decodeTx(response) {
        return decodeTxResponse(response.result);
    }
    static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
    }
    static decodeValidators(response) {
        return decodeValidators(response.result);
    }
}
exports.Responses = Responses;

},{"5cfa7848d5451261":"enCPS","46fbb968a20859d5":"3R4mb","f77a1be6b9569b42":"aYDXm","90fdfb52c006e062":"4rUrR","17c3a85cf7669470":"f88Rz","ff55e1c92e31ce50":"7KCCe","ac9a242b823e4140":"6zW90"}],"6zW90":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashTx = hashTx;
exports.hashBlock = hashBlock;
const crypto_1 = require("f1a81189b6324db5");
const encodings_1 = require("94dd4b9e012c1814");
// hash is sha256
// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260
function hashTx(tx) {
    return (0, crypto_1.sha256)(tx);
}
function getSplitPoint(n) {
    if (n < 1) throw new Error("Cannot split an empty tree");
    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
}
function hashLeaf(leaf) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        0
    ]));
    hash.update(leaf);
    return hash.digest();
}
function hashInner(left, right) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        1
    ]));
    hash.update(left);
    hash.update(right);
    return hash.digest();
}
// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot
// Note: the hashes input may not actually be hashes, especially before a recursive call
function hashTree(hashes) {
    switch(hashes.length){
        case 0:
            throw new Error("Cannot hash empty tree");
        case 1:
            return hashLeaf(hashes[0]);
        default:
            {
                const slicePoint = getSplitPoint(hashes.length);
                const left = hashTree(hashes.slice(0, slicePoint));
                const right = hashTree(hashes.slice(slicePoint));
                return hashInner(left, right);
            }
    }
}
function hashBlock(header) {
    if (!header.lastBlockId) throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
    const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
    ];
    return hashTree(encodedFields);
}

},{"f1a81189b6324db5":"kTd5b","94dd4b9e012c1814":"7KCCe"}],"7IF1D":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isTendermint34Client = isTendermint34Client;
exports.isTendermint37Client = isTendermint37Client;
exports.isComet38Client = isComet38Client;
exports.connectComet = connectComet;
const comet38_1 = require("43acecb53e39d764");
const tendermint34_1 = require("5e742d4186c8b1ef");
const tendermint37_1 = require("f8ab0ba51ca0728d");
function isTendermint34Client(client) {
    return client instanceof tendermint34_1.Tendermint34Client;
}
function isTendermint37Client(client) {
    return client instanceof tendermint37_1.Tendermint37Client;
}
function isComet38Client(client) {
    return client instanceof comet38_1.Comet38Client;
}
/**
 * Auto-detects the version of the backend and uses a suitable client.
 */ async function connectComet(endpoint) {
    // Tendermint/CometBFT 0.34/0.37/0.38 auto-detection. Starting with 0.37 we seem to get reliable versions again 
    // Using 0.34 as the fallback.
    let out;
    const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
    const version = (await tm37Client.status()).nodeInfo.version;
    if (version.startsWith("0.37.")) out = tm37Client;
    else if (version.startsWith("0.38.") || version.startsWith("1.0.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
    } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
    }
    return out;
}

},{"43acecb53e39d764":"cDSHN","5e742d4186c8b1ef":"ieXXt","f8ab0ba51ca0728d":"aFn6G"}],"f7GTj":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StargateClient = exports.BroadcastTxError = exports.TimeoutError = void 0;
exports.isDeliverTxFailure = isDeliverTxFailure;
exports.isDeliverTxSuccess = isDeliverTxSuccess;
exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
const amino_1 = require("1d401fa53b8b95b5");
const encoding_1 = require("32f48f2830b2adad");
const math_1 = require("4f4a721be2fb55ed");
const tendermint_rpc_1 = require("b087723df5e0ebd1");
const utils_1 = require("dbef3514652d9e2b");
const abci_1 = require("2fbd486c2fd0a0db");
const accounts_1 = require("9e16e207a8195251");
const events_1 = require("fcb80a10c68ccf12");
const modules_1 = require("85ca79a7584f55da");
const queryclient_1 = require("a78b8868a08d0656");
const search_1 = require("bd1b0490900c084d");
class TimeoutError extends Error {
    txId;
    constructor(message, txId){
        super(message);
        this.txId = txId;
    }
}
exports.TimeoutError = TimeoutError;
function isDeliverTxFailure(result) {
    return !!result.code;
}
function isDeliverTxSuccess(result) {
    return !isDeliverTxFailure(result);
}
/**
 * Ensures the given result is a success. Throws a detailed error message otherwise.
 */ function assertIsDeliverTxSuccess(result) {
    if (isDeliverTxFailure(result)) throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
}
/**
 * Ensures the given result is a failure. Throws a detailed error message otherwise.
 */ function assertIsDeliverTxFailure(result) {
    if (isDeliverTxSuccess(result)) throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
}
/**
 * An error when broadcasting the transaction. This contains the CheckTx errors
 * from the blockchain. Once a transaction is included in a block no BroadcastTxError
 * is thrown, even if the execution fails (DeliverTx errors).
 */ class BroadcastTxError extends Error {
    code;
    codespace;
    log;
    constructor(code, codespace, log){
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
    }
}
exports.BroadcastTxError = BroadcastTxError;
class StargateClient {
    cometClient;
    queryClient;
    chainId;
    accountParser;
    /**
     * Creates an instance by connecting to the given CometBFT RPC endpoint.
     *
     * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
     * To set the Comet client explicitly, use `create`.
     */ static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return StargateClient.create(cometClient, options);
    }
    /**
     * Creates an instance from a manually created Comet client.
     * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
     */ static create(cometClient, options = {}) {
        return new StargateClient(cometClient, options);
    }
    constructor(cometClient, options){
        if (cometClient) {
            this.cometClient = cometClient;
            this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
    }
    getCometClient() {
        return this.cometClient;
    }
    forceGetCometClient() {
        if (!this.cometClient) throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        return this.cometClient;
    }
    getQueryClient() {
        return this.queryClient;
    }
    forceGetQueryClient() {
        if (!this.queryClient) throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        return this.queryClient;
    }
    async getChainId() {
        if (!this.chainId) {
            const response = await this.forceGetCometClient().status();
            const chainId = response.nodeInfo.network;
            if (!chainId) throw new Error("Chain ID must not be empty");
            this.chainId = chainId;
        }
        return this.chainId;
    }
    async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
    }
    async getAccount(searchAddress) {
        try {
            const account = await this.forceGetQueryClient().auth.account(searchAddress);
            return account ? this.accountParser(account) : null;
        } catch (error) {
            if (/rpc error: code = NotFound/i.test(error.toString())) return null;
            throw error;
        }
    }
    async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        return {
            accountNumber: account.accountNumber,
            sequence: account.sequence
        };
    }
    async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
            id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
            header: {
                version: {
                    block: new math_1.Uint53(response.block.header.version.block).toString(),
                    app: new math_1.Uint53(response.block.header.version.app).toString()
                },
                height: response.block.header.height,
                chainId: response.block.header.chainId,
                time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
            },
            txs: response.block.txs
        };
    }
    async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
    }
    /**
     * Queries all balances for all denoms that belong to this address.
     *
     * Uses the grpc queries (which iterates over the store internally), and we cannot get
     * proofs from such a method.
     */ async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
    }
    async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = undefined;
        do {
            const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
            const loadedDelegations = delegationResponses || [];
            allDelegations.push(...loadedDelegations);
            startAtKey = pagination?.nextKey;
        }while (startAtKey !== undefined && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue)=>{
            // Safe because field is set to non-nullable (https://github.com/cosmos/cosmos-sdk/blob/v0.45.3/proto/cosmos/staking/v1beta1/staking.proto#L295)
            (0, utils_1.assert)(currentValue.balance);
            return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
    }
    async getDelegation(delegatorAddress, validatorAddress) {
        let delegatedAmount;
        try {
            delegatedAmount = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse?.balance;
        } catch (e) {
            if (e.toString().includes("key not found")) ;
            else throw e;
        }
        return delegatedAmount || null;
    }
    async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
    }
    async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") rawQuery = query;
        else if ((0, search_1.isSearchTxQueryArray)(query)) rawQuery = query.map((t)=>{
            // numeric values must not have quotes https://github.com/cosmos/cosmjs/issues/1462
            if (typeof t.value === "string") return `${t.key}='${t.value}'`;
            else return `${t.key}=${t.value}`;
        }).join(" AND ");
        else throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        return this.txsQuery(rawQuery);
    }
    disconnect() {
        if (this.cometClient) this.cometClient.disconnect();
    }
    /**
     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
     *
     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
     * an error is thrown.
     *
     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
     *
     * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
     * usually needs to check for execution success or failure.
     */ async broadcastTx(tx, timeoutMs = 60000, pollIntervalMs = 3000) {
        let timedOut = false;
        const txPollTimeout = setTimeout(()=>{
            timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId)=>{
            if (timedOut) throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1000} seconds.`, txId);
            await (0, utils_1.sleep)(pollIntervalMs);
            const result = await this.getTx(txId);
            return result ? {
                code: result.code,
                height: result.height,
                txIndex: result.txIndex,
                events: result.events,
                rawLog: result.rawLog,
                transactionHash: txId,
                msgResponses: result.msgResponses,
                gasUsed: result.gasUsed,
                gasWanted: result.gasWanted
            } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject)=>pollForTx(transactionId).then((value)=>{
                clearTimeout(txPollTimeout);
                resolve(value);
            }, (error)=>{
                clearTimeout(txPollTimeout);
                reject(error);
            }));
    }
    /**
     * Broadcasts a signed transaction to the network without monitoring it.
     *
     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
     * an error is thrown.
     *
     * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
     * usually needs to check if the transaction was included in a block and was successful.
     *
     * @returns Returns the hash of the transaction
     */ async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({
            tx
        });
        if (broadcasted.code) return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
    }
    async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({
            query: query
        });
        return results.txs.map((tx)=>{
            const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
            return {
                height: tx.height,
                txIndex: tx.index,
                hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
                code: tx.result.code,
                events: tx.result.events.map(events_1.fromTendermintEvent),
                rawLog: tx.result.log || "",
                tx: tx.tx,
                msgResponses: txMsgData.msgResponses,
                gasUsed: tx.result.gasUsed,
                gasWanted: tx.result.gasWanted
            };
        });
    }
}
exports.StargateClient = StargateClient;

},{"1d401fa53b8b95b5":"bh8mf","32f48f2830b2adad":"enCPS","4f4a721be2fb55ed":"e8aug","b087723df5e0ebd1":"5uMVU","dbef3514652d9e2b":"3R4mb","2fbd486c2fd0a0db":"jt1ue","9e16e207a8195251":"inL4M","fcb80a10c68ccf12":"UX70m","85ca79a7584f55da":"MIuAK","a78b8868a08d0656":"cM4fi","bd1b0490900c084d":"8KORu"}]},["j8273","4ZGjQ"], "4ZGjQ", "parcelRequirea3ed", {})

//# sourceMappingURL=dapp.f72d0d54.js.map
